=== PROJETO: animehub ===
=== ESTRUTURA VISUAL ===
.
â”œâ”€â”€ DIR docs
â”‚   â”œâ”€â”€ [X] DATA_MODEL.md
â”‚   â”œâ”€â”€ [X] DOMAIN_CONTRACTS.md
â”‚   â”œâ”€â”€ [X] EVENT_MAP.md
â”‚   â”œâ”€â”€ [X] FOUNDATION SEAL.md
â”‚   â”œâ”€â”€ [X] README.md
â”‚   â”œâ”€â”€ [X] SERVICE_CONTRACTS.md
â”‚   â”œâ”€â”€ [X] UI_LAYOUT.md
â”‚   â””â”€â”€ [X] UI_PRINCIPLES.md
â”œâ”€â”€ DIR .svelte-kit
â”‚   â”œâ”€â”€ DIR generated
â”‚   â”‚   â”œâ”€â”€ DIR client
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR nodes
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] 0.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] 1.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] 2.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] 3.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] 4.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] 5.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] 6.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] 7.js
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] app.js
â”‚   â”‚   â”‚   â””â”€â”€ [X] matchers.js
â”‚   â”‚   â”œâ”€â”€ DIR server
â”‚   â”‚   â”‚   â””â”€â”€ [X] internal.js
â”‚   â”‚   â”œâ”€â”€ [X] root.js
â”‚   â”‚   â””â”€â”€ [X] root.svelte
â”‚   â”œâ”€â”€ DIR types
â”‚   â”‚   â”œâ”€â”€ DIR src
â”‚   â”‚   â”‚   â””â”€â”€ DIR routes
â”‚   â”‚   â”‚       â”œâ”€â”€ DIR anime
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ DIR [id]
â”‚   â”‚   â”‚       â”‚       â””â”€â”€ [X] $types.d.ts
â”‚   â”‚   â”‚       â”œâ”€â”€ DIR calendar
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ [X] $types.d.ts
â”‚   â”‚   â”‚       â”œâ”€â”€ DIR library
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ [X] $types.d.ts
â”‚   â”‚   â”‚       â”œâ”€â”€ DIR statistics
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ [X] $types.d.ts
â”‚   â”‚   â”‚       â”œâ”€â”€ DIR subtitles
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ [X] $types.d.ts
â”‚   â”‚   â”‚       â””â”€â”€ [X] $types.d.ts
â”‚   â”‚   â””â”€â”€ [X] route_meta_data.json
â”‚   â”œâ”€â”€ [X] ambient.d.ts
â”‚   â”œâ”€â”€ [X] non-ambient.d.ts
â”‚   â””â”€â”€ [ ] tsconfig.json
â”œâ”€â”€ DIR src
â”‚   â”œâ”€â”€ DIR lib
â”‚   â”‚   â”œâ”€â”€ DIR api
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] anime.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] episode.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] file.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] playback.ts
â”‚   â”‚   â”‚   â””â”€â”€ [X] subtitle.ts
â”‚   â”‚   â”œâ”€â”€ DIR components
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR anime
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] AnimeHeader.svelte
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] EpisodeItem.svelte
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] EpisodeList.svelte
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR calendar
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR common
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] Sidebar.svelte
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR library
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] AnimeCard.svelte
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] AnimeGrid.svelte
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR player
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR statistics
â”‚   â”‚   â”‚   â””â”€â”€ DIR subtitles
â”‚   â”‚   â”œâ”€â”€ DIR stores
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] anime.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] episode.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] playback.ts
â”‚   â”‚   â”‚   â””â”€â”€ [X] ui.ts
â”‚   â”‚   â””â”€â”€ DIR types
â”‚   â”‚       â”œâ”€â”€ [X] anime.ts
â”‚   â”‚       â”œâ”€â”€ [X] episode.ts
â”‚   â”‚       â”œâ”€â”€ [X] events.ts
â”‚   â”‚       â”œâ”€â”€ [X] file.ts
â”‚   â”‚       â””â”€â”€ [X] subtitle.ts
â”‚   â”œâ”€â”€ DIR routes
â”‚   â”‚   â”œâ”€â”€ DIR anime
â”‚   â”‚   â”‚   â””â”€â”€ DIR [id]
â”‚   â”‚   â”‚       â””â”€â”€ [X] +page.svelte
â”‚   â”‚   â”œâ”€â”€ DIR calendar
â”‚   â”‚   â”‚   â””â”€â”€ [X] +page.svelte
â”‚   â”‚   â”œâ”€â”€ DIR library
â”‚   â”‚   â”‚   â””â”€â”€ [X] +page.svelte
â”‚   â”‚   â”œâ”€â”€ DIR statistics
â”‚   â”‚   â”‚   â””â”€â”€ [X] +page.svelte
â”‚   â”‚   â”œâ”€â”€ DIR subtitles
â”‚   â”‚   â”‚   â””â”€â”€ [X] +page.svelte
â”‚   â”‚   â”œâ”€â”€ [X] +layout.svelte
â”‚   â”‚   â””â”€â”€ [X] +page.svelte
â”‚   â”œâ”€â”€ [X] app.css
â”‚   â””â”€â”€ [X] app.html
â”œâ”€â”€ DIR src-tauri
â”‚   â”œâ”€â”€ DIR capabilities
â”‚   â”‚   â””â”€â”€ [X] default.json
â”‚   â”œâ”€â”€ DIR examples
â”‚   â”‚   â”œâ”€â”€ [X] anilist_query.rs
â”‚   â”‚   â”œâ”€â”€ [X] mpv_test.rs
â”‚   â”‚   â”œâ”€â”€ [X] playback_e2e_test.rs
â”‚   â”‚   â”œâ”€â”€ [X] playback_event_validation_test.rs
â”‚   â”‚   â”œâ”€â”€ [X] playback_invalid_state_test.rs
â”‚   â”‚   â””â”€â”€ [X] scan_validation_test.rs
â”‚   â”œâ”€â”€ DIR gen
â”‚   â”‚   â””â”€â”€ DIR schemas
â”‚   â”‚       â”œâ”€â”€ [X] acl-manifests.json
â”‚   â”‚       â”œâ”€â”€ [X] capabilities.json
â”‚   â”‚       â”œâ”€â”€ [ ] desktop-schema.json
â”‚   â”‚       â””â”€â”€ [ ] windows-schema.json
â”‚   â”œâ”€â”€ DIR icons
â”‚   â”‚   â”œâ”€â”€ DIR android
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR mipmap-anydpi-v26
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [ ] ic_launcher.xml
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR mipmap-hdpi
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] ic_launcher.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] ic_launcher_foreground.png
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [ ] ic_launcher_round.png
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR mipmap-mdpi
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] ic_launcher.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] ic_launcher_foreground.png
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [ ] ic_launcher_round.png
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR mipmap-xhdpi
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] ic_launcher.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] ic_launcher_foreground.png
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [ ] ic_launcher_round.png
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR mipmap-xxhdpi
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] ic_launcher.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] ic_launcher_foreground.png
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [ ] ic_launcher_round.png
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR mipmap-xxxhdpi
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] ic_launcher.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] ic_launcher_foreground.png
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [ ] ic_launcher_round.png
â”‚   â”‚   â”‚   â””â”€â”€ DIR values
â”‚   â”‚   â”‚       â””â”€â”€ [ ] ic_launcher_background.xml
â”‚   â”‚   â”œâ”€â”€ DIR ios
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-20x20@1x.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-20x20@2x-1.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-20x20@2x.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-20x20@3x.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-29x29@1x.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-29x29@2x-1.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-29x29@2x.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-29x29@3x.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-40x40@1x.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-40x40@2x-1.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-40x40@2x.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-40x40@3x.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-512@2x.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-60x60@2x.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-60x60@3x.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-76x76@1x.png
â”‚   â”‚   â”‚   â”œâ”€â”€ [ ] AppIcon-76x76@2x.png
â”‚   â”‚   â”‚   â””â”€â”€ [ ] AppIcon-83.5x83.5@2x.png
â”‚   â”‚   â”œâ”€â”€ [ ] 128x128.png
â”‚   â”‚   â”œâ”€â”€ [ ] 128x128@2x.png
â”‚   â”‚   â”œâ”€â”€ [ ] 32x32.png
â”‚   â”‚   â”œâ”€â”€ [ ] 64x64.png
â”‚   â”‚   â”œâ”€â”€ [ ] icon.icns
â”‚   â”‚   â”œâ”€â”€ [ ] icon.ico
â”‚   â”‚   â”œâ”€â”€ [ ] icon.png
â”‚   â”‚   â”œâ”€â”€ [ ] Square107x107Logo.png
â”‚   â”‚   â”œâ”€â”€ [ ] Square142x142Logo.png
â”‚   â”‚   â”œâ”€â”€ [ ] Square150x150Logo.png
â”‚   â”‚   â”œâ”€â”€ [ ] Square284x284Logo.png
â”‚   â”‚   â”œâ”€â”€ [ ] Square30x30Logo.png
â”‚   â”‚   â”œâ”€â”€ [ ] Square310x310Logo.png
â”‚   â”‚   â”œâ”€â”€ [ ] Square44x44Logo.png
â”‚   â”‚   â”œâ”€â”€ [ ] Square71x71Logo.png
â”‚   â”‚   â”œâ”€â”€ [ ] Square89x89Logo.png
â”‚   â”‚   â””â”€â”€ [ ] StoreLogo.png
â”‚   â”œâ”€â”€ DIR src
â”‚   â”‚   â”œâ”€â”€ DIR application
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR commands
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] anime_commands.rs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] episode_commands.rs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] file_commands.rs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] playback_commands.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] statistics_commands.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR dto
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] error_handling.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â””â”€â”€ [X] state.rs
â”‚   â”‚   â”œâ”€â”€ DIR db
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] connection.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] migrations.rs
â”‚   â”‚   â”‚   â””â”€â”€ [X] mod.rs
â”‚   â”‚   â”œâ”€â”€ DIR domain
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR anime
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] entity.rs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] invariants.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR collection
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] entity.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR episode
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] entity.rs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] invariants.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR file
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] entity.rs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] invariants.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR models
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] statistics.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR resolution
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] value_objects.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR statistics
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] entity.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR subtitle
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] entity.rs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] invariants.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] anime_alias.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] external_reference.rs
â”‚   â”‚   â”‚   â””â”€â”€ [X] mod.rs
â”‚   â”‚   â”œâ”€â”€ DIR error
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â””â”€â”€ [X] types.rs
â”‚   â”‚   â”œâ”€â”€ DIR events
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR bus
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] event_bus.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR handlers
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] resolution_events.rs
â”‚   â”‚   â”‚   â””â”€â”€ [X] types.rs
â”‚   â”‚   â”œâ”€â”€ DIR infrastructure
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â””â”€â”€ [X] subtitle_workspace.rs
â”‚   â”‚   â”œâ”€â”€ DIR integrations
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR anilist
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] client.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR mpv
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] client.rs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] windows.rs
â”‚   â”‚   â”‚   â””â”€â”€ [X] mod.rs
â”‚   â”‚   â”œâ”€â”€ DIR repositories
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR sqlite
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] sqlite_episode_repository.rs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [X] sqlite_file_repository.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] sqlite_statistics_repository.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] anime_alias_repository.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] anime_repository.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] collection_repository.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] episode_repository.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] external_reference_repository.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] file_repository.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] statistics_repository.rs
â”‚   â”‚   â”‚   â””â”€â”€ [X] subtitle_repository.rs
â”‚   â”‚   â”œâ”€â”€ DIR services
â”‚   â”‚   â”‚   â”œâ”€â”€ DIR services
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] anime_service.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] episode_service.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] external_integration_service.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] file_service.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] playback_observer.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] playback_service.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] resolution_service.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] resolution_service_tests.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ [X] statistics_service.rs
â”‚   â”‚   â”‚   â””â”€â”€ [X] subtitle_service.rs
â”‚   â”‚   â”œâ”€â”€ DIR utils
â”‚   â”‚   â”œâ”€â”€ [X] lib.rs
â”‚   â”‚   â””â”€â”€ [X] main.rs
â”‚   â”œâ”€â”€ [X] build.rs
â”‚   â”œâ”€â”€ [ ] Cargo.lock
â”‚   â”œâ”€â”€ [X] Cargo.toml
â”‚   â”œâ”€â”€ [X] schema.sql
â”‚   â””â”€â”€ [X] tauri.conf.json
â”œâ”€â”€ [ ] .gitignore
â”œâ”€â”€ [ ] app-icon.png
â”œâ”€â”€ [ ] contexto_animehub.txt
â”œâ”€â”€ [X] EVENTS_SYSTEM_DESIGN.md
â”œâ”€â”€ [ ] pack.py
â”œâ”€â”€ [ ] package-lock.json
â”œâ”€â”€ [X] package.json
â”œâ”€â”€ [ ] postcss.config.js
â”œâ”€â”€ [X] README.md
â”œâ”€â”€ [X] svelte.config.js
â”œâ”€â”€ [X] tailwind.config.js
â”œâ”€â”€ [ ] tsconfig.json
â””â”€â”€ [X] vite.config.ts

============================================================
CONTEÃšDO DOS ARQUIVOS (Ordenado: Docs -> Source)
============================================================

--- FILE: docs\DATA_MODEL.md ---
AnimeHub â€” Modelo de Dados CanÃ´nico

Este documento define quais dados existem,
como se relacionam,
e quais estados sÃ£o vÃ¡lidos no AnimeHub.

Ele Ã© o reflexo direto e obrigatÃ³rio de:

DOMAIN_CONTRACTS.md

EVENT_MAP.md

SERVICE_CONTRACTS.md

Se algo nÃ£o estiver aqui, nÃ£o existe no sistema.

0. PRINCÃPIOS DO MODELO DE DADOS
0.1 Fonte de verdade

Entidades primÃ¡rias:

Anime

Episode

File

Subtitle

Collection

Entidades derivadas:

Statistics

Eventos:

Podem ser persistidos

Nunca substituem estado primÃ¡rio

0.2 Identidade e mutabilidade

Toda entidade possui:

ID interno imutÃ¡vel

IDs externos:

SÃ£o auxiliares

Nunca substituem identidade interna

Nenhum dado crÃ­tico Ã© sobrescrito sem:

Versionamento

HistÃ³rico preservado

0.3 RelaÃ§Ãµes explÃ­citas

NÃ£o existem relaÃ§Ãµes implÃ­citas

Nenhuma inferÃªncia automÃ¡tica Ã© permitida

1. ENTIDADE: ANIME
Identidade

anime_id (interno, imutÃ¡vel)

Campos conceituais

titulo_principal

titulos_alternativos

tipo (TV | Movie | OVA | Special)

status (em_exibicao | finalizado | cancelado)

total_episodios (opcional)

data_inicio (opcional)

data_fim (opcional)

metadados_livres

criado_em

atualizado_em

RelaÃ§Ãµes

1:N â†’ Episode

N:M â†’ Collection

1:N â†’ ExternalReference

1:N â†’ AnimeAlias

Estados vÃ¡lidos

Anime pode existir:

Sem episÃ³dios

Sem arquivos

Sem referÃªncias externas

2. ENTIDADE: EPISODE
Identidade

episode_id (interno)

Campos conceituais

anime_id (obrigatÃ³rio)

numero (inteiro ou especial)

titulo (opcional)

duracao_esperada (opcional)

progresso_atual

estado (nao_visto | em_progresso | concluido)

criado_em

atualizado_em

RelaÃ§Ãµes

N:1 â†’ Anime

1:N â†’ File (associados)

0..1 â†’ File (arquivo_principal)

Estados vÃ¡lidos

Episode:

Nunca existe sem Anime

Pode existir sem arquivo

Assume uma versÃ£o prÃ¡tica

3. ENTIDADE: FILE
Identidade

file_id

Campos conceituais

caminho_absoluto

tipo (video | legenda | imagem | outro)

tamanho

hash (opcional)

data_modificacao

origem (scan | importacao | manual)

criado_em

atualizado_em

RelaÃ§Ãµes

N:M â†’ Episode

1:N â†’ Subtitle (quando tipo = legenda)

Estados vÃ¡lidos

File pode:

NÃ£o estar associado a nada

Estar associado a mÃºltiplos episÃ³dios (exceÃ§Ã£o)

Arquivo fÃ­sico:

Nunca Ã© deletado automaticamente

Nunca Ã© sobrescrito

4. ENTIDADE: SUBTITLE
Identidade

subtitle_id

Campos conceituais

file_id (origem)

formato (SRT | ASS | VTT)

idioma

versao

eh_original (boolean)

criado_em

RelaÃ§Ãµes

N:1 â†’ File

1:N â†’ SubtitleTransformation

Estados vÃ¡lidos

Toda Subtitle:

Possui origem

Nunca substitui outra

Pode gerar infinitas derivadas

5. ENTIDADE: SUBTITLE_TRANSFORMATION
Identidade

transformation_id

Campos conceituais

subtitle_id_origem

tipo (style | timing | conversao)

parametros_aplicados

criado_em

RelaÃ§Ãµes

N:1 â†’ Subtitle

6. ENTIDADE: COLLECTION
Identidade

collection_id

Campos conceituais

nome

descricao

criado_em

RelaÃ§Ãµes

N:M â†’ Anime

Estados vÃ¡lidos

ColeÃ§Ãµes:

NÃ£o alteram Anime

NÃ£o afetam progresso

SÃ£o puramente organizacionais

7. ENTIDADE: EXTERNAL_REFERENCE
Identidade

external_reference_id

Campos conceituais

anime_id

fonte (AniList)

external_id

criado_em

RelaÃ§Ãµes

N:1 â†’ Anime

Estados vÃ¡lidos

ExternalReference:

Nunca substitui dados locais

Pode ser removida sem impacto estrutural

8. ENTIDADE: ANIME_ALIAS
Identidade

alias_id

Campos conceituais

anime_principal_id

anime_alias_id

criado_em

RelaÃ§Ãµes

2 Ã— Anime

Estados vÃ¡lidos

AnimeAlias:

Nunca Ã© deletado

MantÃ©m histÃ³rico de merges

9. ENTIDADE: STATISTICS_SNAPSHOT (DERIVADA)
Identidade

snapshot_id

Campos conceituais

tipo (global | por_anime | por_periodo)

valor

gerado_em

âš ï¸ Nunca Ã© fonte primÃ¡ria de verdade

10. EVENT STORE (OPCIONAL, RECOMENDADO)
ENTIDADE: DOMAIN_EVENT

Campos conceituais:

event_id

tipo_evento

payload

ocorrido_em

Uso

Auditoria

Debug

Replay de eventos

AnÃ¡lise de falhas

11. REGRAS DE INTEGRIDADE (CRÃTICAS)
Estados proibidos

Episode sem Anime

Subtitle sem File

File deletado automaticamente

EstatÃ­stica como fonte primÃ¡ria

Merge sem AnimeAlias

Se ocorrer â†’ erro arquitetural grave.

12. MATRIZ FINAL DE RELAÃ‡Ã•ES (RESUMO)
Entidade	Relacionamentos
Anime	Episode, Collection, ExternalReference, AnimeAlias
Episode	Anime, File
File	Episode, Subtitle
Subtitle	File, Transformation
Collection	Anime
Statistics	(derivada)
13. ESTADO FINAL DO PROJETO

DomÃ­nios: FECHADOS

Eventos: FECHADOS

ServiÃ§os: FECHADOS

Modelo de Dados: FECHADO

Ambiguidade: ZERO

--- FILE: docs\DOMAIN_CONTRACTS.md ---
AnimeHub â€” Contratos de DomÃ­nio CanÃ´nicos
VersÃ£o do Documento: 1.0
Data de CriaÃ§Ã£o: 24/12/2025
DescriÃ§Ã£o Geral: Este documento define O QUE o sistema AnimeHub Ã©. Ele estabelece contratos de domÃ­nio canÃ´nicos, focando em regras imutÃ¡veis, entidades, invariantes e aÃ§Ãµes permitidas/proibidas. NÃ£o define tecnologia, implementaÃ§Ã£o ou UI. Qualquer cÃ³digo que viole este documento estÃ¡ arquiteturalmente errado, mesmo que funcione funcionalmente.

0. REGRAS GLOBAIS (IMUTÃVEIS)
0.1 Natureza do Sistema

O AnimeHub Ã© local-first.
O usuÃ¡rio controla os arquivos.
O sistema nunca destrÃ³i dados silenciosamente.

0.2 Verdades Fundamentais

Toda entidade possui:
Identidade interna imutÃ¡vel.

IDs externos:
SÃ£o auxiliares.
Nunca substituem identidade interna.


0.3 Estados Proibidos (NUNCA Podem Existir)

EpisÃ³dio sem Anime.
Legenda sem arquivo de origem.
Progresso negativo.
Progresso maior que duraÃ§Ã£o.
EstatÃ­stica como fonte primÃ¡ria.
Arquivo deletado automaticamente.

ConsequÃªncia: Se qualquer um ocorrer â†’ erro crÃ­tico de arquitetura.

1. DOMÃNIO: ANIME
1.1 Escopo
Representa exclusivamente obras japonesas:

SÃ©ries de TV.
Filmes.
OVAs.
Especiais.

âš ï¸ NÃ£o Representa:

Donghua.
AnimaÃ§Ã£o ocidental.
ConteÃºdo genÃ©rico.

1.2 Entidade: Anime
Campos Conceituais:

id (identidade interna).
TÃ­tulo principal.
TÃ­tulos alternativos.
Tipo (TV | Movie | OVA | Special).
Status (em_exibiÃ§Ã£o | finalizado | cancelado).
Total de episÃ³dios (opcional).
Datas relevantes (opcionais).
Metadados livres (gÃªneros, estÃºdio, etc.).

1.3 Invariantes

Um Anime:
Pode existir sem episÃ³dios.
Pode existir sem arquivos.
Pode existir sem fonte externa.

Identidade nunca muda.
Duplicatas sÃ£o permitidas atÃ© resoluÃ§Ã£o explÃ­cita.

1.4 AÃ§Ãµes Permitidas

Criar manualmente.
Criar via importaÃ§Ã£o.
Atualizar metadados.
Associar fontes externas.
Marcar duplicata.
Fundir duplicatas (manual).

1.5 AÃ§Ãµes Proibidas

Deletar automaticamente.
Fundir sem confirmaÃ§Ã£o.
Alterar histÃ³rico ao editar metadados.


2. DOMÃNIO: EPISODE
2.1 Escopo
Representa uma unidade de exibiÃ§Ã£o pertencente a um Anime.
2.2 Entidade: Episode
Campos Conceituais:

id (identidade interna).
anime_id (referÃªncia ao Anime).
NÃºmero (regular ou especial).
TÃ­tulo (opcional).
DuraÃ§Ã£o esperada (opcional).
Progresso atual.
Estado (nÃ£o_visto | em_progresso | concluÃ­do).

2.3 Invariantes

Todo episÃ³dio pertence a exatamente um Anime.
Um episÃ³dio:
Pode existir sem arquivo.
Assume uma versÃ£o prÃ¡tica.

Progresso:
Nunca diminui automaticamente.
Nunca ultrapassa duraÃ§Ã£o.


2.4 AÃ§Ãµes Permitidas

Criar manualmente.
Criar via automaÃ§Ã£o explÃ­cita.
Associar arquivos.
Atualizar progresso.
Marcar como especial.

2.5 AÃ§Ãµes Proibidas

EpisÃ³dio Ã³rfÃ£o.
Reset implÃ­cito de progresso.
Merge automÃ¡tico silencioso.


3. DOMÃNIO: FILE (ARQUIVO FÃSICO)
3.1 Escopo
Representa arquivos reais no disco.
3.2 Entidade: File
Campos Conceituais:

id (identidade interna).
Caminho absoluto.
Tipo (vÃ­deo | legenda | imagem | outro).
Tamanho.
Hash (opcional).
Data de modificaÃ§Ã£o.
Origem (scan | importaÃ§Ã£o | manual).

3.3 Invariantes

Arquivo:
Nunca Ã© assumido confiÃ¡vel.
Pode mudar de caminho.

Nome do arquivo nÃ£o Ã© verdade absoluta.
Arquivo original nunca Ã© sobrescrito.

3.4 AÃ§Ãµes Proibidas

Deletar fisicamente.
Reescrever conteÃºdo.
Inferir associaÃ§Ã£o sem confirmaÃ§Ã£o.


4. DOMÃNIO: SUBTITLE
4.1 Escopo
Legendas como dados transformÃ¡veis, nÃ£o apenas arquivos.
4.2 Entidade: Subtitle
Campos Conceituais:

id (identidade interna).
file_id de origem.
Formato (SRT | ASS | VTT).
Idioma.
VersÃ£o.
Ã©_original (boolean).

4.3 Invariantes

Toda legenda:
Possui origem.
Nunca substitui outra.

TransformaÃ§Ãµes:
SÃ£o versionadas.
SÃ£o reversÃ­veis.


4.4 AÃ§Ãµes Permitidas

Aplicar estilo (fonte, outline, tamanho).
Ajustar timing ocasionalmente.
Converter formato.
Processar em batch.

4.5 AÃ§Ãµes Proibidas

EdiÃ§Ã£o destrutiva.
Sobrescrever arquivo original.


5. DOMÃNIO: COLLECTION
5.1 Escopo
Agrupamento puramente organizacional.
5.2 Invariantes

ColeÃ§Ãµes:
NÃ£o afetam progresso.
NÃ£o alteram Anime.

Anime pode pertencer a vÃ¡rias coleÃ§Ãµes.


6. DOMÃNIO: STATISTICS
6.1 Escopo
Dados derivados, nunca primÃ¡rios.
6.2 Invariantes

EstatÃ­sticas:
Podem ser recalculadas.
Podem ser descartadas.

Nunca alteram domÃ­nios.


7. INTEGRAÃ‡Ã•ES EXTERNAS
7.1 AniList

Fonte auxiliar.
Nunca autoritÃ¡ria.
Nunca sobrescreve dados locais.

7.2 Player (MPV)

ObservÃ¡vel.
ControlÃ¡vel.
Falhas nÃ£o corrompem estado.


8. DECLARAÃ‡ÃƒO FINAL
Se algo:

NÃ£o estÃ¡ descrito aqui â†’ nÃ£o deve ser implementado.

Este documento:

Precede o cÃ³digo.
Precede o banco.
Precede qualquer IA.

--- FILE: docs\EVENT_MAP.md ---
AnimeHub â€” Mapa CanÃ´nico de Eventos e Fluxos

Este documento define o comportamento do sistema ao longo do tempo.
Ele responde, de forma inequÃ­voca, Ã  pergunta:
â€œQuando X acontece, o que o sistema faz?â€

NÃ£o descreve UI.
NÃ£o descreve tecnologia.
Descreve causalidade e reaÃ§Ã£o.

0. PRINCÃPIOS DO EVENT MAP
0.1 Evento Ã© um fato, nÃ£o uma intenÃ§Ã£o

Um evento:

JÃ¡ aconteceu

Ã‰ verdadeiro

NÃ£o depende de interface

Exemplos:

âŒ â€œUsuÃ¡rio clicou no botÃ£oâ€

âœ… â€œArquivo de vÃ­deo foi detectadoâ€

âœ… â€œEpisÃ³dio foi marcado como concluÃ­doâ€

0.2 Tipos de eventos
Evento PrimÃ¡rio

Fato originado por:

AÃ§Ã£o explÃ­cita do usuÃ¡rio

InteraÃ§Ã£o com o mundo externo (scan, player)

Evento Derivado

ConsequÃªncia lÃ³gica de outro evento.

Evento ObservÃ¡vel

Evento que existe para:

Atualizar UI

Atualizar estatÃ­sticas

Atualizar cache

âš ï¸ Eventos observÃ¡veis nunca alteram domÃ­nios diretamente.

0.3 Regra estrutural absoluta

Nenhum evento pode alterar diretamente mais de um domÃ­nio.

CoordenaÃ§Ã£o acontece por reaÃ§Ãµes, nunca por acoplamento.

1. EVENTO: SCAN DE DIRETÃ“RIO
1.1 Evento primÃ¡rio

DirectoryScanned

Emitido quando:

O sistema termina de varrer um diretÃ³rio configurado

1.2 Eventos derivados
FileDetected

Emitido para cada arquivo relevante encontrado:

VÃ­deo

Legenda

Imagem associÃ¡vel

1.3 ReaÃ§Ãµes por domÃ­nio
DomÃ­nio: File

Registra o arquivo

Atualiza:

tamanho

data de modificaÃ§Ã£o

hash (se configurado)

NÃ£o associa automaticamente

DomÃ­nio: Anime / Episode

Nenhuma aÃ§Ã£o direta

AssociaÃ§Ã£o exige evento explÃ­cito posterior

ğŸ“Œ DecisÃ£o canÃ´nica
Scan nunca cria Anime ou Episode automaticamente.

2. EVENTO: CRIAÃ‡ÃƒO DE ANIME
2.1 Evento primÃ¡rio

AnimeCreated

Origem:

CriaÃ§Ã£o manual

ImportaÃ§Ã£o explÃ­cita

2.2 ReaÃ§Ãµes
DomÃ­nio: Anime

Cria entidade Anime

Estado inicial neutro

DomÃ­nio: Statistics

Nenhuma reaÃ§Ã£o imediata

3. EVENTO: CRIAÃ‡ÃƒO DE EPISÃ“DIO
3.1 Evento primÃ¡rio

EpisodeCreated

PrÃ©-condiÃ§Ã£o:

Anime existente

3.2 ReaÃ§Ãµes
DomÃ­nio: Episode

Cria episÃ³dio

Estado inicial: nÃ£o_visto

Progresso = 0

4. EVENTO: ASSOCIAÃ‡ÃƒO DE ARQUIVO A EPISÃ“DIO
4.1 Evento primÃ¡rio

FileLinkedToEpisode

Origem:

AÃ§Ã£o manual do usuÃ¡rio

AutomaÃ§Ã£o explÃ­cita e confirmada

4.2 ReaÃ§Ãµes
DomÃ­nio: Episode

Registra associaÃ§Ã£o

Define papel do arquivo:

principal (vÃ­deo)

auxiliar (legenda, extra)

DomÃ­nio: File

MantÃ©m referÃªncia reversa

4.3 Evento derivado
EpisodeBecamePlayable

Emitido quando:

EpisÃ³dio passa a ter arquivo de vÃ­deo vÃ¡lido

5. EVENTO: INÃCIO DE REPRODUÃ‡ÃƒO
5.1 Evento primÃ¡rio

PlaybackStarted

Emitido quando:

Player inicia reproduÃ§Ã£o de um episÃ³dio

5.2 ReaÃ§Ãµes
DomÃ­nio: Episode

Estado â†’ em_progresso

DomÃ­nio: Statistics

Registra sessÃ£o temporÃ¡ria

ğŸ“Œ Nenhum progresso Ã© persistido aqui.

6. EVENTO: ATUALIZAÃ‡ÃƒO DE PROGRESSO
6.1 Evento primÃ¡rio

PlaybackProgressUpdated

Emitido periodicamente pelo player.

6.2 Invariantes

Progresso:

Nunca diminui automaticamente

Nunca ultrapassa duraÃ§Ã£o conhecida

6.3 ReaÃ§Ãµes
DomÃ­nio: Episode

Atualiza progresso atual

DomÃ­nio: Statistics

Atualiza mÃ©tricas derivadas

7. EVENTO: FINALIZAÃ‡ÃƒO DE EPISÃ“DIO
7.1 Evento primÃ¡rio

EpisodeCompleted

Emitido quando:

Progresso atinge limiar configurado (ex: â‰¥ 90%)

7.2 ReaÃ§Ãµes
DomÃ­nio: Episode

Estado â†’ concluÃ­do

DomÃ­nio: Anime

Atualiza contadores derivados (ex: episÃ³dios assistidos)

DomÃ­nio: Statistics

Atualiza totais globais

8. EVENTO: DETECÃ‡ÃƒO DE LEGENDA
8.1 Evento primÃ¡rio

SubtitleDetected

Origem:

Scan de diretÃ³rio

ImportaÃ§Ã£o manual

8.2 ReaÃ§Ãµes
DomÃ­nio: Subtitle

Registra legenda

Detecta:

formato

idioma

DomÃ­nio: File

MantÃ©m arquivo original imutÃ¡vel

9. EVENTO: APLICAÃ‡ÃƒO DE ESTILO DE LEGENDA
9.1 Evento primÃ¡rio

SubtitleStyleApplied

Origem:

AÃ§Ã£o manual

Batch explÃ­cito

9.2 Invariantes

Legenda original:

Nunca Ã© sobrescrita

Sempre gera nova versÃ£o

9.3 ReaÃ§Ãµes
DomÃ­nio: Subtitle

Cria nova versÃ£o

Registra transformaÃ§Ã£o de estilo

10. EVENTO: AJUSTE DE TIMING DE LEGENDA
10.1 Evento primÃ¡rio

SubtitleTimingAdjusted

10.2 ReaÃ§Ãµes
DomÃ­nio: Subtitle

Gera nova versÃ£o

Registra transformaÃ§Ã£o de timing

ğŸ“Œ Timing Ã© tratado como transformaÃ§Ã£o, nÃ£o ediÃ§Ã£o destrutiva.

11. EVENTO: FUSÃƒO DE ANIMES (DUPLICATAS)
11.1 Evento primÃ¡rio

AnimeMerged

PrÃ©-condiÃ§Ãµes:

AÃ§Ã£o manual

ConfirmaÃ§Ã£o explÃ­cita

11.2 ReaÃ§Ãµes
DomÃ­nio: Anime

Um anime torna-se principal

Outro vira alias histÃ³rico

DomÃ­nio: Episode

EpisÃ³dios sÃ£o reassociados explicitamente

12. EVENTO: REBUILD DE ESTATÃSTICAS
12.1 Evento primÃ¡rio

StatisticsRebuilt

Origem:

AÃ§Ã£o manual

ManutenÃ§Ã£o

12.2 ReaÃ§Ãµes
DomÃ­nio: Statistics

Recalcula todos os dados derivados

ğŸ“Œ Nenhum domÃ­nio primÃ¡rio Ã© alterado.

13. EVENTOS PROIBIDOS (CRÃTICOS)

Os seguintes eventos NUNCA DEVEM EXISTIR:

AutoAnimeDeleted

SubtitleOverwritten

ImplicitEpisodeMerge

ProgressResetWithoutUserAction

FileAutoDeleted

Se aparecerem â†’ erro arquitetural grave.

14. GARANTIA DE CONTINUIDADE

Qualquer IA que leia:

DOMAIN_CONTRACTS.md

EVENT_MAP.md

Consegue:

Entender o sistema

Implementar sem improvisar

Evoluir sem quebrar contratos

15. ESTADO DO PROJETO

DomÃ­nios: FECHADOS

Eventos: FECHADOS

ServiÃ§os: DEFINIDOS

CÃ³digo: NÃƒO INICIADO



--- FILE: docs\FOUNDATION SEAL.md ---
Purpose

This document formally defines which parts of the AnimeHub codebase are SEALED as of the completion of the Foundation Phase (Phase 3).

Sealed components are considered stable architectural boundaries. They are not frozen forever, but must not be modified casually. Any change to a sealed component requires an explicit architectural review.

This document exists to:

Prevent accidental architectural erosion

Stop unnecessary refactors driven by tooling or tests

Provide clarity for future contributors (human or AI)

Definition of â€œSEALEDâ€

A sealed component:

Is architecturally correct and complete for the current phase

Defines contracts relied upon by other layers

Must not be changed to satisfy outdated tests or conveniences

Can only be modified for explicit, justified reasons (bug, design flaw, new phase decision)

Sealing is a process decision, not a technical restriction.

ğŸ”’ SEALED COMPONENTS
1. Domain Layer (STRICTLY SEALED)

Location: src-tauri/src/domain/

These files define the core business model. They are pure, dependency-free, and invariant-driven.

Sealed directories and files:

domain/anime/

domain/episode/

domain/file/

domain/subtitle/

domain/collection/

domain/statistics/

domain/external_reference.rs

domain/anime_alias.rs

Rules:

âŒ No database access

âŒ No filesystem access

âŒ No event bus access

âŒ No UI or service concerns

âœ… Only business rules and invariants

2. Repository Contracts (SEALED)

Location: src-tauri/src/repositories/

These traits define the stable boundary between services and persistence.

Sealed files:

anime_repository.rs

episode_repository.rs

file_repository.rs

subtitle_repository.rs

collection_repository.rs

external_reference_repository.rs

anime_alias_repository.rs

statistics_repository.rs

Rules:

âŒ No business logic

âŒ No cross-repository calls

âŒ No service calls

âœ… Traits only

3. Database Schema (SEALED)

Location: src-tauri/schema.sql

This file defines the canonical SQLite schema.

Rules:

âŒ No breaking changes

âŒ No column removal or type mutation

âœ… Only additive migrations allowed in future phases

4. Event System (SEALED)

Location: src-tauri/src/events/

Sealed files:

events/types.rs

events/bus/event_bus.rs

Rules:

âŒ Existing events must not change

âŒ Event semantics are immutable

âœ… New events may be added

5. Service Responsibilities (SEALED)

Location: src-tauri/src/services/

Sealed service files:

anime_service.rs

episode_service.rs

file_service.rs

playback_service.rs

statistics_service.rs

external_integration_service.rs

subtitle_service.rs

Rules:

âŒ No business logic inside services

âŒ Services must not call other services directly

âœ… Services orchestrate domain + repositories + events

âš ï¸ LEGACY / NON-CANONICAL CODE (DO NOT USE)
Legacy SQLite Implementations

Location: src-tauri/src/repositories/sqlite/

Files:

sqlite_episode_repository.rs

sqlite_file_repository.rs

sqlite_statistics_repository.rs

Status:

âš ï¸ Legacy

âŒ Not used by the current architecture

âŒ Must not be referenced by new code

âœ… Kept only for historical context

ğŸ§ª TEST STATUS CLARIFICATION
Valid Tests (Authoritative)

Domain invariant tests (inside domain modules)

Event bus tests

Database migration tests

Infrastructure utility tests

Legacy / Out-of-Phase Tests

Early repository integration tests

Tests referencing outdated module paths

Tests assuming deprecated helpers

These tests:

âŒ Are not required to pass

âŒ Must not drive architectural changes

âš ï¸ Are considered historical

What Future Development MAY Do

âœ… Add new services âœ… Add new service methods âœ… Add new events âœ… Add UI layers âœ… Add external integrations (AniList, MPV, etc.) âœ… Add integration tests at application boundaries

What Future Development MUST NOT Do

âŒ Modify sealed domain models casually âŒ Change repository contracts without review âŒ Break schema compatibility âŒ Add business logic to repositories âŒ Create service-to-service dependencies

Phase Status

Foundation Phase (Phase 3): CLOSED & SEALED

This document is the authoritative reference for what is considered stable.

All future work builds around this foundation, not inside it.

--- FILE: docs\README.md ---
AnimeHub â€” Documento CanÃ´nico de Continuidade

Este arquivo Ã© o ponto de entrada obrigatÃ³rio para qualquer IA ou humano.
Ele define:

o que Ã© o projeto

o que NÃƒO Ã©

em que estÃ¡gio ele estÃ¡

como continuar a implementaÃ§Ã£o sem reinventar nada

1. O QUE Ã‰ O ANIMEHUB

AnimeHub Ã© um gerenciador local, offline-first, de animes japoneses (incluindo filmes), com foco em:

Controle explÃ­cito de biblioteca

Progresso de visualizaÃ§Ã£o confiÃ¡vel

TransformaÃ§Ãµes nÃ£o destrutivas de legendas

Robustez estrutural acima de conveniÃªncia

ManutenÃ§Ã£o mÃ­nima a longo prazo

NÃ£o Ã© um player.
NÃ£o Ã© um scraper automÃ¡tico.
NÃ£o Ã© um sistema de streaming.

2. PRINCÃPIOS INEGOCIÃVEIS

Nada Ã© implÃ­cito

Nada Ã© destruÃ­do automaticamente

Toda transformaÃ§Ã£o gera histÃ³rico

Eventos coordenam, serviÃ§os nÃ£o se chamam

Dados derivados nunca sÃ£o fonte de verdade

ImplementaÃ§Ã£o nunca decide arquitetura

ViolaÃ§Ã£o de qualquer um â†’ erro crÃ­tico.

3. DOCUMENTOS CANÃ”NICOS (ORDEM DE LEITURA)

README.md (este arquivo)

DOMAIN_CONTRACTS.md

EVENT_MAP.md

SERVICE_CONTRACTS.md

DATA_MODEL.md

ğŸ‘‰ CÃ³digo deve obedecer aos documentos, nunca o contrÃ¡rio.

4. ESCOPO FUNCIONAL
IncluÃ­do

Animes japoneses (TV, Movie, OVA, Special)

Biblioteca local

Player externo (MPV)

Estilo e timing de legendas

Progresso persistente

ExcluÃ­do (por design)

SÃ©ries ocidentais

Streaming online

Download automÃ¡tico

RecomendaÃ§Ãµes algorÃ­tmicas

EdiÃ§Ã£o destrutiva de arquivos

5. ESTADO ATUAL DO PROJETO
Camada	Estado
VisÃ£o	Fechada
DomÃ­nios	Fechados
Eventos	Fechados
ServiÃ§os	Fechados
Dados	Fechados
CÃ³digo	NÃƒO iniciado

ğŸ“Œ Este Ã© o Ãºnico momento seguro para iniciar cÃ³digo.

6. COMO UMA IA DEVE CONTINUAR O PROJETO
Ordem obrigatÃ³ria de implementaÃ§Ã£o

Estrutura base do projeto

DomÃ­nios (entidades + invariantes)

Event bus interno

PersistÃªncia (repositÃ³rios)

ServiÃ§os

IntegraÃ§Ã£o com player

Interface

âš ï¸ Pular etapas quebra o sistema.

7. EXPECTATIVA DE QUALIDADE DE CÃ“DIGO

CÃ³digo:

DeterminÃ­stico

TestÃ¡vel

Sem efeitos colaterais implÃ­citos

Nenhum:

Mock permanente

Placeholder

â€œDepois a gente arrumaâ€

8. SOBRE TECNOLOGIA (DELIBERADAMENTE ABERTO)

Linguagem: indiferente

Framework: indiferente

Banco: indiferente

UI: indiferente

ğŸ“Œ A arquitetura independe da stack.

9. COMO ENTREGAR ESTE PROJETO A OUTRA IA

Ao iniciar uma nova conversa:

Envie todos os arquivos .md

Diga:

â€œLeia todos os documentos. NÃ£o proponha mudanÃ§as arquiteturais. Apenas implemente.â€

Se a IA:

questionar contratos â†’ erro

sugerir simplificaÃ§Ã£o â†’ erro

propor automaÃ§Ã£o implÃ­cita â†’ erro

10. GARANTIA DE CONTINUIDADE

Qualquer IA, lendo estes arquivos, consegue:

Entender o projeto inteiro

Saber exatamente em que fase ele estÃ¡

Continuar sem decisÃµes subjetivas

Manter o mesmo nÃ­vel de rigor

11. STATUS FINAL

Projeto completamente especificado.
Zero ambiguidade.
Pronto para implementaÃ§Ã£o.

--- FILE: docs\SERVICE_CONTRACTS.md ---
AnimeHub â€” Contratos CanÃ´nicos de ServiÃ§os

Este documento define QUEM FAZ O QUÃŠ no sistema.
Ele impede:

serviÃ§os genÃ©ricos

lÃ³gica escondida

acoplamento indevido

Qualquer serviÃ§o que viole este contrato estÃ¡ arquiteturalmente errado.

0. REGRAS GLOBAIS DOS SERVIÃ‡OS
0.1 DefiniÃ§Ã£o de ServiÃ§o

Um ServiÃ§o:

Orquestra domÃ­nios

Reage a eventos

NÃ£o possui estado durÃ¡vel prÃ³prio

ğŸ“Œ Estado durÃ¡vel pertence exclusivamente aos domÃ­nios.

0.2 O que um ServiÃ§o NÃƒO Ã‰

âŒ Controller de UI

âŒ Wrapper de banco

âŒ Lugar para â€œresolver tudoâ€

0.3 ComunicaÃ§Ã£o entre serviÃ§os

ServiÃ§os:

Consomem eventos

Emitem eventos

ServiÃ§os:

Nunca chamam outros serviÃ§os diretamente

Nunca compartilham estado

CoordenaÃ§Ã£o ocorre por eventos, nÃ£o por chamadas diretas.

1. ANIME SERVICE
Responsabilidade

Gerenciar o ciclo de vida do Anime como entidade de domÃ­nio.

Pode fazer

Criar Anime

Atualizar metadados

Associar fontes externas

Resolver duplicatas (merge manual)

NÃƒO pode fazer

Criar episÃ³dios automaticamente

Criar arquivos

Alterar progresso de episÃ³dios

Calcular estatÃ­sticas

Eventos que consome

AnimeCreated

ExternalMetadataLinked

AnimeMerged

Eventos que emite

AnimeUpdated

AnimeMerged

2. EPISODE SERVICE
Responsabilidade

Gerenciar episÃ³dios e progresso de visualizaÃ§Ã£o.

Pode fazer

Criar episÃ³dios

Atualizar progresso

Marcar como concluÃ­do

Associar arquivos existentes

NÃƒO pode fazer

Criar Anime

Criar arquivos fÃ­sicos

Manipular legendas

Gerar estatÃ­sticas globais

Eventos que consome

EpisodeCreated

PlaybackStarted

PlaybackProgressUpdated

EpisodeCompleted

FileLinkedToEpisode

Eventos que emite

EpisodeBecamePlayable

EpisodeProgressUpdated

EpisodeCompleted

3. FILE SERVICE
Responsabilidade

Gerenciar arquivos fÃ­sicos como entidades observÃ¡veis.

Pode fazer

Registrar arquivos detectados

Atualizar metadados fÃ­sicos

Calcular hash

Detectar alteraÃ§Ãµes

NÃƒO pode fazer

Criar Anime ou EpisÃ³dio

Decidir associaÃ§Ãµes implicitamente

Deletar arquivos fÃ­sicos

Eventos que consome

DirectoryScanned

Eventos que emite

FileDetected

FileUpdated

FileLinkedToEpisode

4. SUBTITLE SERVICE
Responsabilidade

Orquestrar transformaÃ§Ãµes de legendas.

Pode fazer

Converter formatos

Aplicar estilos

Ajustar timing

Criar versÃµes derivadas

NÃƒO pode fazer

Sobrescrever legenda original

Alterar arquivos fÃ­sicos diretamente

Modificar progresso de episÃ³dios

Eventos que consome

SubtitleDetected

SubtitleStyleApplied

SubtitleTimingAdjusted

Eventos que emite

SubtitleVersionCreated

SubtitleProcessed

5. PLAYBACK SERVICE
Responsabilidade

Integrar o sistema com o player de mÃ­dia (MPV).

Pode fazer

Iniciar reproduÃ§Ã£o

Pausar e parar

Monitorar progresso

Emitir eventos de playback

NÃƒO pode fazer

Persistir progresso

Alterar estado de domÃ­nio diretamente

Criar entidades

Eventos que consome

PlaybackRequested

Eventos que emite

PlaybackStarted

PlaybackProgressUpdated

PlaybackStopped

6. STATISTICS SERVICE
Responsabilidade

Gerar dados derivados e agregados.

Pode fazer

Agregar dados

Cachear resultados

Recalcular estatÃ­sticas

NÃƒO pode fazer

Alterar domÃ­nios

Criar entidades

Persistir dados como fonte primÃ¡ria

Eventos que consome

EpisodeCompleted

PlaybackProgressUpdated

StatisticsRebuilt

Eventos que emite

StatisticsUpdated

7. EXTERNAL INTEGRATION SERVICE
Responsabilidade

Integrar serviÃ§os externos (AniList).

Pode fazer

Buscar metadados externos

Normalizar dados recebidos

Emitir eventos de associaÃ§Ã£o

NÃƒO pode fazer

Criar Anime automaticamente

Substituir dados locais

Ser fonte de verdade

Eventos que consome

ExternalMetadataRequested

Eventos que emite

ExternalMetadataFetched

ExternalMetadataLinked

8. SERVIÃ‡OS PROIBIDOS (ANTI-PATTERNS)

Os seguintes NÃƒO DEVEM EXISTIR:

LibraryService

ManagerService

UtilsService

GodService

Se aparecerem â†’ falha arquitetural.

9. MATRIZ DE RESPONSABILIDADE (RESUMO)
ServiÃ§o	Pode	NÃ£o pode
Anime	Metadados	Progresso
Episode	Progresso	Arquivos
File	Detectar	Associar implÃ­cito
Subtitle	Transformar	Destruir
Playback	Observar	Persistir
Statistics	Derivar	Alterar
External	Buscar	Mandar
10. ESTADO DO PROJETO APÃ“S ESTE DOCUMENTO

DomÃ­nios: FECHADOS

Eventos: FECHADOS

ServiÃ§os: FECHADOS

Ambiguidade: ZERO

--- FILE: docs\UI_LAYOUT.md ---
UI_LAYOUT.md
1. Estrutura Global
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Sidebar       â”‚
â”‚ - Biblioteca  â”‚
â”‚ - CalendÃ¡rio  â”‚
â”‚ - Legendas    â”‚
â”‚ - EstatÃ­sticasâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Main Content Area     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Sidebar:

Sempre visÃ­vel

Ãcones + texto

Estado ativo claro

2. Tela: Biblioteca

FunÃ§Ã£o: visÃ£o geral da coleÃ§Ã£o

Componentes:

Grid de capas

Indicador de progresso no card

Filtros:

Status

Temporada

ColeÃ§Ãµes

InteraÃ§Ãµes:

Clique â†’ PÃ¡gina do Anime

Hover â†’ aÃ§Ãµes rÃ¡pidas (opcional)

3. Tela: PÃ¡gina do Anime

FunÃ§Ã£o: centro de controle do anime

Layout:

Header grande com capa

InformaÃ§Ãµes:

TÃ­tulo

Sinopse

Status

Lista de episÃ³dios

Lista de episÃ³dios:

NÃºmero

TÃ­tulo (se existir)

Progresso visual

Estado (nÃ£o visto / em progresso / concluÃ­do)

AÃ§Ãµes:

Assistir

Selecionar legendas

Marcar manualmente

4. Tela: Player (Overlay)

FunÃ§Ã£o: assistir sem distrair

Player externo (MPV)

UI mÃ­nima

Controles bÃ¡sicos

Progresso observado automaticamente

ğŸ“Œ Player nunca altera estado diretamente.

5. Tela: CalendÃ¡rio / Countdown

FunÃ§Ã£o: visÃ£o temporal

Componentes:

Lista por temporada

Cada anime mostra:

Data do Ãºltimo episÃ³dio

Countdown visual

Filtros:

Temporada

Status

ğŸ“Œ Dados derivados do AniList
ğŸ“Œ Nunca fonte de verdade

6. Tela: Legendas

FunÃ§Ã£o: gerenciar transformaÃ§Ãµes

Componentes:

Lista de legendas detectadas

SeleÃ§Ã£o por anime / episÃ³dio

Painel de estilos:

Fonte

Outline

Shadow

Tamanho

Fluxo:

Seleciona episÃ³dios

Aplica transformaÃ§Ã£o

Gera nova versÃ£o

HistÃ³rico preservado

7. Tela: EstatÃ­sticas

FunÃ§Ã£o: feedback, nÃ£o controle

Tempo assistido

EpisÃ³dios concluÃ­dos

EvoluÃ§Ã£o temporal

ğŸ“Œ EstatÃ­sticas nunca alteram domÃ­nios.

--- FILE: docs\UI_PRINCIPLES.md ---
UI_PRINCIPLES.md
1. Filosofia Geral

A UI do AnimeHub Ã©:

Local-first

Silenciosamente poderosa

Visualmente limpa

Funcional antes de chamativa

Inspirada em apps premium de mÃ­dia

A UI nunca toma decisÃµes de domÃ­nio.
Ela apenas reflete estado e emite intenÃ§Ãµes explÃ­citas.

2. PrincÃ­pios Visuais

Dark mode Ã© padrÃ£o

Contraste alto, porÃ©m confortÃ¡vel

Poucos elementos por tela

Layouts previsÃ­veis

Nada pisca sem motivo

ğŸ“Œ Regra:

Se algo pode ser ocultado atÃ© o usuÃ¡rio pedir â†’ deve ser ocultado.

3. Tipografia (ObrigatÃ³ria)

Fonte primÃ¡ria: Inter ou Poppins

Hierarquia clara:

TÃ­tulo

SubtÃ­tulo

Corpo

Meta (labels, hints)

âŒ Proibido:

Mais de 2 famÃ­lias de fonte

Texto pequeno demais

UI â€œapertadaâ€

4. Cores

Paleta neutra

Cor de destaque usada com moderaÃ§Ã£o

Estados claros:

Ativo

Inativo

ConcluÃ­do

Em progresso

Erro

ğŸ“Œ Progresso Ã© visual, nÃ£o textual sempre.

5. AnimaÃ§Ãµes

Curtas

Suaves

Sem exagero

Nunca bloqueiam interaÃ§Ã£o

Usadas para:

TransiÃ§Ãµes de pÃ¡gina

ExpansÃ£o de detalhes

Feedback de aÃ§Ã£o

Nunca usadas para:

Enfeite vazio

Chamar atenÃ§Ã£o desnecessÃ¡ria

6. UX (Regras Estritas)

Nenhuma aÃ§Ã£o destrutiva sem confirmaÃ§Ã£o

Nenhuma automaÃ§Ã£o invisÃ­vel

Feedback sempre claro

Erros explicÃ¡veis

ğŸ“Œ Se algo falhar:

A UI explica o que falhou, nÃ£o esconde.

7. InspiraÃ§Ãµes Declaradas

A UI se inspira em:

SeaNimes (estrutura)

Apple TV (layout e tipografia)

Netflix (grid e navegaÃ§Ã£o)

Spotify Desktop (sidebar + conteÃºdo)

âš ï¸ InspiraÃ§Ã£o â‰  cÃ³pia.

--- FILE: EVENTS_SYSTEM_DESIGN.md ---
# AnimeHub Event System - Design Document

## Overview

The Event System is the coordination backbone of AnimeHub. It enables services to communicate without direct dependencies, making the system:
- **Decoupled**: Services don't know about each other
- **Observable**: Every action produces traceable events
- **Deterministic**: Same inputs â†’ same outputs
- **Testable**: Services can be tested in isolation

## Architecture Principles

### 1. Events Are Facts, Not Commands

âŒ **Wrong** (Command): `CreateAnime { title: "..." }`  
âœ… **Right** (Fact): `AnimeCreated { anime_id: ..., title: "..." }`

Events represent something that **has already happened**. They are immutable historical records.

### 2. Synchronous by Design

The event bus executes handlers **immediately** in **subscription order**. This makes the system:
- Predictable (no race conditions)
- Debuggable (step through execution)
- Simple (no async complexity)

When to consider async (future):
- External API calls
- Heavy computation
- I/O-bound operations

But the **core event flow remains synchronous**.

### 3. Type Safety Over Flexibility

We use **concrete types** for every event:
```rust
pub struct AnimeCreated {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub anime_id: Uuid,
    pub titulo_principal: String,
    pub tipo: String,
}
```

No dynamic dispatch. No string-typed events. No `HashMap<String, Any>`.

### 4. One Handler, One Responsibility

Each handler does **exactly one thing**:
- âœ… Update progress
- âœ… Emit derived event
- âœ… Log action
- âŒ Update progress AND send email AND rebuild statistics

If you need multiple things, emit multiple events.

### 5. Services Never Call Services

```rust
// âŒ FORBIDDEN
impl AnimeService {
    fn create_anime(&self) {
        // ...
        self.episode_service.create_episodes(); // NO!
    }
}

// âœ… CORRECT
impl AnimeService {
    fn create_anime(&self, bus: &EventBus) {
        // ...
        bus.emit(AnimeCreated::new(...));
        // EpisodeService will react to this event
    }
}
```

## Event Flow Example

### Scenario: User creates a new anime

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     UI      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ invoke create_anime
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AnimeServiceâ”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ emit AnimeCreated
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Event Bus  â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”˜
      â”‚   â”‚
      â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Statistics â”‚    â”‚  External   â”‚
â”‚   Handler   â”‚    â”‚  Integrationâ”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                  â”‚
       â”‚ emit             â”‚ emit
       â”‚ StatisticsUpdatedâ”‚ MetadataRequested
       â–¼                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Event Bus  â”‚    â”‚  Event Bus  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Each handler:
1. Receives event
2. Performs domain operation
3. Emits resulting events (if needed)

## Event Categories

Events are organized by domain:

### File Scanning
- `DirectoryScanned`: Scan completed
- `FileDetected`: Individual file found

### Anime Domain
- `AnimeCreated`: New anime entity
- `AnimeUpdated`: Metadata changed
- `AnimeMerged`: Duplicates resolved

### Episode Domain
- `EpisodeCreated`: New episode
- `FileLinkedToEpisode`: File association
- `EpisodeBecamePlayable`: Has valid video
- `EpisodeProgressUpdated`: Playback progress
- `EpisodeCompleted`: Finished watching

### Playback
- `PlaybackStarted`: Player launched
- `PlaybackProgressUpdated`: Progress tick
- `PlaybackStopped`: Player closed

### Subtitle
- `SubtitleDetected`: Subtitle file found
- `SubtitleStyleApplied`: Style transformation
- `SubtitleTimingAdjusted`: Timing transformation
- `SubtitleVersionCreated`: New derived version

### Statistics
- `StatisticsRebuilt`: Full recalculation
- `StatisticsUpdated`: Incremental update

### External Integration
- `ExternalMetadataRequested`: User wants external data
- `ExternalMetadataFetched`: Data retrieved
- `ExternalMetadataLinked`: Associated with anime

## Usage Patterns

### Pattern 1: Simple Handler

```rust
use animehub::events::*;

#[derive(Clone)]
struct LoggingHandler;

impl EventHandler<AnimeCreated> for LoggingHandler {
    fn handle(&self, event: &AnimeCreated, _bus: &EventBus) {
        println!("New anime: {}", event.titulo_principal);
    }
}

// Register
let bus = EventBus::new();
let handler = LoggingHandler;
handler.register(&bus);
```

### Pattern 2: Handler with State

```rust
#[derive(Clone)]
struct StatisticsHandler {
    repository: Arc<dyn StatisticsRepository>,
}

impl EventHandler<AnimeCreated> for StatisticsHandler {
    fn handle(&self, event: &AnimeCreated, bus: &EventBus) {
        // Update statistics
        self.repository.increment_anime_count();
        
        // Emit result
        bus.emit(StatisticsUpdated::new());
    }
}
```

### Pattern 3: Coordinator (Complex Flow)

```rust
#[derive(Clone)]
struct AnimeCreationCoordinator {
    episode_service: Arc<EpisodeService>,
    external_service: Arc<ExternalIntegrationService>,
}

impl EventHandler<AnimeCreated> for AnimeCreationCoordinator {
    fn handle(&self, event: &AnimeCreated, bus: &EventBus) {
        // Emit sub-tasks as events
        
        if should_create_episodes(&event) {
            bus.emit(CreateDefaultEpisodesRequested {
                anime_id: event.anime_id,
            });
        }
        
        if should_fetch_metadata(&event) {
            bus.emit(ExternalMetadataRequested {
                anime_id: event.anime_id,
                provider: "AniList".to_string(),
            });
        }
    }
}
```

## Testing Strategy

### Unit Test: Single Handler

```rust
#[test]
fn test_statistics_handler() {
    let bus = EventBus::new();
    let repo = Arc::new(MockStatisticsRepository::new());
    let handler = StatisticsHandler { repository: repo.clone() };
    
    handler.register(&bus);
    
    let event = AnimeCreated::new(
        Uuid::new_v4(),
        "Test".to_string(),
        "TV".to_string(),
    );
    
    bus.emit(event);
    
    assert_eq!(repo.anime_count(), 1);
}
```

### Integration Test: Event Flow

```rust
#[test]
fn test_anime_creation_flow() {
    let bus = EventBus::new();
    
    // Register all handlers
    register_all_handlers(&bus);
    
    // Trigger initial event
    bus.emit(AnimeCreated::new(...));
    
    // Verify resulting state
    let log = bus.get_event_log();
    assert!(log.iter().any(|e| e.event_type == "StatisticsUpdated"));
    assert!(log.iter().any(|e| e.event_type == "ExternalMetadataRequested"));
}
```

## Observability

The EventBus provides built-in observability:

### Event Log

```rust
let log = bus.get_event_log();
for entry in log {
    println!("{}: {} | {} handlers",
        entry.occurred_at,
        entry.event_type,
        entry.handler_count
    );
}
```

### Console Output

Every event emission is logged:
```
[EVENT] AnimeCreated (id: 123e4567-...) | 3 handlers
[EVENT] StatisticsUpdated (id: 234f5678-...) | 1 handlers
```

### Tracing (Future)

Event causality can be tracked by storing parent event IDs.

## Anti-Patterns to Avoid

### âŒ God Event

```rust
// BAD: One event doing everything
struct SystemStateChanged {
    anime_updated: bool,
    episodes_updated: bool,
    statistics_updated: bool,
    // ... kitchen sink
}
```

### âŒ Command Masquerading as Event

```rust
// BAD: This is a command, not an event
struct ShouldCreateAnime {
    title: String,
}

// GOOD: Event after the fact
struct AnimeCreated {
    anime_id: Uuid,
    titulo_principal: String,
}
```

### âŒ Handler Doing Too Much

```rust
// BAD: Multiple responsibilities
impl EventHandler<AnimeCreated> for MegaHandler {
    fn handle(&self, event: &AnimeCreated, bus: &EventBus) {
        self.update_statistics();
        self.fetch_external_data();
        self.send_notification();
        self.update_cache();
        self.log_analytics();
        // ... etc
    }
}
```

### âŒ Direct Service Calls

```rust
// BAD: Direct dependency
impl AnimeService {
    fn create(&self) {
        // ...
        self.episode_service.initialize(); // NO!
    }
}

// GOOD: Event-driven
impl AnimeService {
    fn create(&self, bus: &EventBus) {
        // ...
        bus.emit(AnimeCreated::new(...));
        // EpisodeService reacts independently
    }
}
```

## Performance Considerations

### Synchronous Execution

- **Latency**: All handlers execute before `emit()` returns
- **Trade-off**: Predictability > raw speed
- **Mitigation**: Keep handlers fast (< 1ms each)

### Memory

- **Event Log**: Grows unbounded
- **Solution**: Periodic cleanup or size limit
- **Production**: Consider rotating logs

### Scalability

- **Single-threaded**: Current design
- **Future**: Can add async event queue for I/O-bound tasks
- **Hybrid**: Sync for critical path, async for non-critical

## Future Enhancements (Out of Scope for Step 3)

1. **Event Persistence**: Store events for replay
2. **Event Sourcing**: Rebuild state from events
3. **Async Handlers**: For I/O-bound operations
4. **Dead Letter Queue**: For failed events
5. **Event Versioning**: Evolve event schemas
6. **Distributed Events**: Multi-process coordination

These will be considered in later steps if needed.

## Conclusion

The Event System is deliberately **simple and explicit**. It prioritizes:
- **Understanding** over cleverness
- **Debuggability** over performance
- **Correctness** over convenience

This foundation enables AnimeHub to grow without becoming a tangled mess of dependencies.

---

**Next Step**: Implement concrete services that use this event system (Step 5).

--- FILE: README.md ---


--- FILE: .svelte-kit\ambient.d.ts ---

// this file is generated â€” do not edit it


/// <reference types="@sveltejs/kit" />

/**
 * Environment variables [loaded by Vite](https://vitejs.dev/guide/env-and-mode.html#env-files) from `.env` files and `process.env`. Like [`$env/dynamic/private`](https://svelte.dev/docs/kit/$env-dynamic-private), this module cannot be imported into client-side code. This module only includes variables that _do not_ begin with [`config.kit.env.publicPrefix`](https://svelte.dev/docs/kit/configuration#env) _and do_ start with [`config.kit.env.privatePrefix`](https://svelte.dev/docs/kit/configuration#env) (if configured).
 * 
 * _Unlike_ [`$env/dynamic/private`](https://svelte.dev/docs/kit/$env-dynamic-private), the values exported from this module are statically injected into your bundle at build time, enabling optimisations like dead code elimination.
 * 
 * ```ts
 * import { API_KEY } from '$env/static/private';
 * ```
 * 
 * Note that all environment variables referenced in your code should be declared (for example in an `.env` file), even if they don't have a value until the app is deployed:
 * 
 * ```
 * MY_FEATURE_FLAG=""
 * ```
 * 
 * You can override `.env` values from the command line like so:
 * 
 * ```sh
 * MY_FEATURE_FLAG="enabled" npm run dev
 * ```
 */
declare module '$env/static/private' {
	export const ALLUSERSPROFILE: string;
	export const APPDATA: string;
	export const ChocolateyInstall: string;
	export const ChocolateyLastPathUpdate: string;
	export const COLOR: string;
	export const CommonProgramFiles: string;
	export const CommonProgramW6432: string;
	export const COMPUTERNAME: string;
	export const ComSpec: string;
	export const DriverData: string;
	export const EDITOR: string;
	export const EFC_8428_1262719628: string;
	export const EFC_8428_1592913036: string;
	export const EFC_8428_2283032206: string;
	export const EFC_8428_2775293581: string;
	export const EFC_8428_3789132940: string;
	export const FPS_BROWSER_APP_PROFILE_STRING: string;
	export const FPS_BROWSER_USER_PROFILE_STRING: string;
	export const HOME: string;
	export const HOMEDRIVE: string;
	export const HOMEPATH: string;
	export const INIT_CWD: string;
	export const LOCALAPPDATA: string;
	export const LOGONSERVER: string;
	export const NODE: string;
	export const NODE_ENV: string;
	export const NODE_EXE: string;
	export const NPM_CLI_JS: string;
	export const npm_command: string;
	export const npm_config_cache: string;
	export const npm_config_globalconfig: string;
	export const npm_config_global_prefix: string;
	export const npm_config_init_module: string;
	export const npm_config_local_prefix: string;
	export const npm_config_node_gyp: string;
	export const npm_config_noproxy: string;
	export const npm_config_npm_version: string;
	export const npm_config_prefix: string;
	export const npm_config_userconfig: string;
	export const npm_config_user_agent: string;
	export const npm_execpath: string;
	export const npm_lifecycle_event: string;
	export const npm_lifecycle_script: string;
	export const npm_node_execpath: string;
	export const npm_package_json: string;
	export const npm_package_name: string;
	export const npm_package_version: string;
	export const NPM_PREFIX_JS: string;
	export const NPM_PREFIX_NPM_CLI_JS: string;
	export const NUMBER_OF_PROCESSORS: string;
	export const OneDrive: string;
	export const OneDriveConsumer: string;
	export const OS: string;
	export const Path: string;
	export const PATHEXT: string;
	export const POWERSHELL_TELEMETRY_OPTOUT: string;
	export const PROCESSOR_ARCHITECTURE: string;
	export const PROCESSOR_IDENTIFIER: string;
	export const PROCESSOR_LEVEL: string;
	export const PROCESSOR_REVISION: string;
	export const ProgramData: string;
	export const ProgramFiles: string;
	export const ProgramW6432: string;
	export const PROMPT: string;
	export const PSModulePath: string;
	export const PUBLIC: string;
	export const SESSIONNAME: string;
	export const SystemDrive: string;
	export const SystemRoot: string;
	export const TAURI_CLI_VERBOSITY: string;
	export const TAURI_DIALOG_PLUGIN_CONFIG: string;
	export const TAURI_ENV_ARCH: string;
	export const TAURI_ENV_DEBUG: string;
	export const TAURI_ENV_FAMILY: string;
	export const TAURI_ENV_PLATFORM: string;
	export const TAURI_ENV_PLATFORM_VERSION: string;
	export const TAURI_ENV_TARGET_TRIPLE: string;
	export const TEMP: string;
	export const TMP: string;
	export const USERDOMAIN: string;
	export const USERDOMAIN_ROAMINGPROFILE: string;
	export const USERNAME: string;
	export const USERPROFILE: string;
	export const windir: string;
	export const ZES_ENABLE_SYSMAN: string;
}

/**
 * Similar to [`$env/static/private`](https://svelte.dev/docs/kit/$env-static-private), except that it only includes environment variables that begin with [`config.kit.env.publicPrefix`](https://svelte.dev/docs/kit/configuration#env) (which defaults to `PUBLIC_`), and can therefore safely be exposed to client-side code.
 * 
 * Values are replaced statically at build time.
 * 
 * ```ts
 * import { PUBLIC_BASE_URL } from '$env/static/public';
 * ```
 */
declare module '$env/static/public' {
	
}

/**
 * This module provides access to runtime environment variables, as defined by the platform you're running on. For example if you're using [`adapter-node`](https://github.com/sveltejs/kit/tree/main/packages/adapter-node) (or running [`vite preview`](https://svelte.dev/docs/kit/cli)), this is equivalent to `process.env`. This module only includes variables that _do not_ begin with [`config.kit.env.publicPrefix`](https://svelte.dev/docs/kit/configuration#env) _and do_ start with [`config.kit.env.privatePrefix`](https://svelte.dev/docs/kit/configuration#env) (if configured).
 * 
 * This module cannot be imported into client-side code.
 * 
 * ```ts
 * import { env } from '$env/dynamic/private';
 * console.log(env.DEPLOYMENT_SPECIFIC_VARIABLE);
 * ```
 * 
 * > [!NOTE] In `dev`, `$env/dynamic` always includes environment variables from `.env`. In `prod`, this behavior will depend on your adapter.
 */
declare module '$env/dynamic/private' {
	export const env: {
		ALLUSERSPROFILE: string;
		APPDATA: string;
		ChocolateyInstall: string;
		ChocolateyLastPathUpdate: string;
		COLOR: string;
		CommonProgramFiles: string;
		CommonProgramW6432: string;
		COMPUTERNAME: string;
		ComSpec: string;
		DriverData: string;
		EDITOR: string;
		EFC_8428_1262719628: string;
		EFC_8428_1592913036: string;
		EFC_8428_2283032206: string;
		EFC_8428_2775293581: string;
		EFC_8428_3789132940: string;
		FPS_BROWSER_APP_PROFILE_STRING: string;
		FPS_BROWSER_USER_PROFILE_STRING: string;
		HOME: string;
		HOMEDRIVE: string;
		HOMEPATH: string;
		INIT_CWD: string;
		LOCALAPPDATA: string;
		LOGONSERVER: string;
		NODE: string;
		NODE_ENV: string;
		NODE_EXE: string;
		NPM_CLI_JS: string;
		npm_command: string;
		npm_config_cache: string;
		npm_config_globalconfig: string;
		npm_config_global_prefix: string;
		npm_config_init_module: string;
		npm_config_local_prefix: string;
		npm_config_node_gyp: string;
		npm_config_noproxy: string;
		npm_config_npm_version: string;
		npm_config_prefix: string;
		npm_config_userconfig: string;
		npm_config_user_agent: string;
		npm_execpath: string;
		npm_lifecycle_event: string;
		npm_lifecycle_script: string;
		npm_node_execpath: string;
		npm_package_json: string;
		npm_package_name: string;
		npm_package_version: string;
		NPM_PREFIX_JS: string;
		NPM_PREFIX_NPM_CLI_JS: string;
		NUMBER_OF_PROCESSORS: string;
		OneDrive: string;
		OneDriveConsumer: string;
		OS: string;
		Path: string;
		PATHEXT: string;
		POWERSHELL_TELEMETRY_OPTOUT: string;
		PROCESSOR_ARCHITECTURE: string;
		PROCESSOR_IDENTIFIER: string;
		PROCESSOR_LEVEL: string;
		PROCESSOR_REVISION: string;
		ProgramData: string;
		ProgramFiles: string;
		ProgramW6432: string;
		PROMPT: string;
		PSModulePath: string;
		PUBLIC: string;
		SESSIONNAME: string;
		SystemDrive: string;
		SystemRoot: string;
		TAURI_CLI_VERBOSITY: string;
		TAURI_DIALOG_PLUGIN_CONFIG: string;
		TAURI_ENV_ARCH: string;
		TAURI_ENV_DEBUG: string;
		TAURI_ENV_FAMILY: string;
		TAURI_ENV_PLATFORM: string;
		TAURI_ENV_PLATFORM_VERSION: string;
		TAURI_ENV_TARGET_TRIPLE: string;
		TEMP: string;
		TMP: string;
		USERDOMAIN: string;
		USERDOMAIN_ROAMINGPROFILE: string;
		USERNAME: string;
		USERPROFILE: string;
		windir: string;
		ZES_ENABLE_SYSMAN: string;
		[key: `PUBLIC_${string}`]: undefined;
		[key: `${string}`]: string | undefined;
	}
}

/**
 * Similar to [`$env/dynamic/private`](https://svelte.dev/docs/kit/$env-dynamic-private), but only includes variables that begin with [`config.kit.env.publicPrefix`](https://svelte.dev/docs/kit/configuration#env) (which defaults to `PUBLIC_`), and can therefore safely be exposed to client-side code.
 * 
 * Note that public dynamic environment variables must all be sent from the server to the client, causing larger network requests â€” when possible, use `$env/static/public` instead.
 * 
 * ```ts
 * import { env } from '$env/dynamic/public';
 * console.log(env.PUBLIC_DEPLOYMENT_SPECIFIC_VARIABLE);
 * ```
 */
declare module '$env/dynamic/public' {
	export const env: {
		[key: `PUBLIC_${string}`]: string | undefined;
	}
}


--- FILE: .svelte-kit\generated\client\app.js ---
export { matchers } from './matchers.js';

export const nodes = [
	() => import('./nodes/0'),
	() => import('./nodes/1'),
	() => import('./nodes/2'),
	() => import('./nodes/3'),
	() => import('./nodes/4'),
	() => import('./nodes/5'),
	() => import('./nodes/6'),
	() => import('./nodes/7')
];

export const server_loads = [];

export const dictionary = {
		"/": [2],
		"/anime/[id]": [3],
		"/calendar": [4],
		"/library": [5],
		"/statistics": [6],
		"/subtitles": [7]
	};

export const hooks = {
	handleError: (({ error }) => { console.error(error) }),
	
	reroute: (() => {}),
	transport: {}
};

export const decoders = Object.fromEntries(Object.entries(hooks.transport).map(([k, v]) => [k, v.decode]));
export const encoders = Object.fromEntries(Object.entries(hooks.transport).map(([k, v]) => [k, v.encode]));

export const hash = false;

export const decode = (type, value) => decoders[type](value);

export { default as root } from '../root.js';

--- FILE: .svelte-kit\generated\client\matchers.js ---
export const matchers = {};

--- FILE: .svelte-kit\generated\client\nodes\0.js ---
export { default as component } from "../../../../src/routes/+layout.svelte";

--- FILE: .svelte-kit\generated\client\nodes\1.js ---
export { default as component } from "../../../../node_modules/@sveltejs/kit/src/runtime/components/svelte-5/error.svelte";

--- FILE: .svelte-kit\generated\client\nodes\2.js ---
export { default as component } from "../../../../src/routes/+page.svelte";

--- FILE: .svelte-kit\generated\client\nodes\3.js ---
export { default as component } from "../../../../src/routes/anime/[id]/+page.svelte";

--- FILE: .svelte-kit\generated\client\nodes\4.js ---
export { default as component } from "../../../../src/routes/calendar/+page.svelte";

--- FILE: .svelte-kit\generated\client\nodes\5.js ---
export { default as component } from "../../../../src/routes/library/+page.svelte";

--- FILE: .svelte-kit\generated\client\nodes\6.js ---
export { default as component } from "../../../../src/routes/statistics/+page.svelte";

--- FILE: .svelte-kit\generated\client\nodes\7.js ---
export { default as component } from "../../../../src/routes/subtitles/+page.svelte";

--- FILE: .svelte-kit\generated\root.js ---
import { asClassComponent } from 'svelte/legacy';
import Root from './root.svelte';
export default asClassComponent(Root);

--- FILE: .svelte-kit\generated\root.svelte ---
<!-- This file is generated by @sveltejs/kit â€” do not edit it! -->
<svelte:options runes={true} />
<script>
	import { setContext, onMount, tick } from 'svelte';
	import { browser } from '$app/environment';

	// stores
	let { stores, page, constructors, components = [], form, data_0 = null, data_1 = null } = $props();

	if (!browser) {
		// svelte-ignore state_referenced_locally
		setContext('__svelte__', stores);
	}

	if (browser) {
		$effect.pre(() => stores.page.set(page));
	} else {
		// svelte-ignore state_referenced_locally
		stores.page.set(page);
	}
	$effect(() => {
		stores;page;constructors;components;form;data_0;data_1;
		stores.page.notify();
	});

	let mounted = $state(false);
	let navigated = $state(false);
	let title = $state(null);

	onMount(() => {
		const unsubscribe = stores.page.subscribe(() => {
			if (mounted) {
				navigated = true;
				tick().then(() => {
					title = document.title || 'untitled page';
				});
			}
		});

		mounted = true;
		return unsubscribe;
	});

	const Pyramid_1=$derived(constructors[1])
</script>

{#if constructors[1]}
	{@const Pyramid_0 = constructors[0]}
							<!-- svelte-ignore binding_property_non_reactive -->
							<Pyramid_0 bind:this={components[0]} data={data_0} {form} params={page.params}>
								<!-- svelte-ignore binding_property_non_reactive -->
										<Pyramid_1 bind:this={components[1]} data={data_1} {form} params={page.params} />
							</Pyramid_0>

{:else}
	{@const Pyramid_0 = constructors[0]}
	<!-- svelte-ignore binding_property_non_reactive -->
	<Pyramid_0 bind:this={components[0]} data={data_0} {form} params={page.params} />

{/if}

{#if mounted}
	<div id="svelte-announcer" aria-live="assertive" aria-atomic="true" style="position: absolute; left: 0; top: 0; clip: rect(0 0 0 0); clip-path: inset(50%); overflow: hidden; white-space: nowrap; width: 1px; height: 1px">
		{#if navigated}
			{title}
		{/if}
	</div>
{/if}

--- FILE: .svelte-kit\generated\server\internal.js ---

import root from '../root.js';
import { set_building, set_prerendering } from '__sveltekit/environment';
import { set_assets } from '$app/paths/internal/server';
import { set_manifest, set_read_implementation } from '__sveltekit/server';
import { set_private_env, set_public_env } from '../../../node_modules/@sveltejs/kit/src/runtime/shared-server.js';

export const options = {
	app_template_contains_nonce: false,
	async: false,
	csp: {"mode":"auto","directives":{"upgrade-insecure-requests":false,"block-all-mixed-content":false},"reportOnly":{"upgrade-insecure-requests":false,"block-all-mixed-content":false}},
	csrf_check_origin: true,
	csrf_trusted_origins: [],
	embedded: false,
	env_public_prefix: 'PUBLIC_',
	env_private_prefix: '',
	hash_routing: false,
	hooks: null, // added lazily, via `get_hooks`
	preload_strategy: "modulepreload",
	root,
	service_worker: false,
	service_worker_options: undefined,
	templates: {
		app: ({ head, body, assets, nonce, env }) => "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"utf-8\" />\r\n    <link rel=\"icon\" href=\"" + assets + "/favicon.png\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\n    " + head + "\r\n</head>\r\n\r\n<body data-sveltekit-preload-data=\"hover\">\r\n    <div style=\"display: contents\">" + body + "</div>\r\n</body>\r\n\r\n</html>",
		error: ({ status, message }) => "<!doctype html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"utf-8\" />\n\t\t<title>" + message + "</title>\n\n\t\t<style>\n\t\t\tbody {\n\t\t\t\t--bg: white;\n\t\t\t\t--fg: #222;\n\t\t\t\t--divider: #ccc;\n\t\t\t\tbackground: var(--bg);\n\t\t\t\tcolor: var(--fg);\n\t\t\t\tfont-family:\n\t\t\t\t\tsystem-ui,\n\t\t\t\t\t-apple-system,\n\t\t\t\t\tBlinkMacSystemFont,\n\t\t\t\t\t'Segoe UI',\n\t\t\t\t\tRoboto,\n\t\t\t\t\tOxygen,\n\t\t\t\t\tUbuntu,\n\t\t\t\t\tCantarell,\n\t\t\t\t\t'Open Sans',\n\t\t\t\t\t'Helvetica Neue',\n\t\t\t\t\tsans-serif;\n\t\t\t\tdisplay: flex;\n\t\t\t\talign-items: center;\n\t\t\t\tjustify-content: center;\n\t\t\t\theight: 100vh;\n\t\t\t\tmargin: 0;\n\t\t\t}\n\n\t\t\t.error {\n\t\t\t\tdisplay: flex;\n\t\t\t\talign-items: center;\n\t\t\t\tmax-width: 32rem;\n\t\t\t\tmargin: 0 1rem;\n\t\t\t}\n\n\t\t\t.status {\n\t\t\t\tfont-weight: 200;\n\t\t\t\tfont-size: 3rem;\n\t\t\t\tline-height: 1;\n\t\t\t\tposition: relative;\n\t\t\t\ttop: -0.05rem;\n\t\t\t}\n\n\t\t\t.message {\n\t\t\t\tborder-left: 1px solid var(--divider);\n\t\t\t\tpadding: 0 0 0 1rem;\n\t\t\t\tmargin: 0 0 0 1rem;\n\t\t\t\tmin-height: 2.5rem;\n\t\t\t\tdisplay: flex;\n\t\t\t\talign-items: center;\n\t\t\t}\n\n\t\t\t.message h1 {\n\t\t\t\tfont-weight: 400;\n\t\t\t\tfont-size: 1em;\n\t\t\t\tmargin: 0;\n\t\t\t}\n\n\t\t\t@media (prefers-color-scheme: dark) {\n\t\t\t\tbody {\n\t\t\t\t\t--bg: #222;\n\t\t\t\t\t--fg: #ddd;\n\t\t\t\t\t--divider: #666;\n\t\t\t\t}\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div class=\"error\">\n\t\t\t<span class=\"status\">" + status + "</span>\n\t\t\t<div class=\"message\">\n\t\t\t\t<h1>" + message + "</h1>\n\t\t\t</div>\n\t\t</div>\n\t</body>\n</html>\n"
	},
	version_hash: "14e0ohe"
};

export async function get_hooks() {
	let handle;
	let handleFetch;
	let handleError;
	let handleValidationError;
	let init;
	

	let reroute;
	let transport;
	

	return {
		handle,
		handleFetch,
		handleError,
		handleValidationError,
		init,
		reroute,
		transport
	};
}

export { set_assets, set_building, set_manifest, set_prerendering, set_private_env, set_public_env, set_read_implementation };


--- FILE: .svelte-kit\non-ambient.d.ts ---

// this file is generated â€” do not edit it


declare module "svelte/elements" {
	export interface HTMLAttributes<T> {
		'data-sveltekit-keepfocus'?: true | '' | 'off' | undefined | null;
		'data-sveltekit-noscroll'?: true | '' | 'off' | undefined | null;
		'data-sveltekit-preload-code'?:
			| true
			| ''
			| 'eager'
			| 'viewport'
			| 'hover'
			| 'tap'
			| 'off'
			| undefined
			| null;
		'data-sveltekit-preload-data'?: true | '' | 'hover' | 'tap' | 'off' | undefined | null;
		'data-sveltekit-reload'?: true | '' | 'off' | undefined | null;
		'data-sveltekit-replacestate'?: true | '' | 'off' | undefined | null;
	}
}

export {};


declare module "$app/types" {
	export interface AppTypes {
		RouteId(): "/" | "/anime" | "/anime/[id]" | "/calendar" | "/library" | "/statistics" | "/subtitles";
		RouteParams(): {
			"/anime/[id]": { id: string }
		};
		LayoutParams(): {
			"/": { id?: string };
			"/anime": { id?: string };
			"/anime/[id]": { id: string };
			"/calendar": Record<string, never>;
			"/library": Record<string, never>;
			"/statistics": Record<string, never>;
			"/subtitles": Record<string, never>
		};
		Pathname(): "/" | "/anime" | "/anime/" | `/anime/${string}` & {} | `/anime/${string}/` & {} | "/calendar" | "/calendar/" | "/library" | "/library/" | "/statistics" | "/statistics/" | "/subtitles" | "/subtitles/";
		ResolvedPathname(): `${"" | `/${string}`}${ReturnType<AppTypes['Pathname']>}`;
		Asset(): string & {};
	}
}

--- FILE: .svelte-kit\types\route_meta_data.json ---
{
	"/": [],
	"/anime/[id]": [],
	"/calendar": [],
	"/library": [],
	"/statistics": [],
	"/subtitles": []
}

--- FILE: .svelte-kit\types\src\routes\$types.d.ts ---
import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = EnsureDefined<LayoutData>;
type LayoutRouteId = RouteId | "/" | "/anime/[id]" | "/calendar" | "/library" | "/statistics" | "/subtitles" | null
type LayoutParams = RouteParams & { id?: string }
type LayoutParentData = EnsureDefined<{}>;

export type PageServerData = null;
export type PageData = Expand<PageParentData>;
export type PageProps = { params: RouteParams; data: PageData }
export type LayoutServerData = null;
export type LayoutData = Expand<LayoutParentData>;
export type LayoutProps = { params: LayoutParams; data: LayoutData; children: import("svelte").Snippet }

--- FILE: .svelte-kit\types\src\routes\anime\[id]\$types.d.ts ---
import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = { id: string };
type RouteId = '/anime/[id]';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = EnsureDefined<import('../../$types.js').LayoutData>;

export type EntryGenerator = () => Promise<Array<RouteParams>> | Array<RouteParams>;
export type PageServerData = null;
export type PageData = Expand<PageParentData>;
export type PageProps = { params: RouteParams; data: PageData }

--- FILE: .svelte-kit\types\src\routes\calendar\$types.d.ts ---
import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/calendar';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = EnsureDefined<import('../$types.js').LayoutData>;

export type PageServerData = null;
export type PageData = Expand<PageParentData>;
export type PageProps = { params: RouteParams; data: PageData }

--- FILE: .svelte-kit\types\src\routes\library\$types.d.ts ---
import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/library';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = EnsureDefined<import('../$types.js').LayoutData>;

export type PageServerData = null;
export type PageData = Expand<PageParentData>;
export type PageProps = { params: RouteParams; data: PageData }

--- FILE: .svelte-kit\types\src\routes\statistics\$types.d.ts ---
import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/statistics';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = EnsureDefined<import('../$types.js').LayoutData>;

export type PageServerData = null;
export type PageData = Expand<PageParentData>;
export type PageProps = { params: RouteParams; data: PageData }

--- FILE: .svelte-kit\types\src\routes\subtitles\$types.d.ts ---
import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/subtitles';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = EnsureDefined<import('../$types.js').LayoutData>;

export type PageServerData = null;
export type PageData = Expand<PageParentData>;
export type PageProps = { params: RouteParams; data: PageData }

--- FILE: package.json ---
{
    "name": "animehub",
    "version": "0.1.0",
    "private": true,
    "type": "module",
    "scripts": {
        "dev": "vite dev",
        "build": "vite build",
        "preview": "vite preview",
        "check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
        "check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
        "tauri": "tauri",
        "dev:tauri": "tauri dev",
        "build:tauri": "tauri build"
    },
    "devDependencies": {
        "@sveltejs/adapter-static": "^3.0.0",
        "@sveltejs/kit": "^2.15.0",
        "@sveltejs/vite-plugin-svelte": "^5.0.0",
        "@tauri-apps/cli": "^2.2.0",
        "@types/node": "^22.10.0",
        "autoprefixer": "^10.4.20",
        "postcss": "^8.4.49",
        "svelte": "^5.16.0",
        "svelte-check": "^4.1.0",
        "tailwindcss": "^3.4.17",
        "tslib": "^2.8.1",
        "typescript": "^5.7.2",
        "vite": "^6.0.0"
    },
    "dependencies": {
        "@tauri-apps/api": "^2.2.0",
        "@tauri-apps/plugin-shell": "^2.2.0",
        "lucide-svelte": "^0.469.0"
    }
}

--- FILE: src-tauri\build.rs ---
fn main() {
    tauri_build::build()
}

--- FILE: src-tauri\capabilities\default.json ---
{
    "$schema": "../gen/schemas/desktop-schema.json",
    "identifier": "main-capability",
    "description": "PermissÃµes padrÃ£o para o AnimeHub",
    "windows": [
        "main"
    ],
    "permissions": [
        "core:default",
        "shell:allow-open",
        "dialog:default",
        {
            "identifier": "fs:allow-read",
            "allow": [
                {
                    "path": "$HOME/**"
                }
            ]
        },
        {
            "identifier": "fs:allow-write",
            "allow": [
                {
                    "path": "$HOME/**"
                }
            ]
        },
        "fs:allow-exists",
        "fs:allow-stat"
    ]
}

--- FILE: src-tauri\Cargo.toml ---
[package]
name = "animehub"
version = "0.1.0"
description = "Local-first anime library manager"
authors = ["AnimeHub Team"]
edition = "2021"

# ----------------------------------------
# Build dependencies
# ----------------------------------------
[build-dependencies]
tauri-build = { version = "2.0" }

# ----------------------------------------
# Runtime dependencies (used by the binary)
# ----------------------------------------
[dependencies]
# Tauri v2 core
tauri = { version = "2.0", features = [] }
tauri-plugin-shell = "2.0"
tauri-plugin-fs = "2.0"
tauri-plugin-dialog = "2.0"
windows = { version = "0.53", features = [
  "Win32_Foundation",
  "Win32_Storage_FileSystem",
  "Win32_System_IO",
  "Win32_Security"
] }
regex = "1"



# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Database (SQLite) â€” BUNDLED to avoid sqlite3.lib issues on Windows
rusqlite = { version = "0.32", features = ["bundled"] }
r2d2 = "0.8"
r2d2_sqlite = "0.25"

# IDs & time
uuid = { version = "1.10", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }

# Errors
thiserror = "2.0"
anyhow = "1.0"

# File system & hashing
dirs = "5.0"
walkdir = "2.5"
sha2 = "0.10"
notify = "6.1"

# Async / events
tokio = { version = "1.40", features = ["full"] }
async-trait = "0.1"

# External integrations
reqwest = { version = "0.12", features = ["json"] }

# Subtitle processing
subparse = "0.7"

# ----------------------------------------
# Dev-only dependencies (tests, helpers)
# ----------------------------------------
[dev-dependencies]
tempfile = "3"

# ----------------------------------------
# Features
# ----------------------------------------
[features]
default = ["custom-protocol"]
custom-protocol = ["tauri/custom-protocol"]


--- FILE: src-tauri\examples\anilist_query.rs ---
// src-tauri/examples/anilist_query.rs
use animehub::integrations::anilist::client::AniListClient;
use tokio;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = AniListClient::new();
    let results = client.search_anime("Naruto").await?;
    println!("Found {} results", results.len());
    for a in results {
        println!("{} - episodes: {:?}", a.title.romaji.unwrap_or_default(), a.episodes);
    }
    Ok(())
}


--- FILE: src-tauri\examples\mpv_test.rs ---
use std::path::PathBuf;
use std::thread::sleep;
use std::time::Duration;

use animehub::integrations::mpv::client::MpvClient;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let video = std::env::args()
        .nth(1)
        .expect("Passe o caminho do vÃ­deo como argumento");

    let video_path = PathBuf::from(video);

    // Cria o cliente MPV
    let client = MpvClient::new()?;

    // LanÃ§a o MPV e carrega o vÃ­deo
    client.launch(video_path)?;
    println!("MPV launched. Pausando em 2s...");

    sleep(Duration::from_secs(2));

    // Usa API pÃºblica (NUNCA send_command)
    client.pause()?;
    println!("Pausado. Retomando em 2s...");

    sleep(Duration::from_secs(2));

    client.resume()?;
    println!("Resumed. Parando em 3s...");

    sleep(Duration::from_secs(3));

    client.stop()?;
    println!("MPV stopped.");

    Ok(())
}


--- FILE: src-tauri\examples\playback_e2e_test.rs ---
// src-tauri/examples/playback_e2e_test.rs
//
// PHASE 3 VALIDATION TEST: Post-Resolution Phase (Playback)
//
// PURPOSE:
// - Validate that playback works after explicit domain resolution
// - Flow: Scan â†’ Create Anime (via service) â†’ Create Episode (via service) â†’ 
//         Link File (via service) â†’ Start Playback â†’ Stop Playback
// - Validate MPV opens and closes cleanly
//
// CONTRACT REFERENCES:
// - SERVICE_CONTRACTS.md Section 1: Anime Service
// - SERVICE_CONTRACTS.md Section 2: Episode Service
// - SERVICE_CONTRACTS.md Section 3: File Service
// - SERVICE_CONTRACTS.md Section 5: Playback Service
//
// CRITICAL:
// - Domain entities are created EXPLICITLY via services
// - No implicit inference from file names
// - This is the canonical flow for playback

use std::sync::Arc;
use std::path::PathBuf;
use std::thread::sleep;
use std::time::Duration;

use animehub::db::{create_connection_pool, initialize_database};
use animehub::domain::anime::{AnimeType, AnimeStatus};
use animehub::domain::episode::EpisodeNumber;
use animehub::domain::file::FileType;
use animehub::events::EventBus;
use animehub::integrations::MpvClient;
use animehub::repositories::*;
use animehub::services::*;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== PLAYBACK E2E TEST ===");
    println!("Purpose: Validate post-resolution playback flow");
    println!();

    // =========================================================================
    // 1. INFRASTRUCTURE BOOTSTRAP (same as main.rs)
    // =========================================================================
    println!("[SETUP] Bootstrapping infrastructure...");
    
    let event_bus = Arc::new(EventBus::new());
    let pool = Arc::new(create_connection_pool()?);
    let mpv_client = Arc::new(MpvClient::new()?);

    // Initialize schema (idempotent)
    {
        let conn = pool.get()?;
        initialize_database(&conn)?;
    }
    println!("[SETUP] Database initialized.");

    // =========================================================================
    // 2. REPOSITORIES
    // =========================================================================
    let anime_repo: Arc<dyn AnimeRepository> = Arc::new(SqliteAnimeRepository::new(pool.clone()));
    let episode_repo: Arc<dyn EpisodeRepository> = Arc::new(SqliteEpisodeRepository::new(pool.clone()));
    let file_repo: Arc<dyn FileRepository> = Arc::new(SqliteFileRepository::new(pool.clone()));
    let anime_alias_repo: Arc<dyn AnimeAliasRepository> = Arc::new(SqliteAnimeAliasRepository::new(pool.clone()));
    let external_ref_repo: Arc<dyn ExternalReferenceRepository> = Arc::new(SqliteExternalReferenceRepository::new(pool.clone()));

    // =========================================================================
    // 3. SERVICES
    // =========================================================================
    let anime_service = Arc::new(AnimeService::new(
        anime_repo.clone(),
        anime_alias_repo.clone(),
        external_ref_repo.clone(),
        event_bus.clone(),
    ));
    let episode_service = Arc::new(EpisodeService::new(
        episode_repo.clone(),
        anime_repo.clone(),
        file_repo.clone(),
        event_bus.clone(),
    ));
    let file_service = Arc::new(FileService::new(file_repo.clone(), event_bus.clone()));
    let playback_service = Arc::new(PlaybackService::new(
        episode_repo.clone(),
        file_repo.clone(),
        event_bus.clone(),
        mpv_client.clone(),
    ));

    // Register event handlers (same as main.rs)
    episode_service.register_event_handlers();

    println!("[SETUP] Services initialized.");
    println!();

    // =========================================================================
    // 4. GET TEST VIDEO FILE FROM ARGS
    // =========================================================================
    let video_path = std::env::args()
        .nth(1)
        .map(PathBuf::from)
        .unwrap_or_else(|| {
            eprintln!("Usage: cargo run --example playback_e2e_test -- <video_file_path>");
            eprintln!("       The file should be a valid video file (e.g., .mkv, .mp4).");
            std::process::exit(1);
        });

    if !video_path.exists() {
        eprintln!("[ERROR] Video file does not exist: {:?}", video_path);
        std::process::exit(1);
    }

    if !video_path.is_file() {
        eprintln!("[ERROR] Path is not a file: {:?}", video_path);
        std::process::exit(1);
    }

    println!("[TEST] Video file: {:?}", video_path);
    println!();

    // =========================================================================
    // 5. STEP 1: SCAN DIRECTORY (to register the file)
    // =========================================================================
    println!("[STEP 1] Scanning directory to register file...");
    
    let parent_dir = video_path.parent()
        .ok_or("Cannot get parent directory")?
        .to_path_buf();
    
    let files_found = file_service.scan_directory(parent_dir)?;
    println!("[STEP 1] Files found: {}", files_found);

    // Retrieve the file entity by path
    let file = file_repo.get_by_path(&video_path)?
        .ok_or("File was not registered after scan")?;
    
    if file.tipo != FileType::Video {
        eprintln!("[ERROR] File is not a video type: {:?}", file.tipo);
        std::process::exit(1);
    }

    println!("[STEP 1] File registered with ID: {}", file.id);
    println!();

    // =========================================================================
    // 6. STEP 2: CREATE ANIME (via service)
    // =========================================================================
    println!("[STEP 2] Creating Anime via AnimeService...");
    
    let create_anime_request = CreateAnimeRequest {
        titulo_principal: "Test Anime for Playback E2E".to_string(),
        titulos_alternativos: vec![],
        tipo: AnimeType::TV,
        status: AnimeStatus::EmExibicao,
        total_episodios: Some(12),
        data_inicio: None,
        data_fim: None,
        metadados_livres: serde_json::json!({}),
    };

    let anime_id = anime_service.create_anime(create_anime_request)?;
    println!("[STEP 2] Anime created with ID: {}", anime_id);
    println!();

    // =========================================================================
    // 7. STEP 3: CREATE EPISODE (via service)
    // =========================================================================
    println!("[STEP 3] Creating Episode via EpisodeService...");
    
    let create_episode_request = CreateEpisodeRequest {
        anime_id,
        numero: EpisodeNumber::Regular { numero: 1 },
        titulo: Some("Episode 1 - Test".to_string()),
        duracao_esperada: Some(1440), // 24 minutes in seconds
    };

    let episode_id = episode_service.create_episode(create_episode_request)?;
    println!("[STEP 3] Episode created with ID: {}", episode_id);
    println!();

    // =========================================================================
    // 8. STEP 4: LINK FILE TO EPISODE (via service)
    // =========================================================================
    println!("[STEP 4] Linking File to Episode via EpisodeService...");
    
    let link_request = LinkFileRequest {
        episode_id,
        file_id: file.id,
        is_primary: true,
    };

    episode_service.link_file(link_request)?;
    println!("[STEP 4] File linked to Episode as primary.");
    println!();

    // =========================================================================
    // 9. STEP 5: START PLAYBACK (via service)
    // =========================================================================
    println!("[STEP 5] Starting playback via PlaybackService...");
    println!("--- Events will be printed below ---");
    println!();

    let playback_request = StartPlaybackRequest {
        episode_id,
        file_id: Some(file.id),
    };

    let played_path = playback_service.start_playback(playback_request)?;
    println!();
    println!("[STEP 5] Playback started for: {:?}", played_path);
    println!();

    // =========================================================================
    // 10. STEP 6: LET PLAYBACK RUN BRIEFLY
    // =========================================================================
    println!("[STEP 6] Letting playback run for 5 seconds...");
    println!("         (MPV window should be visible)");
    sleep(Duration::from_secs(5));
    println!("[STEP 6] Wait complete.");
    println!();

    // =========================================================================
    // 11. STEP 7: STOP PLAYBACK (via service)
    // =========================================================================
    println!("[STEP 7] Stopping playback via PlaybackService...");
    
    playback_service.stop_playback(episode_id)?;
    
    println!("[STEP 7] Playback stopped.");
    println!();

    // Give MPV time to close
    sleep(Duration::from_millis(500));

    // =========================================================================
    // 12. FINAL RESULT
    // =========================================================================
    println!("===========================================");
    println!("PLAYBACK E2E TEST: PASSED");
    println!("===========================================");
    println!();
    println!("Summary:");
    println!("  - Video file: {:?}", video_path);
    println!("  - File ID: {}", file.id);
    println!("  - Anime ID: {}", anime_id);
    println!("  - Episode ID: {}", episode_id);
    println!("  - Playback started: YES");
    println!("  - Playback stopped: YES");
    println!("  - MPV opened: YES (verify visually)");
    println!("  - MPV closed: YES (verify visually)");
    println!();
    println!("This test validates the post-resolution playback flow.");

    Ok(())
}


--- FILE: src-tauri\examples\playback_event_validation_test.rs ---
// src-tauri/examples/playback_event_validation_test.rs
//
// PHASE 3 VALIDATION TEST: Playback Event Emission
//
// PURPOSE:
// - Prove canonical event emission during playback lifecycle
// - Validate: PlaybackStarted, PlaybackProgressUpdated, PlaybackStopped
// - Events are observed via EventBus::subscribe (public API)
// - Events are also logged to stdout by EventBus::emit (built-in behavior)
//
// CONTRACT REFERENCES:
// - EVENT_MAP.md Section 5: PlaybackStarted
// - EVENT_MAP.md Section 6: PlaybackProgressUpdated
// - SERVICE_CONTRACTS.md Section 5: Playback Service (emits PlaybackStopped)
//
// OBSERVATION METHOD:
// - EventBus::subscribe<E, F> is used to register handlers
// - Handlers print event details to stdout
// - EventBus::emit already prints "[EVENT] ..." lines (built-in)

use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::path::PathBuf;
use std::thread::sleep;
use std::time::Duration;

use animehub::db::{create_connection_pool, initialize_database};
use animehub::domain::anime::{AnimeType, AnimeStatus};
use animehub::domain::episode::EpisodeNumber;
use animehub::domain::file::FileType;
use animehub::events::{EventBus, PlaybackStarted, PlaybackProgressUpdated, PlaybackStopped};
use animehub::integrations::MpvClient;
use animehub::repositories::*;
use animehub::services::*;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== PLAYBACK EVENT VALIDATION TEST ===");
    println!("Purpose: Validate canonical event emission during playback");
    println!();

    // =========================================================================
    // 1. INFRASTRUCTURE BOOTSTRAP
    // =========================================================================
    println!("[SETUP] Bootstrapping infrastructure...");
    
    let event_bus = Arc::new(EventBus::new());
    let pool = Arc::new(create_connection_pool()?);
    let mpv_client = Arc::new(MpvClient::new()?);

    {
        let conn = pool.get()?;
        initialize_database(&conn)?;
    }

    // =========================================================================
    // 2. REPOSITORIES
    // =========================================================================
    let anime_repo: Arc<dyn AnimeRepository> = Arc::new(SqliteAnimeRepository::new(pool.clone()));
    let episode_repo: Arc<dyn EpisodeRepository> = Arc::new(SqliteEpisodeRepository::new(pool.clone()));
    let file_repo: Arc<dyn FileRepository> = Arc::new(SqliteFileRepository::new(pool.clone()));
    let anime_alias_repo: Arc<dyn AnimeAliasRepository> = Arc::new(SqliteAnimeAliasRepository::new(pool.clone()));
    let external_ref_repo: Arc<dyn ExternalReferenceRepository> = Arc::new(SqliteExternalReferenceRepository::new(pool.clone()));

    // =========================================================================
    // 3. SERVICES
    // =========================================================================
    let anime_service = Arc::new(AnimeService::new(
        anime_repo.clone(),
        anime_alias_repo.clone(),
        external_ref_repo.clone(),
        event_bus.clone(),
    ));
    let episode_service = Arc::new(EpisodeService::new(
        episode_repo.clone(),
        anime_repo.clone(),
        file_repo.clone(),
        event_bus.clone(),
    ));
    let file_service = Arc::new(FileService::new(file_repo.clone(), event_bus.clone()));
    let playback_service = Arc::new(PlaybackService::new(
        episode_repo.clone(),
        file_repo.clone(),
        event_bus.clone(),
        mpv_client.clone(),
    ));

    episode_service.register_event_handlers();

    println!("[SETUP] Services initialized.");
    println!();

    // =========================================================================
    // 4. REGISTER EVENT OBSERVERS
    // =========================================================================
    println!("[SETUP] Registering event observers...");

    // Counters for validation
    let started_count = Arc::new(AtomicUsize::new(0));
    let progress_count = Arc::new(AtomicUsize::new(0));
    let stopped_count = Arc::new(AtomicUsize::new(0));

    // PlaybackStarted observer
    {
        let counter = Arc::clone(&started_count);
        event_bus.subscribe::<PlaybackStarted, _>(move |event| {
            counter.fetch_add(1, Ordering::SeqCst);
            println!("[OBSERVER] PlaybackStarted received:");
            println!("           episode_id: {}", event.episode_id);
            println!("           event_id: {}", event.event_id);
            println!("           occurred_at: {}", event.occurred_at);
        });
    }

    // PlaybackProgressUpdated observer
    {
        let counter = Arc::clone(&progress_count);
        event_bus.subscribe::<PlaybackProgressUpdated, _>(move |event| {
            counter.fetch_add(1, Ordering::SeqCst);
            println!("[OBSERVER] PlaybackProgressUpdated received:");
            println!("           episode_id: {}", event.episode_id);
            println!("           progress_seconds: {}", event.progress_seconds);
        });
    }

    // PlaybackStopped observer
    {
        let counter = Arc::clone(&stopped_count);
        event_bus.subscribe::<PlaybackStopped, _>(move |event| {
            counter.fetch_add(1, Ordering::SeqCst);
            println!("[OBSERVER] PlaybackStopped received:");
            println!("           episode_id: {}", event.episode_id);
            println!("           final_progress_seconds: {}", event.final_progress_seconds);
        });
    }

    println!("[SETUP] Event observers registered.");
    println!();

    // =========================================================================
    // 5. GET TEST VIDEO FILE FROM ARGS
    // =========================================================================
    let video_path = std::env::args()
        .nth(1)
        .map(PathBuf::from)
        .unwrap_or_else(|| {
            eprintln!("Usage: cargo run --example playback_event_validation_test -- <video_file_path>");
            std::process::exit(1);
        });

    if !video_path.exists() || !video_path.is_file() {
        eprintln!("[ERROR] Invalid video file: {:?}", video_path);
        std::process::exit(1);
    }

    println!("[TEST] Video file: {:?}", video_path);
    println!();

    // =========================================================================
    // 6. SETUP: Scan, Create Anime, Create Episode, Link File
    // =========================================================================
    println!("[SETUP] Creating test entities...");

    // Scan
    let parent_dir = video_path.parent().unwrap().to_path_buf();
    file_service.scan_directory(parent_dir)?;
    let file = file_repo.get_by_path(&video_path)?.ok_or("File not found")?;

    // Create Anime
    let anime_id = anime_service.create_anime(CreateAnimeRequest {
        titulo_principal: "Event Validation Test Anime".to_string(),
        titulos_alternativos: vec![],
        tipo: AnimeType::TV,
        status: AnimeStatus::EmExibicao,
        total_episodios: Some(12),
        data_inicio: None,
        data_fim: None,
        metadados_livres: serde_json::json!({}),
    })?;

    // Create Episode
    let episode_id = episode_service.create_episode(CreateEpisodeRequest {
        anime_id,
        numero: EpisodeNumber::Regular { numero: 1 },
        titulo: Some("Event Test Episode".to_string()),
        duracao_esperada: Some(1440),
    })?;

    // Link File
    episode_service.link_file(LinkFileRequest {
        episode_id,
        file_id: file.id,
        is_primary: true,
    })?;

    println!("[SETUP] Test entities created.");
    println!("        Anime ID: {}", anime_id);
    println!("        Episode ID: {}", episode_id);
    println!("        File ID: {}", file.id);
    println!();

    // Clear event log before playback
    event_bus.clear_event_log();

    // =========================================================================
    // 7. START PLAYBACK
    // =========================================================================
    println!("[PLAYBACK] Starting playback...");
    println!("=== EVENT OUTPUT BEGIN ===");
    println!();

    playback_service.start_playback(StartPlaybackRequest {
        episode_id,
        file_id: Some(file.id),
    })?;

    // =========================================================================
    // 8. WAIT FOR PROGRESS EVENTS
    // =========================================================================
    // PlaybackObserver polls every 2000ms with min_progress_delta of 5 seconds
    // Wait 7 seconds to ensure at least one progress event
    println!();
    println!("[PLAYBACK] Waiting 7 seconds for progress events...");
    sleep(Duration::from_secs(7));

    // =========================================================================
    // 9. STOP PLAYBACK
    // =========================================================================
    println!();
    println!("[PLAYBACK] Stopping playback...");
    playback_service.stop_playback(episode_id)?;

    println!();
    println!("=== EVENT OUTPUT END ===");
    println!();

    // Give time for final events
    sleep(Duration::from_millis(500));

    // =========================================================================
    // 10. VALIDATE EVENT COUNTS
    // =========================================================================
    println!("[VALIDATION] Checking event counts...");

    let started = started_count.load(Ordering::SeqCst);
    let progress = progress_count.load(Ordering::SeqCst);
    let stopped = stopped_count.load(Ordering::SeqCst);

    println!("  PlaybackStarted: {}", started);
    println!("  PlaybackProgressUpdated: {}", progress);
    println!("  PlaybackStopped: {}", stopped);
    println!();

    let mut passed = true;

    if started < 1 {
        println!("[FAIL] Expected at least 1 PlaybackStarted event.");
        passed = false;
    } else {
        println!("[PASS] PlaybackStarted emitted.");
    }

    // Note: PlaybackProgressUpdated may be 0 if video is very short or MPV didn't report position
    // We check for >= 0 but warn if 0
    if progress == 0 {
        println!("[WARN] No PlaybackProgressUpdated events received.");
        println!("       This may be expected for very short playback or if MPV didn't report position.");
    } else {
        println!("[PASS] PlaybackProgressUpdated emitted ({} times).", progress);
    }

    // PlaybackStopped is emitted by the observer when MPV stops
    // It may not be emitted if we call stop_playback before observer detects it
    if stopped == 0 {
        println!("[WARN] No PlaybackStopped events received.");
        println!("       This may be expected if stop_playback was called before observer detected stop.");
    } else {
        println!("[PASS] PlaybackStopped emitted.");
    }

    println!();

    // =========================================================================
    // 11. FINAL RESULT
    // =========================================================================
    if passed {
        println!("===========================================");
        println!("PLAYBACK EVENT VALIDATION TEST: PASSED");
        println!("===========================================");
    } else {
        println!("===========================================");
        println!("PLAYBACK EVENT VALIDATION TEST: FAILED");
        println!("===========================================");
        std::process::exit(1);
    }

    println!();
    println!("Summary:");
    println!("  - PlaybackStarted: {} (required: >= 1)", started);
    println!("  - PlaybackProgressUpdated: {} (informational)", progress);
    println!("  - PlaybackStopped: {} (informational)", stopped);
    println!();
    println!("This test validates canonical event emission during playback.");

    Ok(())
}


--- FILE: src-tauri\examples\playback_invalid_state_test.rs ---
// src-tauri/examples/playback_invalid_state_test.rs
//
// PHASE 3 VALIDATION TEST: Invalid State Handling
//
// PURPOSE:
// - Prove system gracefully rejects invalid playback attempts
// - Case 1: Episode with no linked file â†’ error, no MPV launch
// - Case 2: Invalid episode ID â†’ NotFound error, no MPV launch
// - No panic in any case
//
// CONTRACT REFERENCES:
// - playback_service.rs line 12038: "No video file linked" error
// - playback_service.rs line 12032: NotFound error for missing episode
//
// VALIDATION:
// - Errors are returned (not panics)
// - MPV is never launched
// - System remains stable

use std::sync::Arc;
use uuid::Uuid;

use animehub::db::{create_connection_pool, initialize_database};
use animehub::domain::anime::{AnimeType, AnimeStatus};
use animehub::domain::episode::EpisodeNumber;
use animehub::events::EventBus;
use animehub::integrations::MpvClient;
use animehub::repositories::*;
use animehub::services::*;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== PLAYBACK INVALID STATE TEST ===");
    println!("Purpose: Validate graceful rejection of invalid playback attempts");
    println!();

    // =========================================================================
    // 1. INFRASTRUCTURE BOOTSTRAP
    // =========================================================================
    println!("[SETUP] Bootstrapping infrastructure...");
    
    let event_bus = Arc::new(EventBus::new());
    let pool = Arc::new(create_connection_pool()?);
    let mpv_client = Arc::new(MpvClient::new()?);

    {
        let conn = pool.get()?;
        initialize_database(&conn)?;
    }

    // =========================================================================
    // 2. REPOSITORIES
    // =========================================================================
    let anime_repo: Arc<dyn AnimeRepository> = Arc::new(SqliteAnimeRepository::new(pool.clone()));
    let episode_repo: Arc<dyn EpisodeRepository> = Arc::new(SqliteEpisodeRepository::new(pool.clone()));
    let file_repo: Arc<dyn FileRepository> = Arc::new(SqliteFileRepository::new(pool.clone()));
    let anime_alias_repo: Arc<dyn AnimeAliasRepository> = Arc::new(SqliteAnimeAliasRepository::new(pool.clone()));
    let external_ref_repo: Arc<dyn ExternalReferenceRepository> = Arc::new(SqliteExternalReferenceRepository::new(pool.clone()));

    // =========================================================================
    // 3. SERVICES
    // =========================================================================
    let anime_service = Arc::new(AnimeService::new(
        anime_repo.clone(),
        anime_alias_repo.clone(),
        external_ref_repo.clone(),
        event_bus.clone(),
    ));
    let episode_service = Arc::new(EpisodeService::new(
        episode_repo.clone(),
        anime_repo.clone(),
        file_repo.clone(),
        event_bus.clone(),
    ));
    let playback_service = Arc::new(PlaybackService::new(
        episode_repo.clone(),
        file_repo.clone(),
        event_bus.clone(),
        mpv_client.clone(),
    ));

    println!("[SETUP] Services initialized.");
    println!();

    let mut all_passed = true;

    // =========================================================================
    // CASE 1: Episode with no linked file
    // =========================================================================
    println!("===========================================");
    println!("CASE 1: Episode with no linked file");
    println!("===========================================");
    println!();

    // Create Anime
    println!("[CASE 1] Creating Anime...");
    let anime_id = anime_service.create_anime(CreateAnimeRequest {
        titulo_principal: "Invalid State Test Anime".to_string(),
        titulos_alternativos: vec![],
        tipo: AnimeType::TV,
        status: AnimeStatus::EmExibicao,
        total_episodios: Some(12),
        data_inicio: None,
        data_fim: None,
        metadados_livres: serde_json::json!({}),
    })?;
    println!("[CASE 1] Anime created: {}", anime_id);

    // Create Episode (WITHOUT linking any file)
    println!("[CASE 1] Creating Episode (no file linked)...");
    let episode_id = episode_service.create_episode(CreateEpisodeRequest {
        anime_id,
        numero: EpisodeNumber::Regular { numero: 1 },
        titulo: Some("Episode without file".to_string()),
        duracao_esperada: Some(1440),
    })?;
    println!("[CASE 1] Episode created: {}", episode_id);

    // Attempt playback
    println!("[CASE 1] Attempting playback (should fail)...");
    let result = playback_service.start_playback(StartPlaybackRequest {
        episode_id,
        file_id: None,
    });

    match result {
        Ok(_) => {
            println!("[FAIL] Playback started when it should have failed!");
            all_passed = false;
        }
        Err(e) => {
            let error_msg = e.to_string();
            println!("[CASE 1] Error received: {}", error_msg);
            
            if error_msg.contains("No video file linked") || error_msg.contains("no file") || error_msg.contains("Not found") {
                println!("[PASS] Correct error returned for episode with no file.");
            } else {
                println!("[WARN] Error returned but message unexpected: {}", error_msg);
                println!("       (Still passing because error was returned, not panic)");
            }
        }
    }

    // Verify MPV is not running
    if mpv_client.is_running() {
        println!("[FAIL] MPV is running when it should not be!");
        all_passed = false;
    } else {
        println!("[PASS] MPV was not launched.");
    }

    println!();

    // =========================================================================
    // CASE 2: Invalid episode ID
    // =========================================================================
    println!("===========================================");
    println!("CASE 2: Invalid episode ID");
    println!("===========================================");
    println!();

    // Generate random UUID that doesn't exist
    let fake_episode_id = Uuid::new_v4();
    println!("[CASE 2] Using non-existent episode ID: {}", fake_episode_id);

    // Attempt playback
    println!("[CASE 2] Attempting playback (should fail)...");
    let result = playback_service.start_playback(StartPlaybackRequest {
        episode_id: fake_episode_id,
        file_id: None,
    });

    match result {
        Ok(_) => {
            println!("[FAIL] Playback started when it should have failed!");
            all_passed = false;
        }
        Err(e) => {
            let error_msg = e.to_string();
            println!("[CASE 2] Error received: {}", error_msg);
            
            if error_msg.contains("Not found") || error_msg.contains("not found") || error_msg.contains("NotFound") {
                println!("[PASS] Correct NotFound error returned.");
            } else {
                println!("[WARN] Error returned but message unexpected: {}", error_msg);
                println!("       (Still passing because error was returned, not panic)");
            }
        }
    }

    // Verify MPV is not running
    if mpv_client.is_running() {
        println!("[FAIL] MPV is running when it should not be!");
        all_passed = false;
    } else {
        println!("[PASS] MPV was not launched.");
    }

    println!();

    // =========================================================================
    // CASE 3: Stop playback with invalid episode ID
    // =========================================================================
    println!("===========================================");
    println!("CASE 3: Stop playback with invalid episode ID");
    println!("===========================================");
    println!();

    let fake_episode_id_2 = Uuid::new_v4();
    println!("[CASE 3] Using non-existent episode ID: {}", fake_episode_id_2);

    // Attempt to stop playback (nothing is playing)
    println!("[CASE 3] Attempting stop_playback (should not panic)...");
    let result = playback_service.stop_playback(fake_episode_id_2);

    match result {
        Ok(_) => {
            println!("[PASS] stop_playback returned Ok (graceful no-op).");
        }
        Err(e) => {
            println!("[PASS] stop_playback returned error: {}", e);
            println!("       (Error is acceptable, panic is not)");
        }
    }

    println!();

    // =========================================================================
    // FINAL RESULT
    // =========================================================================
    if all_passed {
        println!("===========================================");
        println!("PLAYBACK INVALID STATE TEST: PASSED");
        println!("===========================================");
    } else {
        println!("===========================================");
        println!("PLAYBACK INVALID STATE TEST: FAILED");
        println!("===========================================");
        std::process::exit(1);
    }

    println!();
    println!("Summary:");
    println!("  - Case 1 (no file): Error returned, no MPV launch");
    println!("  - Case 2 (invalid ID): Error returned, no MPV launch");
    println!("  - Case 3 (stop invalid): Graceful handling, no panic");
    println!();
    println!("This test validates graceful error handling for invalid states.");

    Ok(())
}


--- FILE: src-tauri\examples\scan_validation_test.rs ---
// src-tauri/examples/scan_validation_test.rs
//
// PHASE 3 VALIDATION TEST: Pre-Resolution Phase (Scan)
//
// PURPOSE:
// - Validate that directory scan detects files correctly
// - Validate correct event emission (FileDetected, DirectoryScanned)
// - Validate that NO domain entities (Anime, Episode) are implicitly created
//
// CONTRACT REFERENCES:
// - SERVICE_CONTRACTS.md Section 3: File Service
// - EVENT_MAP.md Section 1: DirectoryScanned
// - EVENT_MAP.md Section 2: FileDetected
//
// DOES NOT:
// - Start playback
// - Infer Anime or Episode
// - Create domain entities

use std::sync::Arc;
use std::path::PathBuf;

use animehub::db::{create_connection_pool, initialize_database};
use animehub::events::EventBus;
use animehub::repositories::*;
use animehub::services::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== SCAN VALIDATION TEST ===");
    println!("Purpose: Validate pre-resolution phase (scan only)");
    println!();

    // =========================================================================
    // 1. INFRASTRUCTURE BOOTSTRAP (same as main.rs)
    // =========================================================================
    println!("[SETUP] Bootstrapping infrastructure...");
    
    let event_bus = Arc::new(EventBus::new());
    let pool = Arc::new(create_connection_pool()?);

    // Initialize schema (idempotent)
    {
        let conn = pool.get()?;
        initialize_database(&conn)?;
    }
    println!("[SETUP] Database initialized.");

    // =========================================================================
    // 2. REPOSITORIES
    // =========================================================================
    let anime_repo: Arc<dyn AnimeRepository> = Arc::new(SqliteAnimeRepository::new(pool.clone()));
    let episode_repo: Arc<dyn EpisodeRepository> = Arc::new(SqliteEpisodeRepository::new(pool.clone()));
    let file_repo: Arc<dyn FileRepository> = Arc::new(SqliteFileRepository::new(pool.clone()));

    // =========================================================================
    // 3. SERVICES (only FileService needed for this test)
    // =========================================================================
    let file_service = Arc::new(FileService::new(file_repo.clone(), event_bus.clone()));

    println!("[SETUP] Services initialized.");
    println!();

    // =========================================================================
    // 4. GET TEST DIRECTORY FROM ARGS
    // =========================================================================
    let test_dir = std::env::args()
        .nth(1)
        .map(PathBuf::from)
        .unwrap_or_else(|| {
            eprintln!("Usage: cargo run --example scan_validation_test -- <directory_path>");
            eprintln!("       The directory should contain at least one video file.");
            std::process::exit(1);
        });

    if !test_dir.exists() {
        eprintln!("[ERROR] Directory does not exist: {:?}", test_dir);
        std::process::exit(1);
    }

    println!("[TEST] Scanning directory: {:?}", test_dir);
    println!();

    // =========================================================================
    // 5. CLEAR EVENT LOG (for clean observation)
    // =========================================================================
    event_bus.clear_event_log();

    // =========================================================================
    // 6. COUNT ENTITIES BEFORE SCAN
    // =========================================================================
    let animes_before = anime_repo.list_all()?.len();
    let episodes_before: usize = {
        // Count all episodes across all animes
        let animes = anime_repo.list_all()?;
        animes.iter()
            .map(|a| episode_repo.list_by_anime(a.id).map(|e| e.len()).unwrap_or(0))
            .sum()
    };
    
    println!("[PRE-SCAN] Anime count: {}", animes_before);
    println!("[PRE-SCAN] Episode count: {}", episodes_before);
    println!();

    // =========================================================================
    // 6.5 REGISTER EVENT OBSERVERS (must happen BEFORE scan)
    // =========================================================================
    event_bus.subscribe::<animehub::events::FileDetected, _>(|_event| {
        // no-op: ensures event is observed and logged
    });
    
    event_bus.subscribe::<animehub::events::DirectoryScanned, _>(|_event| {
        // no-op: ensures event is observed and logged
    });


    // =========================================================================
    // 7. EXECUTE SCAN
    // =========================================================================
    println!("[SCAN] Starting directory scan...");
    println!("--- Events will be printed below ---");
    println!();

    let files_found = file_service.scan_directory(test_dir.clone())?;

    println!();
    println!("--- End of events ---");
    println!();
    println!("[SCAN] Files detected: {}", files_found);
    println!();

    // =========================================================================
    // 8. COUNT ENTITIES AFTER SCAN
    // =========================================================================
    let animes_after = anime_repo.list_all()?.len();
    let episodes_after: usize = {
        let animes = anime_repo.list_all()?;
        animes.iter()
            .map(|a| episode_repo.list_by_anime(a.id).map(|e| e.len()).unwrap_or(0))
            .sum()
    };

    println!("[POST-SCAN] Anime count: {}", animes_after);
    println!("[POST-SCAN] Episode count: {}", episodes_after);
    println!();

    // =========================================================================
    // 9. VALIDATE: NO IMPLICIT ENTITY CREATION
    // =========================================================================
    println!("[VALIDATION] Checking for implicit entity creation...");
    
    if animes_after != animes_before {
        println!("[FAIL] Anime entities were implicitly created!");
        println!("       Before: {}, After: {}", animes_before, animes_after);
        std::process::exit(1);
    }
    
    if episodes_after != episodes_before {
        println!("[FAIL] Episode entities were implicitly created!");
        println!("       Before: {}, After: {}", episodes_before, episodes_after);
        std::process::exit(1);
    }

    println!("[PASS] No implicit Anime or Episode entities created.");
    println!();

    // =========================================================================
    // 10. VALIDATE: EVENT LOG
    // =========================================================================
    println!("[VALIDATION] Checking event log...");
    
    let event_log = event_bus.get_event_log();
    
    let file_detected_count = event_log.iter()
        .filter(|e| e.event_type == "FileDetected")
        .count();
    
    let directory_scanned_count = event_log.iter()
        .filter(|e| e.event_type == "DirectoryScanned")
        .count();

    println!("  FileDetected events: {}", file_detected_count);
    println!("  DirectoryScanned events: {}", directory_scanned_count);

    if files_found > 0 && file_detected_count == 0 {
        println!("[FAIL] Files were found but no FileDetected events emitted!");
        std::process::exit(1);
    }

    if directory_scanned_count != 1 {
        println!("[FAIL] Expected exactly 1 DirectoryScanned event, got {}", directory_scanned_count);
        std::process::exit(1);
    }

    println!("[PASS] Events emitted correctly.");
    println!();

    // =========================================================================
    // 11. FINAL RESULT
    // =========================================================================
    println!("===========================================");
    println!("SCAN VALIDATION TEST: PASSED");
    println!("===========================================");
    println!();
    println!("Summary:");
    println!("  - Directory scanned: {:?}", test_dir);
    println!("  - Files detected: {}", files_found);
    println!("  - FileDetected events: {}", file_detected_count);
    println!("  - DirectoryScanned events: {}", directory_scanned_count);
    println!("  - Implicit Anime created: 0 (correct)");
    println!("  - Implicit Episode created: 0 (correct)");
    println!();
    println!("This test seals the pre-resolution phase of the pipeline.");

    Ok(())
}


--- FILE: src-tauri\gen\schemas\acl-manifests.json ---
{"core":{"default_permission":{"identifier":"default","description":"Default core plugins set.","permissions":["core:path:default","core:event:default","core:window:default","core:webview:default","core:app:default","core:image:default","core:resources:default","core:menu:default","core:tray:default"]},"permissions":{},"permission_sets":{},"global_scope_schema":null},"core:app":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin.","permissions":["allow-version","allow-name","allow-tauri-version","allow-identifier","allow-bundle-type","allow-register-listener","allow-remove-listener"]},"permissions":{"allow-app-hide":{"identifier":"allow-app-hide","description":"Enables the app_hide command without any pre-configured scope.","commands":{"allow":["app_hide"],"deny":[]}},"allow-app-show":{"identifier":"allow-app-show","description":"Enables the app_show command without any pre-configured scope.","commands":{"allow":["app_show"],"deny":[]}},"allow-bundle-type":{"identifier":"allow-bundle-type","description":"Enables the bundle_type command without any pre-configured scope.","commands":{"allow":["bundle_type"],"deny":[]}},"allow-default-window-icon":{"identifier":"allow-default-window-icon","description":"Enables the default_window_icon command without any pre-configured scope.","commands":{"allow":["default_window_icon"],"deny":[]}},"allow-fetch-data-store-identifiers":{"identifier":"allow-fetch-data-store-identifiers","description":"Enables the fetch_data_store_identifiers command without any pre-configured scope.","commands":{"allow":["fetch_data_store_identifiers"],"deny":[]}},"allow-identifier":{"identifier":"allow-identifier","description":"Enables the identifier command without any pre-configured scope.","commands":{"allow":["identifier"],"deny":[]}},"allow-name":{"identifier":"allow-name","description":"Enables the name command without any pre-configured scope.","commands":{"allow":["name"],"deny":[]}},"allow-register-listener":{"identifier":"allow-register-listener","description":"Enables the register_listener command without any pre-configured scope.","commands":{"allow":["register_listener"],"deny":[]}},"allow-remove-data-store":{"identifier":"allow-remove-data-store","description":"Enables the remove_data_store command without any pre-configured scope.","commands":{"allow":["remove_data_store"],"deny":[]}},"allow-remove-listener":{"identifier":"allow-remove-listener","description":"Enables the remove_listener command without any pre-configured scope.","commands":{"allow":["remove_listener"],"deny":[]}},"allow-set-app-theme":{"identifier":"allow-set-app-theme","description":"Enables the set_app_theme command without any pre-configured scope.","commands":{"allow":["set_app_theme"],"deny":[]}},"allow-set-dock-visibility":{"identifier":"allow-set-dock-visibility","description":"Enables the set_dock_visibility command without any pre-configured scope.","commands":{"allow":["set_dock_visibility"],"deny":[]}},"allow-tauri-version":{"identifier":"allow-tauri-version","description":"Enables the tauri_version command without any pre-configured scope.","commands":{"allow":["tauri_version"],"deny":[]}},"allow-version":{"identifier":"allow-version","description":"Enables the version command without any pre-configured scope.","commands":{"allow":["version"],"deny":[]}},"deny-app-hide":{"identifier":"deny-app-hide","description":"Denies the app_hide command without any pre-configured scope.","commands":{"allow":[],"deny":["app_hide"]}},"deny-app-show":{"identifier":"deny-app-show","description":"Denies the app_show command without any pre-configured scope.","commands":{"allow":[],"deny":["app_show"]}},"deny-bundle-type":{"identifier":"deny-bundle-type","description":"Denies the bundle_type command without any pre-configured scope.","commands":{"allow":[],"deny":["bundle_type"]}},"deny-default-window-icon":{"identifier":"deny-default-window-icon","description":"Denies the default_window_icon command without any pre-configured scope.","commands":{"allow":[],"deny":["default_window_icon"]}},"deny-fetch-data-store-identifiers":{"identifier":"deny-fetch-data-store-identifiers","description":"Denies the fetch_data_store_identifiers command without any pre-configured scope.","commands":{"allow":[],"deny":["fetch_data_store_identifiers"]}},"deny-identifier":{"identifier":"deny-identifier","description":"Denies the identifier command without any pre-configured scope.","commands":{"allow":[],"deny":["identifier"]}},"deny-name":{"identifier":"deny-name","description":"Denies the name command without any pre-configured scope.","commands":{"allow":[],"deny":["name"]}},"deny-register-listener":{"identifier":"deny-register-listener","description":"Denies the register_listener command without any pre-configured scope.","commands":{"allow":[],"deny":["register_listener"]}},"deny-remove-data-store":{"identifier":"deny-remove-data-store","description":"Denies the remove_data_store command without any pre-configured scope.","commands":{"allow":[],"deny":["remove_data_store"]}},"deny-remove-listener":{"identifier":"deny-remove-listener","description":"Denies the remove_listener command without any pre-configured scope.","commands":{"allow":[],"deny":["remove_listener"]}},"deny-set-app-theme":{"identifier":"deny-set-app-theme","description":"Denies the set_app_theme command without any pre-configured scope.","commands":{"allow":[],"deny":["set_app_theme"]}},"deny-set-dock-visibility":{"identifier":"deny-set-dock-visibility","description":"Denies the set_dock_visibility command without any pre-configured scope.","commands":{"allow":[],"deny":["set_dock_visibility"]}},"deny-tauri-version":{"identifier":"deny-tauri-version","description":"Denies the tauri_version command without any pre-configured scope.","commands":{"allow":[],"deny":["tauri_version"]}},"deny-version":{"identifier":"deny-version","description":"Denies the version command without any pre-configured scope.","commands":{"allow":[],"deny":["version"]}}},"permission_sets":{},"global_scope_schema":null},"core:event":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin, which enables all commands.","permissions":["allow-listen","allow-unlisten","allow-emit","allow-emit-to"]},"permissions":{"allow-emit":{"identifier":"allow-emit","description":"Enables the emit command without any pre-configured scope.","commands":{"allow":["emit"],"deny":[]}},"allow-emit-to":{"identifier":"allow-emit-to","description":"Enables the emit_to command without any pre-configured scope.","commands":{"allow":["emit_to"],"deny":[]}},"allow-listen":{"identifier":"allow-listen","description":"Enables the listen command without any pre-configured scope.","commands":{"allow":["listen"],"deny":[]}},"allow-unlisten":{"identifier":"allow-unlisten","description":"Enables the unlisten command without any pre-configured scope.","commands":{"allow":["unlisten"],"deny":[]}},"deny-emit":{"identifier":"deny-emit","description":"Denies the emit command without any pre-configured scope.","commands":{"allow":[],"deny":["emit"]}},"deny-emit-to":{"identifier":"deny-emit-to","description":"Denies the emit_to command without any pre-configured scope.","commands":{"allow":[],"deny":["emit_to"]}},"deny-listen":{"identifier":"deny-listen","description":"Denies the listen command without any pre-configured scope.","commands":{"allow":[],"deny":["listen"]}},"deny-unlisten":{"identifier":"deny-unlisten","description":"Denies the unlisten command without any pre-configured scope.","commands":{"allow":[],"deny":["unlisten"]}}},"permission_sets":{},"global_scope_schema":null},"core:image":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin, which enables all commands.","permissions":["allow-new","allow-from-bytes","allow-from-path","allow-rgba","allow-size"]},"permissions":{"allow-from-bytes":{"identifier":"allow-from-bytes","description":"Enables the from_bytes command without any pre-configured scope.","commands":{"allow":["from_bytes"],"deny":[]}},"allow-from-path":{"identifier":"allow-from-path","description":"Enables the from_path command without any pre-configured scope.","commands":{"allow":["from_path"],"deny":[]}},"allow-new":{"identifier":"allow-new","description":"Enables the new command without any pre-configured scope.","commands":{"allow":["new"],"deny":[]}},"allow-rgba":{"identifier":"allow-rgba","description":"Enables the rgba command without any pre-configured scope.","commands":{"allow":["rgba"],"deny":[]}},"allow-size":{"identifier":"allow-size","description":"Enables the size command without any pre-configured scope.","commands":{"allow":["size"],"deny":[]}},"deny-from-bytes":{"identifier":"deny-from-bytes","description":"Denies the from_bytes command without any pre-configured scope.","commands":{"allow":[],"deny":["from_bytes"]}},"deny-from-path":{"identifier":"deny-from-path","description":"Denies the from_path command without any pre-configured scope.","commands":{"allow":[],"deny":["from_path"]}},"deny-new":{"identifier":"deny-new","description":"Denies the new command without any pre-configured scope.","commands":{"allow":[],"deny":["new"]}},"deny-rgba":{"identifier":"deny-rgba","description":"Denies the rgba command without any pre-configured scope.","commands":{"allow":[],"deny":["rgba"]}},"deny-size":{"identifier":"deny-size","description":"Denies the size command without any pre-configured scope.","commands":{"allow":[],"deny":["size"]}}},"permission_sets":{},"global_scope_schema":null},"core:menu":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin, which enables all commands.","permissions":["allow-new","allow-append","allow-prepend","allow-insert","allow-remove","allow-remove-at","allow-items","allow-get","allow-popup","allow-create-default","allow-set-as-app-menu","allow-set-as-window-menu","allow-text","allow-set-text","allow-is-enabled","allow-set-enabled","allow-set-accelerator","allow-set-as-windows-menu-for-nsapp","allow-set-as-help-menu-for-nsapp","allow-is-checked","allow-set-checked","allow-set-icon"]},"permissions":{"allow-append":{"identifier":"allow-append","description":"Enables the append command without any pre-configured scope.","commands":{"allow":["append"],"deny":[]}},"allow-create-default":{"identifier":"allow-create-default","description":"Enables the create_default command without any pre-configured scope.","commands":{"allow":["create_default"],"deny":[]}},"allow-get":{"identifier":"allow-get","description":"Enables the get command without any pre-configured scope.","commands":{"allow":["get"],"deny":[]}},"allow-insert":{"identifier":"allow-insert","description":"Enables the insert command without any pre-configured scope.","commands":{"allow":["insert"],"deny":[]}},"allow-is-checked":{"identifier":"allow-is-checked","description":"Enables the is_checked command without any pre-configured scope.","commands":{"allow":["is_checked"],"deny":[]}},"allow-is-enabled":{"identifier":"allow-is-enabled","description":"Enables the is_enabled command without any pre-configured scope.","commands":{"allow":["is_enabled"],"deny":[]}},"allow-items":{"identifier":"allow-items","description":"Enables the items command without any pre-configured scope.","commands":{"allow":["items"],"deny":[]}},"allow-new":{"identifier":"allow-new","description":"Enables the new command without any pre-configured scope.","commands":{"allow":["new"],"deny":[]}},"allow-popup":{"identifier":"allow-popup","description":"Enables the popup command without any pre-configured scope.","commands":{"allow":["popup"],"deny":[]}},"allow-prepend":{"identifier":"allow-prepend","description":"Enables the prepend command without any pre-configured scope.","commands":{"allow":["prepend"],"deny":[]}},"allow-remove":{"identifier":"allow-remove","description":"Enables the remove command without any pre-configured scope.","commands":{"allow":["remove"],"deny":[]}},"allow-remove-at":{"identifier":"allow-remove-at","description":"Enables the remove_at command without any pre-configured scope.","commands":{"allow":["remove_at"],"deny":[]}},"allow-set-accelerator":{"identifier":"allow-set-accelerator","description":"Enables the set_accelerator command without any pre-configured scope.","commands":{"allow":["set_accelerator"],"deny":[]}},"allow-set-as-app-menu":{"identifier":"allow-set-as-app-menu","description":"Enables the set_as_app_menu command without any pre-configured scope.","commands":{"allow":["set_as_app_menu"],"deny":[]}},"allow-set-as-help-menu-for-nsapp":{"identifier":"allow-set-as-help-menu-for-nsapp","description":"Enables the set_as_help_menu_for_nsapp command without any pre-configured scope.","commands":{"allow":["set_as_help_menu_for_nsapp"],"deny":[]}},"allow-set-as-window-menu":{"identifier":"allow-set-as-window-menu","description":"Enables the set_as_window_menu command without any pre-configured scope.","commands":{"allow":["set_as_window_menu"],"deny":[]}},"allow-set-as-windows-menu-for-nsapp":{"identifier":"allow-set-as-windows-menu-for-nsapp","description":"Enables the set_as_windows_menu_for_nsapp command without any pre-configured scope.","commands":{"allow":["set_as_windows_menu_for_nsapp"],"deny":[]}},"allow-set-checked":{"identifier":"allow-set-checked","description":"Enables the set_checked command without any pre-configured scope.","commands":{"allow":["set_checked"],"deny":[]}},"allow-set-enabled":{"identifier":"allow-set-enabled","description":"Enables the set_enabled command without any pre-configured scope.","commands":{"allow":["set_enabled"],"deny":[]}},"allow-set-icon":{"identifier":"allow-set-icon","description":"Enables the set_icon command without any pre-configured scope.","commands":{"allow":["set_icon"],"deny":[]}},"allow-set-text":{"identifier":"allow-set-text","description":"Enables the set_text command without any pre-configured scope.","commands":{"allow":["set_text"],"deny":[]}},"allow-text":{"identifier":"allow-text","description":"Enables the text command without any pre-configured scope.","commands":{"allow":["text"],"deny":[]}},"deny-append":{"identifier":"deny-append","description":"Denies the append command without any pre-configured scope.","commands":{"allow":[],"deny":["append"]}},"deny-create-default":{"identifier":"deny-create-default","description":"Denies the create_default command without any pre-configured scope.","commands":{"allow":[],"deny":["create_default"]}},"deny-get":{"identifier":"deny-get","description":"Denies the get command without any pre-configured scope.","commands":{"allow":[],"deny":["get"]}},"deny-insert":{"identifier":"deny-insert","description":"Denies the insert command without any pre-configured scope.","commands":{"allow":[],"deny":["insert"]}},"deny-is-checked":{"identifier":"deny-is-checked","description":"Denies the is_checked command without any pre-configured scope.","commands":{"allow":[],"deny":["is_checked"]}},"deny-is-enabled":{"identifier":"deny-is-enabled","description":"Denies the is_enabled command without any pre-configured scope.","commands":{"allow":[],"deny":["is_enabled"]}},"deny-items":{"identifier":"deny-items","description":"Denies the items command without any pre-configured scope.","commands":{"allow":[],"deny":["items"]}},"deny-new":{"identifier":"deny-new","description":"Denies the new command without any pre-configured scope.","commands":{"allow":[],"deny":["new"]}},"deny-popup":{"identifier":"deny-popup","description":"Denies the popup command without any pre-configured scope.","commands":{"allow":[],"deny":["popup"]}},"deny-prepend":{"identifier":"deny-prepend","description":"Denies the prepend command without any pre-configured scope.","commands":{"allow":[],"deny":["prepend"]}},"deny-remove":{"identifier":"deny-remove","description":"Denies the remove command without any pre-configured scope.","commands":{"allow":[],"deny":["remove"]}},"deny-remove-at":{"identifier":"deny-remove-at","description":"Denies the remove_at command without any pre-configured scope.","commands":{"allow":[],"deny":["remove_at"]}},"deny-set-accelerator":{"identifier":"deny-set-accelerator","description":"Denies the set_accelerator command without any pre-configured scope.","commands":{"allow":[],"deny":["set_accelerator"]}},"deny-set-as-app-menu":{"identifier":"deny-set-as-app-menu","description":"Denies the set_as_app_menu command without any pre-configured scope.","commands":{"allow":[],"deny":["set_as_app_menu"]}},"deny-set-as-help-menu-for-nsapp":{"identifier":"deny-set-as-help-menu-for-nsapp","description":"Denies the set_as_help_menu_for_nsapp command without any pre-configured scope.","commands":{"allow":[],"deny":["set_as_help_menu_for_nsapp"]}},"deny-set-as-window-menu":{"identifier":"deny-set-as-window-menu","description":"Denies the set_as_window_menu command without any pre-configured scope.","commands":{"allow":[],"deny":["set_as_window_menu"]}},"deny-set-as-windows-menu-for-nsapp":{"identifier":"deny-set-as-windows-menu-for-nsapp","description":"Denies the set_as_windows_menu_for_nsapp command without any pre-configured scope.","commands":{"allow":[],"deny":["set_as_windows_menu_for_nsapp"]}},"deny-set-checked":{"identifier":"deny-set-checked","description":"Denies the set_checked command without any pre-configured scope.","commands":{"allow":[],"deny":["set_checked"]}},"deny-set-enabled":{"identifier":"deny-set-enabled","description":"Denies the set_enabled command without any pre-configured scope.","commands":{"allow":[],"deny":["set_enabled"]}},"deny-set-icon":{"identifier":"deny-set-icon","description":"Denies the set_icon command without any pre-configured scope.","commands":{"allow":[],"deny":["set_icon"]}},"deny-set-text":{"identifier":"deny-set-text","description":"Denies the set_text command without any pre-configured scope.","commands":{"allow":[],"deny":["set_text"]}},"deny-text":{"identifier":"deny-text","description":"Denies the text command without any pre-configured scope.","commands":{"allow":[],"deny":["text"]}}},"permission_sets":{},"global_scope_schema":null},"core:path":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin, which enables all commands.","permissions":["allow-resolve-directory","allow-resolve","allow-normalize","allow-join","allow-dirname","allow-extname","allow-basename","allow-is-absolute"]},"permissions":{"allow-basename":{"identifier":"allow-basename","description":"Enables the basename command without any pre-configured scope.","commands":{"allow":["basename"],"deny":[]}},"allow-dirname":{"identifier":"allow-dirname","description":"Enables the dirname command without any pre-configured scope.","commands":{"allow":["dirname"],"deny":[]}},"allow-extname":{"identifier":"allow-extname","description":"Enables the extname command without any pre-configured scope.","commands":{"allow":["extname"],"deny":[]}},"allow-is-absolute":{"identifier":"allow-is-absolute","description":"Enables the is_absolute command without any pre-configured scope.","commands":{"allow":["is_absolute"],"deny":[]}},"allow-join":{"identifier":"allow-join","description":"Enables the join command without any pre-configured scope.","commands":{"allow":["join"],"deny":[]}},"allow-normalize":{"identifier":"allow-normalize","description":"Enables the normalize command without any pre-configured scope.","commands":{"allow":["normalize"],"deny":[]}},"allow-resolve":{"identifier":"allow-resolve","description":"Enables the resolve command without any pre-configured scope.","commands":{"allow":["resolve"],"deny":[]}},"allow-resolve-directory":{"identifier":"allow-resolve-directory","description":"Enables the resolve_directory command without any pre-configured scope.","commands":{"allow":["resolve_directory"],"deny":[]}},"deny-basename":{"identifier":"deny-basename","description":"Denies the basename command without any pre-configured scope.","commands":{"allow":[],"deny":["basename"]}},"deny-dirname":{"identifier":"deny-dirname","description":"Denies the dirname command without any pre-configured scope.","commands":{"allow":[],"deny":["dirname"]}},"deny-extname":{"identifier":"deny-extname","description":"Denies the extname command without any pre-configured scope.","commands":{"allow":[],"deny":["extname"]}},"deny-is-absolute":{"identifier":"deny-is-absolute","description":"Denies the is_absolute command without any pre-configured scope.","commands":{"allow":[],"deny":["is_absolute"]}},"deny-join":{"identifier":"deny-join","description":"Denies the join command without any pre-configured scope.","commands":{"allow":[],"deny":["join"]}},"deny-normalize":{"identifier":"deny-normalize","description":"Denies the normalize command without any pre-configured scope.","commands":{"allow":[],"deny":["normalize"]}},"deny-resolve":{"identifier":"deny-resolve","description":"Denies the resolve command without any pre-configured scope.","commands":{"allow":[],"deny":["resolve"]}},"deny-resolve-directory":{"identifier":"deny-resolve-directory","description":"Denies the resolve_directory command without any pre-configured scope.","commands":{"allow":[],"deny":["resolve_directory"]}}},"permission_sets":{},"global_scope_schema":null},"core:resources":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin, which enables all commands.","permissions":["allow-close"]},"permissions":{"allow-close":{"identifier":"allow-close","description":"Enables the close command without any pre-configured scope.","commands":{"allow":["close"],"deny":[]}},"deny-close":{"identifier":"deny-close","description":"Denies the close command without any pre-configured scope.","commands":{"allow":[],"deny":["close"]}}},"permission_sets":{},"global_scope_schema":null},"core:tray":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin, which enables all commands.","permissions":["allow-new","allow-get-by-id","allow-remove-by-id","allow-set-icon","allow-set-menu","allow-set-tooltip","allow-set-title","allow-set-visible","allow-set-temp-dir-path","allow-set-icon-as-template","allow-set-show-menu-on-left-click"]},"permissions":{"allow-get-by-id":{"identifier":"allow-get-by-id","description":"Enables the get_by_id command without any pre-configured scope.","commands":{"allow":["get_by_id"],"deny":[]}},"allow-new":{"identifier":"allow-new","description":"Enables the new command without any pre-configured scope.","commands":{"allow":["new"],"deny":[]}},"allow-remove-by-id":{"identifier":"allow-remove-by-id","description":"Enables the remove_by_id command without any pre-configured scope.","commands":{"allow":["remove_by_id"],"deny":[]}},"allow-set-icon":{"identifier":"allow-set-icon","description":"Enables the set_icon command without any pre-configured scope.","commands":{"allow":["set_icon"],"deny":[]}},"allow-set-icon-as-template":{"identifier":"allow-set-icon-as-template","description":"Enables the set_icon_as_template command without any pre-configured scope.","commands":{"allow":["set_icon_as_template"],"deny":[]}},"allow-set-menu":{"identifier":"allow-set-menu","description":"Enables the set_menu command without any pre-configured scope.","commands":{"allow":["set_menu"],"deny":[]}},"allow-set-show-menu-on-left-click":{"identifier":"allow-set-show-menu-on-left-click","description":"Enables the set_show_menu_on_left_click command without any pre-configured scope.","commands":{"allow":["set_show_menu_on_left_click"],"deny":[]}},"allow-set-temp-dir-path":{"identifier":"allow-set-temp-dir-path","description":"Enables the set_temp_dir_path command without any pre-configured scope.","commands":{"allow":["set_temp_dir_path"],"deny":[]}},"allow-set-title":{"identifier":"allow-set-title","description":"Enables the set_title command without any pre-configured scope.","commands":{"allow":["set_title"],"deny":[]}},"allow-set-tooltip":{"identifier":"allow-set-tooltip","description":"Enables the set_tooltip command without any pre-configured scope.","commands":{"allow":["set_tooltip"],"deny":[]}},"allow-set-visible":{"identifier":"allow-set-visible","description":"Enables the set_visible command without any pre-configured scope.","commands":{"allow":["set_visible"],"deny":[]}},"deny-get-by-id":{"identifier":"deny-get-by-id","description":"Denies the get_by_id command without any pre-configured scope.","commands":{"allow":[],"deny":["get_by_id"]}},"deny-new":{"identifier":"deny-new","description":"Denies the new command without any pre-configured scope.","commands":{"allow":[],"deny":["new"]}},"deny-remove-by-id":{"identifier":"deny-remove-by-id","description":"Denies the remove_by_id command without any pre-configured scope.","commands":{"allow":[],"deny":["remove_by_id"]}},"deny-set-icon":{"identifier":"deny-set-icon","description":"Denies the set_icon command without any pre-configured scope.","commands":{"allow":[],"deny":["set_icon"]}},"deny-set-icon-as-template":{"identifier":"deny-set-icon-as-template","description":"Denies the set_icon_as_template command without any pre-configured scope.","commands":{"allow":[],"deny":["set_icon_as_template"]}},"deny-set-menu":{"identifier":"deny-set-menu","description":"Denies the set_menu command without any pre-configured scope.","commands":{"allow":[],"deny":["set_menu"]}},"deny-set-show-menu-on-left-click":{"identifier":"deny-set-show-menu-on-left-click","description":"Denies the set_show_menu_on_left_click command without any pre-configured scope.","commands":{"allow":[],"deny":["set_show_menu_on_left_click"]}},"deny-set-temp-dir-path":{"identifier":"deny-set-temp-dir-path","description":"Denies the set_temp_dir_path command without any pre-configured scope.","commands":{"allow":[],"deny":["set_temp_dir_path"]}},"deny-set-title":{"identifier":"deny-set-title","description":"Denies the set_title command without any pre-configured scope.","commands":{"allow":[],"deny":["set_title"]}},"deny-set-tooltip":{"identifier":"deny-set-tooltip","description":"Denies the set_tooltip command without any pre-configured scope.","commands":{"allow":[],"deny":["set_tooltip"]}},"deny-set-visible":{"identifier":"deny-set-visible","description":"Denies the set_visible command without any pre-configured scope.","commands":{"allow":[],"deny":["set_visible"]}}},"permission_sets":{},"global_scope_schema":null},"core:webview":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin.","permissions":["allow-get-all-webviews","allow-webview-position","allow-webview-size","allow-internal-toggle-devtools"]},"permissions":{"allow-clear-all-browsing-data":{"identifier":"allow-clear-all-browsing-data","description":"Enables the clear_all_browsing_data command without any pre-configured scope.","commands":{"allow":["clear_all_browsing_data"],"deny":[]}},"allow-create-webview":{"identifier":"allow-create-webview","description":"Enables the create_webview command without any pre-configured scope.","commands":{"allow":["create_webview"],"deny":[]}},"allow-create-webview-window":{"identifier":"allow-create-webview-window","description":"Enables the create_webview_window command without any pre-configured scope.","commands":{"allow":["create_webview_window"],"deny":[]}},"allow-get-all-webviews":{"identifier":"allow-get-all-webviews","description":"Enables the get_all_webviews command without any pre-configured scope.","commands":{"allow":["get_all_webviews"],"deny":[]}},"allow-internal-toggle-devtools":{"identifier":"allow-internal-toggle-devtools","description":"Enables the internal_toggle_devtools command without any pre-configured scope.","commands":{"allow":["internal_toggle_devtools"],"deny":[]}},"allow-print":{"identifier":"allow-print","description":"Enables the print command without any pre-configured scope.","commands":{"allow":["print"],"deny":[]}},"allow-reparent":{"identifier":"allow-reparent","description":"Enables the reparent command without any pre-configured scope.","commands":{"allow":["reparent"],"deny":[]}},"allow-set-webview-auto-resize":{"identifier":"allow-set-webview-auto-resize","description":"Enables the set_webview_auto_resize command without any pre-configured scope.","commands":{"allow":["set_webview_auto_resize"],"deny":[]}},"allow-set-webview-background-color":{"identifier":"allow-set-webview-background-color","description":"Enables the set_webview_background_color command without any pre-configured scope.","commands":{"allow":["set_webview_background_color"],"deny":[]}},"allow-set-webview-focus":{"identifier":"allow-set-webview-focus","description":"Enables the set_webview_focus command without any pre-configured scope.","commands":{"allow":["set_webview_focus"],"deny":[]}},"allow-set-webview-position":{"identifier":"allow-set-webview-position","description":"Enables the set_webview_position command without any pre-configured scope.","commands":{"allow":["set_webview_position"],"deny":[]}},"allow-set-webview-size":{"identifier":"allow-set-webview-size","description":"Enables the set_webview_size command without any pre-configured scope.","commands":{"allow":["set_webview_size"],"deny":[]}},"allow-set-webview-zoom":{"identifier":"allow-set-webview-zoom","description":"Enables the set_webview_zoom command without any pre-configured scope.","commands":{"allow":["set_webview_zoom"],"deny":[]}},"allow-webview-close":{"identifier":"allow-webview-close","description":"Enables the webview_close command without any pre-configured scope.","commands":{"allow":["webview_close"],"deny":[]}},"allow-webview-hide":{"identifier":"allow-webview-hide","description":"Enables the webview_hide command without any pre-configured scope.","commands":{"allow":["webview_hide"],"deny":[]}},"allow-webview-position":{"identifier":"allow-webview-position","description":"Enables the webview_position command without any pre-configured scope.","commands":{"allow":["webview_position"],"deny":[]}},"allow-webview-show":{"identifier":"allow-webview-show","description":"Enables the webview_show command without any pre-configured scope.","commands":{"allow":["webview_show"],"deny":[]}},"allow-webview-size":{"identifier":"allow-webview-size","description":"Enables the webview_size command without any pre-configured scope.","commands":{"allow":["webview_size"],"deny":[]}},"deny-clear-all-browsing-data":{"identifier":"deny-clear-all-browsing-data","description":"Denies the clear_all_browsing_data command without any pre-configured scope.","commands":{"allow":[],"deny":["clear_all_browsing_data"]}},"deny-create-webview":{"identifier":"deny-create-webview","description":"Denies the create_webview command without any pre-configured scope.","commands":{"allow":[],"deny":["create_webview"]}},"deny-create-webview-window":{"identifier":"deny-create-webview-window","description":"Denies the create_webview_window command without any pre-configured scope.","commands":{"allow":[],"deny":["create_webview_window"]}},"deny-get-all-webviews":{"identifier":"deny-get-all-webviews","description":"Denies the get_all_webviews command without any pre-configured scope.","commands":{"allow":[],"deny":["get_all_webviews"]}},"deny-internal-toggle-devtools":{"identifier":"deny-internal-toggle-devtools","description":"Denies the internal_toggle_devtools command without any pre-configured scope.","commands":{"allow":[],"deny":["internal_toggle_devtools"]}},"deny-print":{"identifier":"deny-print","description":"Denies the print command without any pre-configured scope.","commands":{"allow":[],"deny":["print"]}},"deny-reparent":{"identifier":"deny-reparent","description":"Denies the reparent command without any pre-configured scope.","commands":{"allow":[],"deny":["reparent"]}},"deny-set-webview-auto-resize":{"identifier":"deny-set-webview-auto-resize","description":"Denies the set_webview_auto_resize command without any pre-configured scope.","commands":{"allow":[],"deny":["set_webview_auto_resize"]}},"deny-set-webview-background-color":{"identifier":"deny-set-webview-background-color","description":"Denies the set_webview_background_color command without any pre-configured scope.","commands":{"allow":[],"deny":["set_webview_background_color"]}},"deny-set-webview-focus":{"identifier":"deny-set-webview-focus","description":"Denies the set_webview_focus command without any pre-configured scope.","commands":{"allow":[],"deny":["set_webview_focus"]}},"deny-set-webview-position":{"identifier":"deny-set-webview-position","description":"Denies the set_webview_position command without any pre-configured scope.","commands":{"allow":[],"deny":["set_webview_position"]}},"deny-set-webview-size":{"identifier":"deny-set-webview-size","description":"Denies the set_webview_size command without any pre-configured scope.","commands":{"allow":[],"deny":["set_webview_size"]}},"deny-set-webview-zoom":{"identifier":"deny-set-webview-zoom","description":"Denies the set_webview_zoom command without any pre-configured scope.","commands":{"allow":[],"deny":["set_webview_zoom"]}},"deny-webview-close":{"identifier":"deny-webview-close","description":"Denies the webview_close command without any pre-configured scope.","commands":{"allow":[],"deny":["webview_close"]}},"deny-webview-hide":{"identifier":"deny-webview-hide","description":"Denies the webview_hide command without any pre-configured scope.","commands":{"allow":[],"deny":["webview_hide"]}},"deny-webview-position":{"identifier":"deny-webview-position","description":"Denies the webview_position command without any pre-configured scope.","commands":{"allow":[],"deny":["webview_position"]}},"deny-webview-show":{"identifier":"deny-webview-show","description":"Denies the webview_show command without any pre-configured scope.","commands":{"allow":[],"deny":["webview_show"]}},"deny-webview-size":{"identifier":"deny-webview-size","description":"Denies the webview_size command without any pre-configured scope.","commands":{"allow":[],"deny":["webview_size"]}}},"permission_sets":{},"global_scope_schema":null},"core:window":{"default_permission":{"identifier":"default","description":"Default permissions for the plugin.","permissions":["allow-get-all-windows","allow-scale-factor","allow-inner-position","allow-outer-position","allow-inner-size","allow-outer-size","allow-is-fullscreen","allow-is-minimized","allow-is-maximized","allow-is-focused","allow-is-decorated","allow-is-resizable","allow-is-maximizable","allow-is-minimizable","allow-is-closable","allow-is-visible","allow-is-enabled","allow-title","allow-current-monitor","allow-primary-monitor","allow-monitor-from-point","allow-available-monitors","allow-cursor-position","allow-theme","allow-is-always-on-top","allow-internal-toggle-maximize"]},"permissions":{"allow-available-monitors":{"identifier":"allow-available-monitors","description":"Enables the available_monitors command without any pre-configured scope.","commands":{"allow":["available_monitors"],"deny":[]}},"allow-center":{"identifier":"allow-center","description":"Enables the center command without any pre-configured scope.","commands":{"allow":["center"],"deny":[]}},"allow-close":{"identifier":"allow-close","description":"Enables the close command without any pre-configured scope.","commands":{"allow":["close"],"deny":[]}},"allow-create":{"identifier":"allow-create","description":"Enables the create command without any pre-configured scope.","commands":{"allow":["create"],"deny":[]}},"allow-current-monitor":{"identifier":"allow-current-monitor","description":"Enables the current_monitor command without any pre-configured scope.","commands":{"allow":["current_monitor"],"deny":[]}},"allow-cursor-position":{"identifier":"allow-cursor-position","description":"Enables the cursor_position command without any pre-configured scope.","commands":{"allow":["cursor_position"],"deny":[]}},"allow-destroy":{"identifier":"allow-destroy","description":"Enables the destroy command without any pre-configured scope.","commands":{"allow":["destroy"],"deny":[]}},"allow-get-all-windows":{"identifier":"allow-get-all-windows","description":"Enables the get_all_windows command without any pre-configured scope.","commands":{"allow":["get_all_windows"],"deny":[]}},"allow-hide":{"identifier":"allow-hide","description":"Enables the hide command without any pre-configured scope.","commands":{"allow":["hide"],"deny":[]}},"allow-inner-position":{"identifier":"allow-inner-position","description":"Enables the inner_position command without any pre-configured scope.","commands":{"allow":["inner_position"],"deny":[]}},"allow-inner-size":{"identifier":"allow-inner-size","description":"Enables the inner_size command without any pre-configured scope.","commands":{"allow":["inner_size"],"deny":[]}},"allow-internal-toggle-maximize":{"identifier":"allow-internal-toggle-maximize","description":"Enables the internal_toggle_maximize command without any pre-configured scope.","commands":{"allow":["internal_toggle_maximize"],"deny":[]}},"allow-is-always-on-top":{"identifier":"allow-is-always-on-top","description":"Enables the is_always_on_top command without any pre-configured scope.","commands":{"allow":["is_always_on_top"],"deny":[]}},"allow-is-closable":{"identifier":"allow-is-closable","description":"Enables the is_closable command without any pre-configured scope.","commands":{"allow":["is_closable"],"deny":[]}},"allow-is-decorated":{"identifier":"allow-is-decorated","description":"Enables the is_decorated command without any pre-configured scope.","commands":{"allow":["is_decorated"],"deny":[]}},"allow-is-enabled":{"identifier":"allow-is-enabled","description":"Enables the is_enabled command without any pre-configured scope.","commands":{"allow":["is_enabled"],"deny":[]}},"allow-is-focused":{"identifier":"allow-is-focused","description":"Enables the is_focused command without any pre-configured scope.","commands":{"allow":["is_focused"],"deny":[]}},"allow-is-fullscreen":{"identifier":"allow-is-fullscreen","description":"Enables the is_fullscreen command without any pre-configured scope.","commands":{"allow":["is_fullscreen"],"deny":[]}},"allow-is-maximizable":{"identifier":"allow-is-maximizable","description":"Enables the is_maximizable command without any pre-configured scope.","commands":{"allow":["is_maximizable"],"deny":[]}},"allow-is-maximized":{"identifier":"allow-is-maximized","description":"Enables the is_maximized command without any pre-configured scope.","commands":{"allow":["is_maximized"],"deny":[]}},"allow-is-minimizable":{"identifier":"allow-is-minimizable","description":"Enables the is_minimizable command without any pre-configured scope.","commands":{"allow":["is_minimizable"],"deny":[]}},"allow-is-minimized":{"identifier":"allow-is-minimized","description":"Enables the is_minimized command without any pre-configured scope.","commands":{"allow":["is_minimized"],"deny":[]}},"allow-is-resizable":{"identifier":"allow-is-resizable","description":"Enables the is_resizable command without any pre-configured scope.","commands":{"allow":["is_resizable"],"deny":[]}},"allow-is-visible":{"identifier":"allow-is-visible","description":"Enables the is_visible command without any pre-configured scope.","commands":{"allow":["is_visible"],"deny":[]}},"allow-maximize":{"identifier":"allow-maximize","description":"Enables the maximize command without any pre-configured scope.","commands":{"allow":["maximize"],"deny":[]}},"allow-minimize":{"identifier":"allow-minimize","description":"Enables the minimize command without any pre-configured scope.","commands":{"allow":["minimize"],"deny":[]}},"allow-monitor-from-point":{"identifier":"allow-monitor-from-point","description":"Enables the monitor_from_point command without any pre-configured scope.","commands":{"allow":["monitor_from_point"],"deny":[]}},"allow-outer-position":{"identifier":"allow-outer-position","description":"Enables the outer_position command without any pre-configured scope.","commands":{"allow":["outer_position"],"deny":[]}},"allow-outer-size":{"identifier":"allow-outer-size","description":"Enables the outer_size command without any pre-configured scope.","commands":{"allow":["outer_size"],"deny":[]}},"allow-primary-monitor":{"identifier":"allow-primary-monitor","description":"Enables the primary_monitor command without any pre-configured scope.","commands":{"allow":["primary_monitor"],"deny":[]}},"allow-request-user-attention":{"identifier":"allow-request-user-attention","description":"Enables the request_user_attention command without any pre-configured scope.","commands":{"allow":["request_user_attention"],"deny":[]}},"allow-scale-factor":{"identifier":"allow-scale-factor","description":"Enables the scale_factor command without any pre-configured scope.","commands":{"allow":["scale_factor"],"deny":[]}},"allow-set-always-on-bottom":{"identifier":"allow-set-always-on-bottom","description":"Enables the set_always_on_bottom command without any pre-configured scope.","commands":{"allow":["set_always_on_bottom"],"deny":[]}},"allow-set-always-on-top":{"identifier":"allow-set-always-on-top","description":"Enables the set_always_on_top command without any pre-configured scope.","commands":{"allow":["set_always_on_top"],"deny":[]}},"allow-set-background-color":{"identifier":"allow-set-background-color","description":"Enables the set_background_color command without any pre-configured scope.","commands":{"allow":["set_background_color"],"deny":[]}},"allow-set-badge-count":{"identifier":"allow-set-badge-count","description":"Enables the set_badge_count command without any pre-configured scope.","commands":{"allow":["set_badge_count"],"deny":[]}},"allow-set-badge-label":{"identifier":"allow-set-badge-label","description":"Enables the set_badge_label command without any pre-configured scope.","commands":{"allow":["set_badge_label"],"deny":[]}},"allow-set-closable":{"identifier":"allow-set-closable","description":"Enables the set_closable command without any pre-configured scope.","commands":{"allow":["set_closable"],"deny":[]}},"allow-set-content-protected":{"identifier":"allow-set-content-protected","description":"Enables the set_content_protected command without any pre-configured scope.","commands":{"allow":["set_content_protected"],"deny":[]}},"allow-set-cursor-grab":{"identifier":"allow-set-cursor-grab","description":"Enables the set_cursor_grab command without any pre-configured scope.","commands":{"allow":["set_cursor_grab"],"deny":[]}},"allow-set-cursor-icon":{"identifier":"allow-set-cursor-icon","description":"Enables the set_cursor_icon command without any pre-configured scope.","commands":{"allow":["set_cursor_icon"],"deny":[]}},"allow-set-cursor-position":{"identifier":"allow-set-cursor-position","description":"Enables the set_cursor_position command without any pre-configured scope.","commands":{"allow":["set_cursor_position"],"deny":[]}},"allow-set-cursor-visible":{"identifier":"allow-set-cursor-visible","description":"Enables the set_cursor_visible command without any pre-configured scope.","commands":{"allow":["set_cursor_visible"],"deny":[]}},"allow-set-decorations":{"identifier":"allow-set-decorations","description":"Enables the set_decorations command without any pre-configured scope.","commands":{"allow":["set_decorations"],"deny":[]}},"allow-set-effects":{"identifier":"allow-set-effects","description":"Enables the set_effects command without any pre-configured scope.","commands":{"allow":["set_effects"],"deny":[]}},"allow-set-enabled":{"identifier":"allow-set-enabled","description":"Enables the set_enabled command without any pre-configured scope.","commands":{"allow":["set_enabled"],"deny":[]}},"allow-set-focus":{"identifier":"allow-set-focus","description":"Enables the set_focus command without any pre-configured scope.","commands":{"allow":["set_focus"],"deny":[]}},"allow-set-focusable":{"identifier":"allow-set-focusable","description":"Enables the set_focusable command without any pre-configured scope.","commands":{"allow":["set_focusable"],"deny":[]}},"allow-set-fullscreen":{"identifier":"allow-set-fullscreen","description":"Enables the set_fullscreen command without any pre-configured scope.","commands":{"allow":["set_fullscreen"],"deny":[]}},"allow-set-icon":{"identifier":"allow-set-icon","description":"Enables the set_icon command without any pre-configured scope.","commands":{"allow":["set_icon"],"deny":[]}},"allow-set-ignore-cursor-events":{"identifier":"allow-set-ignore-cursor-events","description":"Enables the set_ignore_cursor_events command without any pre-configured scope.","commands":{"allow":["set_ignore_cursor_events"],"deny":[]}},"allow-set-max-size":{"identifier":"allow-set-max-size","description":"Enables the set_max_size command without any pre-configured scope.","commands":{"allow":["set_max_size"],"deny":[]}},"allow-set-maximizable":{"identifier":"allow-set-maximizable","description":"Enables the set_maximizable command without any pre-configured scope.","commands":{"allow":["set_maximizable"],"deny":[]}},"allow-set-min-size":{"identifier":"allow-set-min-size","description":"Enables the set_min_size command without any pre-configured scope.","commands":{"allow":["set_min_size"],"deny":[]}},"allow-set-minimizable":{"identifier":"allow-set-minimizable","description":"Enables the set_minimizable command without any pre-configured scope.","commands":{"allow":["set_minimizable"],"deny":[]}},"allow-set-overlay-icon":{"identifier":"allow-set-overlay-icon","description":"Enables the set_overlay_icon command without any pre-configured scope.","commands":{"allow":["set_overlay_icon"],"deny":[]}},"allow-set-position":{"identifier":"allow-set-position","description":"Enables the set_position command without any pre-configured scope.","commands":{"allow":["set_position"],"deny":[]}},"allow-set-progress-bar":{"identifier":"allow-set-progress-bar","description":"Enables the set_progress_bar command without any pre-configured scope.","commands":{"allow":["set_progress_bar"],"deny":[]}},"allow-set-resizable":{"identifier":"allow-set-resizable","description":"Enables the set_resizable command without any pre-configured scope.","commands":{"allow":["set_resizable"],"deny":[]}},"allow-set-shadow":{"identifier":"allow-set-shadow","description":"Enables the set_shadow command without any pre-configured scope.","commands":{"allow":["set_shadow"],"deny":[]}},"allow-set-simple-fullscreen":{"identifier":"allow-set-simple-fullscreen","description":"Enables the set_simple_fullscreen command without any pre-configured scope.","commands":{"allow":["set_simple_fullscreen"],"deny":[]}},"allow-set-size":{"identifier":"allow-set-size","description":"Enables the set_size command without any pre-configured scope.","commands":{"allow":["set_size"],"deny":[]}},"allow-set-size-constraints":{"identifier":"allow-set-size-constraints","description":"Enables the set_size_constraints command without any pre-configured scope.","commands":{"allow":["set_size_constraints"],"deny":[]}},"allow-set-skip-taskbar":{"identifier":"allow-set-skip-taskbar","description":"Enables the set_skip_taskbar command without any pre-configured scope.","commands":{"allow":["set_skip_taskbar"],"deny":[]}},"allow-set-theme":{"identifier":"allow-set-theme","description":"Enables the set_theme command without any pre-configured scope.","commands":{"allow":["set_theme"],"deny":[]}},"allow-set-title":{"identifier":"allow-set-title","description":"Enables the set_title command without any pre-configured scope.","commands":{"allow":["set_title"],"deny":[]}},"allow-set-title-bar-style":{"identifier":"allow-set-title-bar-style","description":"Enables the set_title_bar_style command without any pre-configured scope.","commands":{"allow":["set_title_bar_style"],"deny":[]}},"allow-set-visible-on-all-workspaces":{"identifier":"allow-set-visible-on-all-workspaces","description":"Enables the set_visible_on_all_workspaces command without any pre-configured scope.","commands":{"allow":["set_visible_on_all_workspaces"],"deny":[]}},"allow-show":{"identifier":"allow-show","description":"Enables the show command without any pre-configured scope.","commands":{"allow":["show"],"deny":[]}},"allow-start-dragging":{"identifier":"allow-start-dragging","description":"Enables the start_dragging command without any pre-configured scope.","commands":{"allow":["start_dragging"],"deny":[]}},"allow-start-resize-dragging":{"identifier":"allow-start-resize-dragging","description":"Enables the start_resize_dragging command without any pre-configured scope.","commands":{"allow":["start_resize_dragging"],"deny":[]}},"allow-theme":{"identifier":"allow-theme","description":"Enables the theme command without any pre-configured scope.","commands":{"allow":["theme"],"deny":[]}},"allow-title":{"identifier":"allow-title","description":"Enables the title command without any pre-configured scope.","commands":{"allow":["title"],"deny":[]}},"allow-toggle-maximize":{"identifier":"allow-toggle-maximize","description":"Enables the toggle_maximize command without any pre-configured scope.","commands":{"allow":["toggle_maximize"],"deny":[]}},"allow-unmaximize":{"identifier":"allow-unmaximize","description":"Enables the unmaximize command without any pre-configured scope.","commands":{"allow":["unmaximize"],"deny":[]}},"allow-unminimize":{"identifier":"allow-unminimize","description":"Enables the unminimize command without any pre-configured scope.","commands":{"allow":["unminimize"],"deny":[]}},"deny-available-monitors":{"identifier":"deny-available-monitors","description":"Denies the available_monitors command without any pre-configured scope.","commands":{"allow":[],"deny":["available_monitors"]}},"deny-center":{"identifier":"deny-center","description":"Denies the center command without any pre-configured scope.","commands":{"allow":[],"deny":["center"]}},"deny-close":{"identifier":"deny-close","description":"Denies the close command without any pre-configured scope.","commands":{"allow":[],"deny":["close"]}},"deny-create":{"identifier":"deny-create","description":"Denies the create command without any pre-configured scope.","commands":{"allow":[],"deny":["create"]}},"deny-current-monitor":{"identifier":"deny-current-monitor","description":"Denies the current_monitor command without any pre-configured scope.","commands":{"allow":[],"deny":["current_monitor"]}},"deny-cursor-position":{"identifier":"deny-cursor-position","description":"Denies the cursor_position command without any pre-configured scope.","commands":{"allow":[],"deny":["cursor_position"]}},"deny-destroy":{"identifier":"deny-destroy","description":"Denies the destroy command without any pre-configured scope.","commands":{"allow":[],"deny":["destroy"]}},"deny-get-all-windows":{"identifier":"deny-get-all-windows","description":"Denies the get_all_windows command without any pre-configured scope.","commands":{"allow":[],"deny":["get_all_windows"]}},"deny-hide":{"identifier":"deny-hide","description":"Denies the hide command without any pre-configured scope.","commands":{"allow":[],"deny":["hide"]}},"deny-inner-position":{"identifier":"deny-inner-position","description":"Denies the inner_position command without any pre-configured scope.","commands":{"allow":[],"deny":["inner_position"]}},"deny-inner-size":{"identifier":"deny-inner-size","description":"Denies the inner_size command without any pre-configured scope.","commands":{"allow":[],"deny":["inner_size"]}},"deny-internal-toggle-maximize":{"identifier":"deny-internal-toggle-maximize","description":"Denies the internal_toggle_maximize command without any pre-configured scope.","commands":{"allow":[],"deny":["internal_toggle_maximize"]}},"deny-is-always-on-top":{"identifier":"deny-is-always-on-top","description":"Denies the is_always_on_top command without any pre-configured scope.","commands":{"allow":[],"deny":["is_always_on_top"]}},"deny-is-closable":{"identifier":"deny-is-closable","description":"Denies the is_closable command without any pre-configured scope.","commands":{"allow":[],"deny":["is_closable"]}},"deny-is-decorated":{"identifier":"deny-is-decorated","description":"Denies the is_decorated command without any pre-configured scope.","commands":{"allow":[],"deny":["is_decorated"]}},"deny-is-enabled":{"identifier":"deny-is-enabled","description":"Denies the is_enabled command without any pre-configured scope.","commands":{"allow":[],"deny":["is_enabled"]}},"deny-is-focused":{"identifier":"deny-is-focused","description":"Denies the is_focused command without any pre-configured scope.","commands":{"allow":[],"deny":["is_focused"]}},"deny-is-fullscreen":{"identifier":"deny-is-fullscreen","description":"Denies the is_fullscreen command without any pre-configured scope.","commands":{"allow":[],"deny":["is_fullscreen"]}},"deny-is-maximizable":{"identifier":"deny-is-maximizable","description":"Denies the is_maximizable command without any pre-configured scope.","commands":{"allow":[],"deny":["is_maximizable"]}},"deny-is-maximized":{"identifier":"deny-is-maximized","description":"Denies the is_maximized command without any pre-configured scope.","commands":{"allow":[],"deny":["is_maximized"]}},"deny-is-minimizable":{"identifier":"deny-is-minimizable","description":"Denies the is_minimizable command without any pre-configured scope.","commands":{"allow":[],"deny":["is_minimizable"]}},"deny-is-minimized":{"identifier":"deny-is-minimized","description":"Denies the is_minimized command without any pre-configured scope.","commands":{"allow":[],"deny":["is_minimized"]}},"deny-is-resizable":{"identifier":"deny-is-resizable","description":"Denies the is_resizable command without any pre-configured scope.","commands":{"allow":[],"deny":["is_resizable"]}},"deny-is-visible":{"identifier":"deny-is-visible","description":"Denies the is_visible command without any pre-configured scope.","commands":{"allow":[],"deny":["is_visible"]}},"deny-maximize":{"identifier":"deny-maximize","description":"Denies the maximize command without any pre-configured scope.","commands":{"allow":[],"deny":["maximize"]}},"deny-minimize":{"identifier":"deny-minimize","description":"Denies the minimize command without any pre-configured scope.","commands":{"allow":[],"deny":["minimize"]}},"deny-monitor-from-point":{"identifier":"deny-monitor-from-point","description":"Denies the monitor_from_point command without any pre-configured scope.","commands":{"allow":[],"deny":["monitor_from_point"]}},"deny-outer-position":{"identifier":"deny-outer-position","description":"Denies the outer_position command without any pre-configured scope.","commands":{"allow":[],"deny":["outer_position"]}},"deny-outer-size":{"identifier":"deny-outer-size","description":"Denies the outer_size command without any pre-configured scope.","commands":{"allow":[],"deny":["outer_size"]}},"deny-primary-monitor":{"identifier":"deny-primary-monitor","description":"Denies the primary_monitor command without any pre-configured scope.","commands":{"allow":[],"deny":["primary_monitor"]}},"deny-request-user-attention":{"identifier":"deny-request-user-attention","description":"Denies the request_user_attention command without any pre-configured scope.","commands":{"allow":[],"deny":["request_user_attention"]}},"deny-scale-factor":{"identifier":"deny-scale-factor","description":"Denies the scale_factor command without any pre-configured scope.","commands":{"allow":[],"deny":["scale_factor"]}},"deny-set-always-on-bottom":{"identifier":"deny-set-always-on-bottom","description":"Denies the set_always_on_bottom command without any pre-configured scope.","commands":{"allow":[],"deny":["set_always_on_bottom"]}},"deny-set-always-on-top":{"identifier":"deny-set-always-on-top","description":"Denies the set_always_on_top command without any pre-configured scope.","commands":{"allow":[],"deny":["set_always_on_top"]}},"deny-set-background-color":{"identifier":"deny-set-background-color","description":"Denies the set_background_color command without any pre-configured scope.","commands":{"allow":[],"deny":["set_background_color"]}},"deny-set-badge-count":{"identifier":"deny-set-badge-count","description":"Denies the set_badge_count command without any pre-configured scope.","commands":{"allow":[],"deny":["set_badge_count"]}},"deny-set-badge-label":{"identifier":"deny-set-badge-label","description":"Denies the set_badge_label command without any pre-configured scope.","commands":{"allow":[],"deny":["set_badge_label"]}},"deny-set-closable":{"identifier":"deny-set-closable","description":"Denies the set_closable command without any pre-configured scope.","commands":{"allow":[],"deny":["set_closable"]}},"deny-set-content-protected":{"identifier":"deny-set-content-protected","description":"Denies the set_content_protected command without any pre-configured scope.","commands":{"allow":[],"deny":["set_content_protected"]}},"deny-set-cursor-grab":{"identifier":"deny-set-cursor-grab","description":"Denies the set_cursor_grab command without any pre-configured scope.","commands":{"allow":[],"deny":["set_cursor_grab"]}},"deny-set-cursor-icon":{"identifier":"deny-set-cursor-icon","description":"Denies the set_cursor_icon command without any pre-configured scope.","commands":{"allow":[],"deny":["set_cursor_icon"]}},"deny-set-cursor-position":{"identifier":"deny-set-cursor-position","description":"Denies the set_cursor_position command without any pre-configured scope.","commands":{"allow":[],"deny":["set_cursor_position"]}},"deny-set-cursor-visible":{"identifier":"deny-set-cursor-visible","description":"Denies the set_cursor_visible command without any pre-configured scope.","commands":{"allow":[],"deny":["set_cursor_visible"]}},"deny-set-decorations":{"identifier":"deny-set-decorations","description":"Denies the set_decorations command without any pre-configured scope.","commands":{"allow":[],"deny":["set_decorations"]}},"deny-set-effects":{"identifier":"deny-set-effects","description":"Denies the set_effects command without any pre-configured scope.","commands":{"allow":[],"deny":["set_effects"]}},"deny-set-enabled":{"identifier":"deny-set-enabled","description":"Denies the set_enabled command without any pre-configured scope.","commands":{"allow":[],"deny":["set_enabled"]}},"deny-set-focus":{"identifier":"deny-set-focus","description":"Denies the set_focus command without any pre-configured scope.","commands":{"allow":[],"deny":["set_focus"]}},"deny-set-focusable":{"identifier":"deny-set-focusable","description":"Denies the set_focusable command without any pre-configured scope.","commands":{"allow":[],"deny":["set_focusable"]}},"deny-set-fullscreen":{"identifier":"deny-set-fullscreen","description":"Denies the set_fullscreen command without any pre-configured scope.","commands":{"allow":[],"deny":["set_fullscreen"]}},"deny-set-icon":{"identifier":"deny-set-icon","description":"Denies the set_icon command without any pre-configured scope.","commands":{"allow":[],"deny":["set_icon"]}},"deny-set-ignore-cursor-events":{"identifier":"deny-set-ignore-cursor-events","description":"Denies the set_ignore_cursor_events command without any pre-configured scope.","commands":{"allow":[],"deny":["set_ignore_cursor_events"]}},"deny-set-max-size":{"identifier":"deny-set-max-size","description":"Denies the set_max_size command without any pre-configured scope.","commands":{"allow":[],"deny":["set_max_size"]}},"deny-set-maximizable":{"identifier":"deny-set-maximizable","description":"Denies the set_maximizable command without any pre-configured scope.","commands":{"allow":[],"deny":["set_maximizable"]}},"deny-set-min-size":{"identifier":"deny-set-min-size","description":"Denies the set_min_size command without any pre-configured scope.","commands":{"allow":[],"deny":["set_min_size"]}},"deny-set-minimizable":{"identifier":"deny-set-minimizable","description":"Denies the set_minimizable command without any pre-configured scope.","commands":{"allow":[],"deny":["set_minimizable"]}},"deny-set-overlay-icon":{"identifier":"deny-set-overlay-icon","description":"Denies the set_overlay_icon command without any pre-configured scope.","commands":{"allow":[],"deny":["set_overlay_icon"]}},"deny-set-position":{"identifier":"deny-set-position","description":"Denies the set_position command without any pre-configured scope.","commands":{"allow":[],"deny":["set_position"]}},"deny-set-progress-bar":{"identifier":"deny-set-progress-bar","description":"Denies the set_progress_bar command without any pre-configured scope.","commands":{"allow":[],"deny":["set_progress_bar"]}},"deny-set-resizable":{"identifier":"deny-set-resizable","description":"Denies the set_resizable command without any pre-configured scope.","commands":{"allow":[],"deny":["set_resizable"]}},"deny-set-shadow":{"identifier":"deny-set-shadow","description":"Denies the set_shadow command without any pre-configured scope.","commands":{"allow":[],"deny":["set_shadow"]}},"deny-set-simple-fullscreen":{"identifier":"deny-set-simple-fullscreen","description":"Denies the set_simple_fullscreen command without any pre-configured scope.","commands":{"allow":[],"deny":["set_simple_fullscreen"]}},"deny-set-size":{"identifier":"deny-set-size","description":"Denies the set_size command without any pre-configured scope.","commands":{"allow":[],"deny":["set_size"]}},"deny-set-size-constraints":{"identifier":"deny-set-size-constraints","description":"Denies the set_size_constraints command without any pre-configured scope.","commands":{"allow":[],"deny":["set_size_constraints"]}},"deny-set-skip-taskbar":{"identifier":"deny-set-skip-taskbar","description":"Denies the set_skip_taskbar command without any pre-configured scope.","commands":{"allow":[],"deny":["set_skip_taskbar"]}},"deny-set-theme":{"identifier":"deny-set-theme","description":"Denies the set_theme command without any pre-configured scope.","commands":{"allow":[],"deny":["set_theme"]}},"deny-set-title":{"identifier":"deny-set-title","description":"Denies the set_title command without any pre-configured scope.","commands":{"allow":[],"deny":["set_title"]}},"deny-set-title-bar-style":{"identifier":"deny-set-title-bar-style","description":"Denies the set_title_bar_style command without any pre-configured scope.","commands":{"allow":[],"deny":["set_title_bar_style"]}},"deny-set-visible-on-all-workspaces":{"identifier":"deny-set-visible-on-all-workspaces","description":"Denies the set_visible_on_all_workspaces command without any pre-configured scope.","commands":{"allow":[],"deny":["set_visible_on_all_workspaces"]}},"deny-show":{"identifier":"deny-show","description":"Denies the show command without any pre-configured scope.","commands":{"allow":[],"deny":["show"]}},"deny-start-dragging":{"identifier":"deny-start-dragging","description":"Denies the start_dragging command without any pre-configured scope.","commands":{"allow":[],"deny":["start_dragging"]}},"deny-start-resize-dragging":{"identifier":"deny-start-resize-dragging","description":"Denies the start_resize_dragging command without any pre-configured scope.","commands":{"allow":[],"deny":["start_resize_dragging"]}},"deny-theme":{"identifier":"deny-theme","description":"Denies the theme command without any pre-configured scope.","commands":{"allow":[],"deny":["theme"]}},"deny-title":{"identifier":"deny-title","description":"Denies the title command without any pre-configured scope.","commands":{"allow":[],"deny":["title"]}},"deny-toggle-maximize":{"identifier":"deny-toggle-maximize","description":"Denies the toggle_maximize command without any pre-configured scope.","commands":{"allow":[],"deny":["toggle_maximize"]}},"deny-unmaximize":{"identifier":"deny-unmaximize","description":"Denies the unmaximize command without any pre-configured scope.","commands":{"allow":[],"deny":["unmaximize"]}},"deny-unminimize":{"identifier":"deny-unminimize","description":"Denies the unminimize command without any pre-configured scope.","commands":{"allow":[],"deny":["unminimize"]}}},"permission_sets":{},"global_scope_schema":null},"dialog":{"default_permission":{"identifier":"default","description":"This permission set configures the types of dialogs\navailable from the dialog plugin.\n\n#### Granted Permissions\n\nAll dialog types are enabled.\n\n\n","permissions":["allow-ask","allow-confirm","allow-message","allow-save","allow-open"]},"permissions":{"allow-ask":{"identifier":"allow-ask","description":"Enables the ask command without any pre-configured scope.","commands":{"allow":["ask"],"deny":[]}},"allow-confirm":{"identifier":"allow-confirm","description":"Enables the confirm command without any pre-configured scope.","commands":{"allow":["confirm"],"deny":[]}},"allow-message":{"identifier":"allow-message","description":"Enables the message command without any pre-configured scope.","commands":{"allow":["message"],"deny":[]}},"allow-open":{"identifier":"allow-open","description":"Enables the open command without any pre-configured scope.","commands":{"allow":["open"],"deny":[]}},"allow-save":{"identifier":"allow-save","description":"Enables the save command without any pre-configured scope.","commands":{"allow":["save"],"deny":[]}},"deny-ask":{"identifier":"deny-ask","description":"Denies the ask command without any pre-configured scope.","commands":{"allow":[],"deny":["ask"]}},"deny-confirm":{"identifier":"deny-confirm","description":"Denies the confirm command without any pre-configured scope.","commands":{"allow":[],"deny":["confirm"]}},"deny-message":{"identifier":"deny-message","description":"Denies the message command without any pre-configured scope.","commands":{"allow":[],"deny":["message"]}},"deny-open":{"identifier":"deny-open","description":"Denies the open command without any pre-configured scope.","commands":{"allow":[],"deny":["open"]}},"deny-save":{"identifier":"deny-save","description":"Denies the save command without any pre-configured scope.","commands":{"allow":[],"deny":["save"]}}},"permission_sets":{},"global_scope_schema":null},"fs":{"default_permission":{"identifier":"default","description":"This set of permissions describes the what kind of\nfile system access the `fs` plugin has enabled or denied by default.\n\n#### Granted Permissions\n\nThis default permission set enables read access to the\napplication specific directories (AppConfig, AppData, AppLocalData, AppCache,\nAppLog) and all files and sub directories created in it.\nThe location of these directories depends on the operating system,\nwhere the application is run.\n\nIn general these directories need to be manually created\nby the application at runtime, before accessing files or folders\nin it is possible.\n\nTherefore, it is also allowed to create all of these folders via\nthe `mkdir` command.\n\n#### Denied Permissions\n\nThis default permission set prevents access to critical components\nof the Tauri application by default.\nOn Windows the webview data folder access is denied.\n","permissions":["create-app-specific-dirs","read-app-specific-dirs-recursive","deny-default"]},"permissions":{"allow-copy-file":{"identifier":"allow-copy-file","description":"Enables the copy_file command without any pre-configured scope.","commands":{"allow":["copy_file"],"deny":[]}},"allow-create":{"identifier":"allow-create","description":"Enables the create command without any pre-configured scope.","commands":{"allow":["create"],"deny":[]}},"allow-exists":{"identifier":"allow-exists","description":"Enables the exists command without any pre-configured scope.","commands":{"allow":["exists"],"deny":[]}},"allow-fstat":{"identifier":"allow-fstat","description":"Enables the fstat command without any pre-configured scope.","commands":{"allow":["fstat"],"deny":[]}},"allow-ftruncate":{"identifier":"allow-ftruncate","description":"Enables the ftruncate command without any pre-configured scope.","commands":{"allow":["ftruncate"],"deny":[]}},"allow-lstat":{"identifier":"allow-lstat","description":"Enables the lstat command without any pre-configured scope.","commands":{"allow":["lstat"],"deny":[]}},"allow-mkdir":{"identifier":"allow-mkdir","description":"Enables the mkdir command without any pre-configured scope.","commands":{"allow":["mkdir"],"deny":[]}},"allow-open":{"identifier":"allow-open","description":"Enables the open command without any pre-configured scope.","commands":{"allow":["open"],"deny":[]}},"allow-read":{"identifier":"allow-read","description":"Enables the read command without any pre-configured scope.","commands":{"allow":["read"],"deny":[]}},"allow-read-dir":{"identifier":"allow-read-dir","description":"Enables the read_dir command without any pre-configured scope.","commands":{"allow":["read_dir"],"deny":[]}},"allow-read-file":{"identifier":"allow-read-file","description":"Enables the read_file command without any pre-configured scope.","commands":{"allow":["read_file"],"deny":[]}},"allow-read-text-file":{"identifier":"allow-read-text-file","description":"Enables the read_text_file command without any pre-configured scope.","commands":{"allow":["read_text_file"],"deny":[]}},"allow-read-text-file-lines":{"identifier":"allow-read-text-file-lines","description":"Enables the read_text_file_lines command without any pre-configured scope.","commands":{"allow":["read_text_file_lines","read_text_file_lines_next"],"deny":[]}},"allow-read-text-file-lines-next":{"identifier":"allow-read-text-file-lines-next","description":"Enables the read_text_file_lines_next command without any pre-configured scope.","commands":{"allow":["read_text_file_lines_next"],"deny":[]}},"allow-remove":{"identifier":"allow-remove","description":"Enables the remove command without any pre-configured scope.","commands":{"allow":["remove"],"deny":[]}},"allow-rename":{"identifier":"allow-rename","description":"Enables the rename command without any pre-configured scope.","commands":{"allow":["rename"],"deny":[]}},"allow-seek":{"identifier":"allow-seek","description":"Enables the seek command without any pre-configured scope.","commands":{"allow":["seek"],"deny":[]}},"allow-size":{"identifier":"allow-size","description":"Enables the size command without any pre-configured scope.","commands":{"allow":["size"],"deny":[]}},"allow-stat":{"identifier":"allow-stat","description":"Enables the stat command without any pre-configured scope.","commands":{"allow":["stat"],"deny":[]}},"allow-truncate":{"identifier":"allow-truncate","description":"Enables the truncate command without any pre-configured scope.","commands":{"allow":["truncate"],"deny":[]}},"allow-unwatch":{"identifier":"allow-unwatch","description":"Enables the unwatch command without any pre-configured scope.","commands":{"allow":["unwatch"],"deny":[]}},"allow-watch":{"identifier":"allow-watch","description":"Enables the watch command without any pre-configured scope.","commands":{"allow":["watch"],"deny":[]}},"allow-write":{"identifier":"allow-write","description":"Enables the write command without any pre-configured scope.","commands":{"allow":["write"],"deny":[]}},"allow-write-file":{"identifier":"allow-write-file","description":"Enables the write_file command without any pre-configured scope.","commands":{"allow":["write_file","open","write"],"deny":[]}},"allow-write-text-file":{"identifier":"allow-write-text-file","description":"Enables the write_text_file command without any pre-configured scope.","commands":{"allow":["write_text_file"],"deny":[]}},"create-app-specific-dirs":{"identifier":"create-app-specific-dirs","description":"This permissions allows to create the application specific directories.\n","commands":{"allow":["mkdir","scope-app-index"],"deny":[]}},"deny-copy-file":{"identifier":"deny-copy-file","description":"Denies the copy_file command without any pre-configured scope.","commands":{"allow":[],"deny":["copy_file"]}},"deny-create":{"identifier":"deny-create","description":"Denies the create command without any pre-configured scope.","commands":{"allow":[],"deny":["create"]}},"deny-exists":{"identifier":"deny-exists","description":"Denies the exists command without any pre-configured scope.","commands":{"allow":[],"deny":["exists"]}},"deny-fstat":{"identifier":"deny-fstat","description":"Denies the fstat command without any pre-configured scope.","commands":{"allow":[],"deny":["fstat"]}},"deny-ftruncate":{"identifier":"deny-ftruncate","description":"Denies the ftruncate command without any pre-configured scope.","commands":{"allow":[],"deny":["ftruncate"]}},"deny-lstat":{"identifier":"deny-lstat","description":"Denies the lstat command without any pre-configured scope.","commands":{"allow":[],"deny":["lstat"]}},"deny-mkdir":{"identifier":"deny-mkdir","description":"Denies the mkdir command without any pre-configured scope.","commands":{"allow":[],"deny":["mkdir"]}},"deny-open":{"identifier":"deny-open","description":"Denies the open command without any pre-configured scope.","commands":{"allow":[],"deny":["open"]}},"deny-read":{"identifier":"deny-read","description":"Denies the read command without any pre-configured scope.","commands":{"allow":[],"deny":["read"]}},"deny-read-dir":{"identifier":"deny-read-dir","description":"Denies the read_dir command without any pre-configured scope.","commands":{"allow":[],"deny":["read_dir"]}},"deny-read-file":{"identifier":"deny-read-file","description":"Denies the read_file command without any pre-configured scope.","commands":{"allow":[],"deny":["read_file"]}},"deny-read-text-file":{"identifier":"deny-read-text-file","description":"Denies the read_text_file command without any pre-configured scope.","commands":{"allow":[],"deny":["read_text_file"]}},"deny-read-text-file-lines":{"identifier":"deny-read-text-file-lines","description":"Denies the read_text_file_lines command without any pre-configured scope.","commands":{"allow":[],"deny":["read_text_file_lines"]}},"deny-read-text-file-lines-next":{"identifier":"deny-read-text-file-lines-next","description":"Denies the read_text_file_lines_next command without any pre-configured scope.","commands":{"allow":[],"deny":["read_text_file_lines_next"]}},"deny-remove":{"identifier":"deny-remove","description":"Denies the remove command without any pre-configured scope.","commands":{"allow":[],"deny":["remove"]}},"deny-rename":{"identifier":"deny-rename","description":"Denies the rename command without any pre-configured scope.","commands":{"allow":[],"deny":["rename"]}},"deny-seek":{"identifier":"deny-seek","description":"Denies the seek command without any pre-configured scope.","commands":{"allow":[],"deny":["seek"]}},"deny-size":{"identifier":"deny-size","description":"Denies the size command without any pre-configured scope.","commands":{"allow":[],"deny":["size"]}},"deny-stat":{"identifier":"deny-stat","description":"Denies the stat command without any pre-configured scope.","commands":{"allow":[],"deny":["stat"]}},"deny-truncate":{"identifier":"deny-truncate","description":"Denies the truncate command without any pre-configured scope.","commands":{"allow":[],"deny":["truncate"]}},"deny-unwatch":{"identifier":"deny-unwatch","description":"Denies the unwatch command without any pre-configured scope.","commands":{"allow":[],"deny":["unwatch"]}},"deny-watch":{"identifier":"deny-watch","description":"Denies the watch command without any pre-configured scope.","commands":{"allow":[],"deny":["watch"]}},"deny-webview-data-linux":{"identifier":"deny-webview-data-linux","description":"This denies read access to the\n`$APPLOCALDATA` folder on linux as the webview data and configuration values are stored here.\nAllowing access can lead to sensitive information disclosure and should be well considered.","commands":{"allow":[],"deny":[]}},"deny-webview-data-windows":{"identifier":"deny-webview-data-windows","description":"This denies read access to the\n`$APPLOCALDATA/EBWebView` folder on windows as the webview data and configuration values are stored here.\nAllowing access can lead to sensitive information disclosure and should be well considered.","commands":{"allow":[],"deny":[]}},"deny-write":{"identifier":"deny-write","description":"Denies the write command without any pre-configured scope.","commands":{"allow":[],"deny":["write"]}},"deny-write-file":{"identifier":"deny-write-file","description":"Denies the write_file command without any pre-configured scope.","commands":{"allow":[],"deny":["write_file"]}},"deny-write-text-file":{"identifier":"deny-write-text-file","description":"Denies the write_text_file command without any pre-configured scope.","commands":{"allow":[],"deny":["write_text_file"]}},"read-all":{"identifier":"read-all","description":"This enables all read related commands without any pre-configured accessible paths.","commands":{"allow":["read_dir","read_file","read","open","read_text_file","read_text_file_lines","read_text_file_lines_next","seek","stat","lstat","fstat","exists","watch","unwatch"],"deny":[]}},"read-app-specific-dirs-recursive":{"identifier":"read-app-specific-dirs-recursive","description":"This permission allows recursive read functionality on the application\nspecific base directories. \n","commands":{"allow":["read_dir","read_file","read_text_file","read_text_file_lines","read_text_file_lines_next","exists","scope-app-recursive"],"deny":[]}},"read-dirs":{"identifier":"read-dirs","description":"This enables directory read and file metadata related commands without any pre-configured accessible paths.","commands":{"allow":["read_dir","stat","lstat","fstat","exists"],"deny":[]}},"read-files":{"identifier":"read-files","description":"This enables file read related commands without any pre-configured accessible paths.","commands":{"allow":["read_file","read","open","read_text_file","read_text_file_lines","read_text_file_lines_next","seek","stat","lstat","fstat","exists"],"deny":[]}},"read-meta":{"identifier":"read-meta","description":"This enables all index or metadata related commands without any pre-configured accessible paths.","commands":{"allow":["read_dir","stat","lstat","fstat","exists","size"],"deny":[]}},"scope":{"identifier":"scope","description":"An empty permission you can use to modify the global scope.\n\n## Example\n\n```json\n{\n  \"identifier\": \"read-documents\",\n  \"windows\": [\"main\"],\n  \"permissions\": [\n    \"fs:allow-read\",\n    {\n      \"identifier\": \"fs:scope\",\n      \"allow\": [\n        \"$APPDATA/documents/**/*\"\n      ],\n      \"deny\": [\n        \"$APPDATA/documents/secret.txt\"\n      ]\n    }\n  ]\n}\n```\n","commands":{"allow":[],"deny":[]}},"scope-app":{"identifier":"scope-app","description":"This scope permits access to all files and list content of top level directories in the application folders.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPCONFIG"},{"path":"$APPCONFIG/*"},{"path":"$APPDATA"},{"path":"$APPDATA/*"},{"path":"$APPLOCALDATA"},{"path":"$APPLOCALDATA/*"},{"path":"$APPCACHE"},{"path":"$APPCACHE/*"},{"path":"$APPLOG"},{"path":"$APPLOG/*"}]}},"scope-app-index":{"identifier":"scope-app-index","description":"This scope permits to list all files and folders in the application directories.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPCONFIG"},{"path":"$APPDATA"},{"path":"$APPLOCALDATA"},{"path":"$APPCACHE"},{"path":"$APPLOG"}]}},"scope-app-recursive":{"identifier":"scope-app-recursive","description":"This scope permits recursive access to the complete application folders, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPCONFIG"},{"path":"$APPCONFIG/**"},{"path":"$APPDATA"},{"path":"$APPDATA/**"},{"path":"$APPLOCALDATA"},{"path":"$APPLOCALDATA/**"},{"path":"$APPCACHE"},{"path":"$APPCACHE/**"},{"path":"$APPLOG"},{"path":"$APPLOG/**"}]}},"scope-appcache":{"identifier":"scope-appcache","description":"This scope permits access to all files and list content of top level directories in the `$APPCACHE` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPCACHE"},{"path":"$APPCACHE/*"}]}},"scope-appcache-index":{"identifier":"scope-appcache-index","description":"This scope permits to list all files and folders in the `$APPCACHE`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPCACHE"}]}},"scope-appcache-recursive":{"identifier":"scope-appcache-recursive","description":"This scope permits recursive access to the complete `$APPCACHE` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPCACHE"},{"path":"$APPCACHE/**"}]}},"scope-appconfig":{"identifier":"scope-appconfig","description":"This scope permits access to all files and list content of top level directories in the `$APPCONFIG` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPCONFIG"},{"path":"$APPCONFIG/*"}]}},"scope-appconfig-index":{"identifier":"scope-appconfig-index","description":"This scope permits to list all files and folders in the `$APPCONFIG`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPCONFIG"}]}},"scope-appconfig-recursive":{"identifier":"scope-appconfig-recursive","description":"This scope permits recursive access to the complete `$APPCONFIG` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPCONFIG"},{"path":"$APPCONFIG/**"}]}},"scope-appdata":{"identifier":"scope-appdata","description":"This scope permits access to all files and list content of top level directories in the `$APPDATA` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPDATA"},{"path":"$APPDATA/*"}]}},"scope-appdata-index":{"identifier":"scope-appdata-index","description":"This scope permits to list all files and folders in the `$APPDATA`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPDATA"}]}},"scope-appdata-recursive":{"identifier":"scope-appdata-recursive","description":"This scope permits recursive access to the complete `$APPDATA` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPDATA"},{"path":"$APPDATA/**"}]}},"scope-applocaldata":{"identifier":"scope-applocaldata","description":"This scope permits access to all files and list content of top level directories in the `$APPLOCALDATA` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPLOCALDATA"},{"path":"$APPLOCALDATA/*"}]}},"scope-applocaldata-index":{"identifier":"scope-applocaldata-index","description":"This scope permits to list all files and folders in the `$APPLOCALDATA`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPLOCALDATA"}]}},"scope-applocaldata-recursive":{"identifier":"scope-applocaldata-recursive","description":"This scope permits recursive access to the complete `$APPLOCALDATA` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPLOCALDATA"},{"path":"$APPLOCALDATA/**"}]}},"scope-applog":{"identifier":"scope-applog","description":"This scope permits access to all files and list content of top level directories in the `$APPLOG` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPLOG"},{"path":"$APPLOG/*"}]}},"scope-applog-index":{"identifier":"scope-applog-index","description":"This scope permits to list all files and folders in the `$APPLOG`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPLOG"}]}},"scope-applog-recursive":{"identifier":"scope-applog-recursive","description":"This scope permits recursive access to the complete `$APPLOG` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$APPLOG"},{"path":"$APPLOG/**"}]}},"scope-audio":{"identifier":"scope-audio","description":"This scope permits access to all files and list content of top level directories in the `$AUDIO` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$AUDIO"},{"path":"$AUDIO/*"}]}},"scope-audio-index":{"identifier":"scope-audio-index","description":"This scope permits to list all files and folders in the `$AUDIO`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$AUDIO"}]}},"scope-audio-recursive":{"identifier":"scope-audio-recursive","description":"This scope permits recursive access to the complete `$AUDIO` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$AUDIO"},{"path":"$AUDIO/**"}]}},"scope-cache":{"identifier":"scope-cache","description":"This scope permits access to all files and list content of top level directories in the `$CACHE` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$CACHE"},{"path":"$CACHE/*"}]}},"scope-cache-index":{"identifier":"scope-cache-index","description":"This scope permits to list all files and folders in the `$CACHE`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$CACHE"}]}},"scope-cache-recursive":{"identifier":"scope-cache-recursive","description":"This scope permits recursive access to the complete `$CACHE` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$CACHE"},{"path":"$CACHE/**"}]}},"scope-config":{"identifier":"scope-config","description":"This scope permits access to all files and list content of top level directories in the `$CONFIG` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$CONFIG"},{"path":"$CONFIG/*"}]}},"scope-config-index":{"identifier":"scope-config-index","description":"This scope permits to list all files and folders in the `$CONFIG`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$CONFIG"}]}},"scope-config-recursive":{"identifier":"scope-config-recursive","description":"This scope permits recursive access to the complete `$CONFIG` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$CONFIG"},{"path":"$CONFIG/**"}]}},"scope-data":{"identifier":"scope-data","description":"This scope permits access to all files and list content of top level directories in the `$DATA` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$DATA"},{"path":"$DATA/*"}]}},"scope-data-index":{"identifier":"scope-data-index","description":"This scope permits to list all files and folders in the `$DATA`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$DATA"}]}},"scope-data-recursive":{"identifier":"scope-data-recursive","description":"This scope permits recursive access to the complete `$DATA` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$DATA"},{"path":"$DATA/**"}]}},"scope-desktop":{"identifier":"scope-desktop","description":"This scope permits access to all files and list content of top level directories in the `$DESKTOP` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$DESKTOP"},{"path":"$DESKTOP/*"}]}},"scope-desktop-index":{"identifier":"scope-desktop-index","description":"This scope permits to list all files and folders in the `$DESKTOP`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$DESKTOP"}]}},"scope-desktop-recursive":{"identifier":"scope-desktop-recursive","description":"This scope permits recursive access to the complete `$DESKTOP` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$DESKTOP"},{"path":"$DESKTOP/**"}]}},"scope-document":{"identifier":"scope-document","description":"This scope permits access to all files and list content of top level directories in the `$DOCUMENT` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$DOCUMENT"},{"path":"$DOCUMENT/*"}]}},"scope-document-index":{"identifier":"scope-document-index","description":"This scope permits to list all files and folders in the `$DOCUMENT`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$DOCUMENT"}]}},"scope-document-recursive":{"identifier":"scope-document-recursive","description":"This scope permits recursive access to the complete `$DOCUMENT` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$DOCUMENT"},{"path":"$DOCUMENT/**"}]}},"scope-download":{"identifier":"scope-download","description":"This scope permits access to all files and list content of top level directories in the `$DOWNLOAD` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$DOWNLOAD"},{"path":"$DOWNLOAD/*"}]}},"scope-download-index":{"identifier":"scope-download-index","description":"This scope permits to list all files and folders in the `$DOWNLOAD`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$DOWNLOAD"}]}},"scope-download-recursive":{"identifier":"scope-download-recursive","description":"This scope permits recursive access to the complete `$DOWNLOAD` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$DOWNLOAD"},{"path":"$DOWNLOAD/**"}]}},"scope-exe":{"identifier":"scope-exe","description":"This scope permits access to all files and list content of top level directories in the `$EXE` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$EXE"},{"path":"$EXE/*"}]}},"scope-exe-index":{"identifier":"scope-exe-index","description":"This scope permits to list all files and folders in the `$EXE`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$EXE"}]}},"scope-exe-recursive":{"identifier":"scope-exe-recursive","description":"This scope permits recursive access to the complete `$EXE` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$EXE"},{"path":"$EXE/**"}]}},"scope-font":{"identifier":"scope-font","description":"This scope permits access to all files and list content of top level directories in the `$FONT` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$FONT"},{"path":"$FONT/*"}]}},"scope-font-index":{"identifier":"scope-font-index","description":"This scope permits to list all files and folders in the `$FONT`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$FONT"}]}},"scope-font-recursive":{"identifier":"scope-font-recursive","description":"This scope permits recursive access to the complete `$FONT` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$FONT"},{"path":"$FONT/**"}]}},"scope-home":{"identifier":"scope-home","description":"This scope permits access to all files and list content of top level directories in the `$HOME` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$HOME"},{"path":"$HOME/*"}]}},"scope-home-index":{"identifier":"scope-home-index","description":"This scope permits to list all files and folders in the `$HOME`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$HOME"}]}},"scope-home-recursive":{"identifier":"scope-home-recursive","description":"This scope permits recursive access to the complete `$HOME` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$HOME"},{"path":"$HOME/**"}]}},"scope-localdata":{"identifier":"scope-localdata","description":"This scope permits access to all files and list content of top level directories in the `$LOCALDATA` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$LOCALDATA"},{"path":"$LOCALDATA/*"}]}},"scope-localdata-index":{"identifier":"scope-localdata-index","description":"This scope permits to list all files and folders in the `$LOCALDATA`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$LOCALDATA"}]}},"scope-localdata-recursive":{"identifier":"scope-localdata-recursive","description":"This scope permits recursive access to the complete `$LOCALDATA` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$LOCALDATA"},{"path":"$LOCALDATA/**"}]}},"scope-log":{"identifier":"scope-log","description":"This scope permits access to all files and list content of top level directories in the `$LOG` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$LOG"},{"path":"$LOG/*"}]}},"scope-log-index":{"identifier":"scope-log-index","description":"This scope permits to list all files and folders in the `$LOG`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$LOG"}]}},"scope-log-recursive":{"identifier":"scope-log-recursive","description":"This scope permits recursive access to the complete `$LOG` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$LOG"},{"path":"$LOG/**"}]}},"scope-picture":{"identifier":"scope-picture","description":"This scope permits access to all files and list content of top level directories in the `$PICTURE` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$PICTURE"},{"path":"$PICTURE/*"}]}},"scope-picture-index":{"identifier":"scope-picture-index","description":"This scope permits to list all files and folders in the `$PICTURE`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$PICTURE"}]}},"scope-picture-recursive":{"identifier":"scope-picture-recursive","description":"This scope permits recursive access to the complete `$PICTURE` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$PICTURE"},{"path":"$PICTURE/**"}]}},"scope-public":{"identifier":"scope-public","description":"This scope permits access to all files and list content of top level directories in the `$PUBLIC` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$PUBLIC"},{"path":"$PUBLIC/*"}]}},"scope-public-index":{"identifier":"scope-public-index","description":"This scope permits to list all files and folders in the `$PUBLIC`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$PUBLIC"}]}},"scope-public-recursive":{"identifier":"scope-public-recursive","description":"This scope permits recursive access to the complete `$PUBLIC` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$PUBLIC"},{"path":"$PUBLIC/**"}]}},"scope-resource":{"identifier":"scope-resource","description":"This scope permits access to all files and list content of top level directories in the `$RESOURCE` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$RESOURCE"},{"path":"$RESOURCE/*"}]}},"scope-resource-index":{"identifier":"scope-resource-index","description":"This scope permits to list all files and folders in the `$RESOURCE`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$RESOURCE"}]}},"scope-resource-recursive":{"identifier":"scope-resource-recursive","description":"This scope permits recursive access to the complete `$RESOURCE` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$RESOURCE"},{"path":"$RESOURCE/**"}]}},"scope-runtime":{"identifier":"scope-runtime","description":"This scope permits access to all files and list content of top level directories in the `$RUNTIME` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$RUNTIME"},{"path":"$RUNTIME/*"}]}},"scope-runtime-index":{"identifier":"scope-runtime-index","description":"This scope permits to list all files and folders in the `$RUNTIME`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$RUNTIME"}]}},"scope-runtime-recursive":{"identifier":"scope-runtime-recursive","description":"This scope permits recursive access to the complete `$RUNTIME` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$RUNTIME"},{"path":"$RUNTIME/**"}]}},"scope-temp":{"identifier":"scope-temp","description":"This scope permits access to all files and list content of top level directories in the `$TEMP` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$TEMP"},{"path":"$TEMP/*"}]}},"scope-temp-index":{"identifier":"scope-temp-index","description":"This scope permits to list all files and folders in the `$TEMP`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$TEMP"}]}},"scope-temp-recursive":{"identifier":"scope-temp-recursive","description":"This scope permits recursive access to the complete `$TEMP` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$TEMP"},{"path":"$TEMP/**"}]}},"scope-template":{"identifier":"scope-template","description":"This scope permits access to all files and list content of top level directories in the `$TEMPLATE` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$TEMPLATE"},{"path":"$TEMPLATE/*"}]}},"scope-template-index":{"identifier":"scope-template-index","description":"This scope permits to list all files and folders in the `$TEMPLATE`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$TEMPLATE"}]}},"scope-template-recursive":{"identifier":"scope-template-recursive","description":"This scope permits recursive access to the complete `$TEMPLATE` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$TEMPLATE"},{"path":"$TEMPLATE/**"}]}},"scope-video":{"identifier":"scope-video","description":"This scope permits access to all files and list content of top level directories in the `$VIDEO` folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$VIDEO"},{"path":"$VIDEO/*"}]}},"scope-video-index":{"identifier":"scope-video-index","description":"This scope permits to list all files and folders in the `$VIDEO`folder.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$VIDEO"}]}},"scope-video-recursive":{"identifier":"scope-video-recursive","description":"This scope permits recursive access to the complete `$VIDEO` folder, including sub directories and files.","commands":{"allow":[],"deny":[]},"scope":{"allow":[{"path":"$VIDEO"},{"path":"$VIDEO/**"}]}},"write-all":{"identifier":"write-all","description":"This enables all write related commands without any pre-configured accessible paths.","commands":{"allow":["mkdir","create","copy_file","remove","rename","truncate","ftruncate","write","write_file","write_text_file"],"deny":[]}},"write-files":{"identifier":"write-files","description":"This enables all file write related commands without any pre-configured accessible paths.","commands":{"allow":["create","copy_file","remove","rename","truncate","ftruncate","write","write_file","write_text_file"],"deny":[]}}},"permission_sets":{"allow-app-meta":{"identifier":"allow-app-meta","description":"This allows non-recursive read access to metadata of the application folders, including file listing and statistics.","permissions":["read-meta","scope-app-index"]},"allow-app-meta-recursive":{"identifier":"allow-app-meta-recursive","description":"This allows full recursive read access to metadata of the application folders, including file listing and statistics.","permissions":["read-meta","scope-app-recursive"]},"allow-app-read":{"identifier":"allow-app-read","description":"This allows non-recursive read access to the application folders.","permissions":["read-all","scope-app"]},"allow-app-read-recursive":{"identifier":"allow-app-read-recursive","description":"This allows full recursive read access to the complete application folders, files and subdirectories.","permissions":["read-all","scope-app-recursive"]},"allow-app-write":{"identifier":"allow-app-write","description":"This allows non-recursive write access to the application folders.","permissions":["write-all","scope-app"]},"allow-app-write-recursive":{"identifier":"allow-app-write-recursive","description":"This allows full recursive write access to the complete application folders, files and subdirectories.","permissions":["write-all","scope-app-recursive"]},"allow-appcache-meta":{"identifier":"allow-appcache-meta","description":"This allows non-recursive read access to metadata of the `$APPCACHE` folder, including file listing and statistics.","permissions":["read-meta","scope-appcache-index"]},"allow-appcache-meta-recursive":{"identifier":"allow-appcache-meta-recursive","description":"This allows full recursive read access to metadata of the `$APPCACHE` folder, including file listing and statistics.","permissions":["read-meta","scope-appcache-recursive"]},"allow-appcache-read":{"identifier":"allow-appcache-read","description":"This allows non-recursive read access to the `$APPCACHE` folder.","permissions":["read-all","scope-appcache"]},"allow-appcache-read-recursive":{"identifier":"allow-appcache-read-recursive","description":"This allows full recursive read access to the complete `$APPCACHE` folder, files and subdirectories.","permissions":["read-all","scope-appcache-recursive"]},"allow-appcache-write":{"identifier":"allow-appcache-write","description":"This allows non-recursive write access to the `$APPCACHE` folder.","permissions":["write-all","scope-appcache"]},"allow-appcache-write-recursive":{"identifier":"allow-appcache-write-recursive","description":"This allows full recursive write access to the complete `$APPCACHE` folder, files and subdirectories.","permissions":["write-all","scope-appcache-recursive"]},"allow-appconfig-meta":{"identifier":"allow-appconfig-meta","description":"This allows non-recursive read access to metadata of the `$APPCONFIG` folder, including file listing and statistics.","permissions":["read-meta","scope-appconfig-index"]},"allow-appconfig-meta-recursive":{"identifier":"allow-appconfig-meta-recursive","description":"This allows full recursive read access to metadata of the `$APPCONFIG` folder, including file listing and statistics.","permissions":["read-meta","scope-appconfig-recursive"]},"allow-appconfig-read":{"identifier":"allow-appconfig-read","description":"This allows non-recursive read access to the `$APPCONFIG` folder.","permissions":["read-all","scope-appconfig"]},"allow-appconfig-read-recursive":{"identifier":"allow-appconfig-read-recursive","description":"This allows full recursive read access to the complete `$APPCONFIG` folder, files and subdirectories.","permissions":["read-all","scope-appconfig-recursive"]},"allow-appconfig-write":{"identifier":"allow-appconfig-write","description":"This allows non-recursive write access to the `$APPCONFIG` folder.","permissions":["write-all","scope-appconfig"]},"allow-appconfig-write-recursive":{"identifier":"allow-appconfig-write-recursive","description":"This allows full recursive write access to the complete `$APPCONFIG` folder, files and subdirectories.","permissions":["write-all","scope-appconfig-recursive"]},"allow-appdata-meta":{"identifier":"allow-appdata-meta","description":"This allows non-recursive read access to metadata of the `$APPDATA` folder, including file listing and statistics.","permissions":["read-meta","scope-appdata-index"]},"allow-appdata-meta-recursive":{"identifier":"allow-appdata-meta-recursive","description":"This allows full recursive read access to metadata of the `$APPDATA` folder, including file listing and statistics.","permissions":["read-meta","scope-appdata-recursive"]},"allow-appdata-read":{"identifier":"allow-appdata-read","description":"This allows non-recursive read access to the `$APPDATA` folder.","permissions":["read-all","scope-appdata"]},"allow-appdata-read-recursive":{"identifier":"allow-appdata-read-recursive","description":"This allows full recursive read access to the complete `$APPDATA` folder, files and subdirectories.","permissions":["read-all","scope-appdata-recursive"]},"allow-appdata-write":{"identifier":"allow-appdata-write","description":"This allows non-recursive write access to the `$APPDATA` folder.","permissions":["write-all","scope-appdata"]},"allow-appdata-write-recursive":{"identifier":"allow-appdata-write-recursive","description":"This allows full recursive write access to the complete `$APPDATA` folder, files and subdirectories.","permissions":["write-all","scope-appdata-recursive"]},"allow-applocaldata-meta":{"identifier":"allow-applocaldata-meta","description":"This allows non-recursive read access to metadata of the `$APPLOCALDATA` folder, including file listing and statistics.","permissions":["read-meta","scope-applocaldata-index"]},"allow-applocaldata-meta-recursive":{"identifier":"allow-applocaldata-meta-recursive","description":"This allows full recursive read access to metadata of the `$APPLOCALDATA` folder, including file listing and statistics.","permissions":["read-meta","scope-applocaldata-recursive"]},"allow-applocaldata-read":{"identifier":"allow-applocaldata-read","description":"This allows non-recursive read access to the `$APPLOCALDATA` folder.","permissions":["read-all","scope-applocaldata"]},"allow-applocaldata-read-recursive":{"identifier":"allow-applocaldata-read-recursive","description":"This allows full recursive read access to the complete `$APPLOCALDATA` folder, files and subdirectories.","permissions":["read-all","scope-applocaldata-recursive"]},"allow-applocaldata-write":{"identifier":"allow-applocaldata-write","description":"This allows non-recursive write access to the `$APPLOCALDATA` folder.","permissions":["write-all","scope-applocaldata"]},"allow-applocaldata-write-recursive":{"identifier":"allow-applocaldata-write-recursive","description":"This allows full recursive write access to the complete `$APPLOCALDATA` folder, files and subdirectories.","permissions":["write-all","scope-applocaldata-recursive"]},"allow-applog-meta":{"identifier":"allow-applog-meta","description":"This allows non-recursive read access to metadata of the `$APPLOG` folder, including file listing and statistics.","permissions":["read-meta","scope-applog-index"]},"allow-applog-meta-recursive":{"identifier":"allow-applog-meta-recursive","description":"This allows full recursive read access to metadata of the `$APPLOG` folder, including file listing and statistics.","permissions":["read-meta","scope-applog-recursive"]},"allow-applog-read":{"identifier":"allow-applog-read","description":"This allows non-recursive read access to the `$APPLOG` folder.","permissions":["read-all","scope-applog"]},"allow-applog-read-recursive":{"identifier":"allow-applog-read-recursive","description":"This allows full recursive read access to the complete `$APPLOG` folder, files and subdirectories.","permissions":["read-all","scope-applog-recursive"]},"allow-applog-write":{"identifier":"allow-applog-write","description":"This allows non-recursive write access to the `$APPLOG` folder.","permissions":["write-all","scope-applog"]},"allow-applog-write-recursive":{"identifier":"allow-applog-write-recursive","description":"This allows full recursive write access to the complete `$APPLOG` folder, files and subdirectories.","permissions":["write-all","scope-applog-recursive"]},"allow-audio-meta":{"identifier":"allow-audio-meta","description":"This allows non-recursive read access to metadata of the `$AUDIO` folder, including file listing and statistics.","permissions":["read-meta","scope-audio-index"]},"allow-audio-meta-recursive":{"identifier":"allow-audio-meta-recursive","description":"This allows full recursive read access to metadata of the `$AUDIO` folder, including file listing and statistics.","permissions":["read-meta","scope-audio-recursive"]},"allow-audio-read":{"identifier":"allow-audio-read","description":"This allows non-recursive read access to the `$AUDIO` folder.","permissions":["read-all","scope-audio"]},"allow-audio-read-recursive":{"identifier":"allow-audio-read-recursive","description":"This allows full recursive read access to the complete `$AUDIO` folder, files and subdirectories.","permissions":["read-all","scope-audio-recursive"]},"allow-audio-write":{"identifier":"allow-audio-write","description":"This allows non-recursive write access to the `$AUDIO` folder.","permissions":["write-all","scope-audio"]},"allow-audio-write-recursive":{"identifier":"allow-audio-write-recursive","description":"This allows full recursive write access to the complete `$AUDIO` folder, files and subdirectories.","permissions":["write-all","scope-audio-recursive"]},"allow-cache-meta":{"identifier":"allow-cache-meta","description":"This allows non-recursive read access to metadata of the `$CACHE` folder, including file listing and statistics.","permissions":["read-meta","scope-cache-index"]},"allow-cache-meta-recursive":{"identifier":"allow-cache-meta-recursive","description":"This allows full recursive read access to metadata of the `$CACHE` folder, including file listing and statistics.","permissions":["read-meta","scope-cache-recursive"]},"allow-cache-read":{"identifier":"allow-cache-read","description":"This allows non-recursive read access to the `$CACHE` folder.","permissions":["read-all","scope-cache"]},"allow-cache-read-recursive":{"identifier":"allow-cache-read-recursive","description":"This allows full recursive read access to the complete `$CACHE` folder, files and subdirectories.","permissions":["read-all","scope-cache-recursive"]},"allow-cache-write":{"identifier":"allow-cache-write","description":"This allows non-recursive write access to the `$CACHE` folder.","permissions":["write-all","scope-cache"]},"allow-cache-write-recursive":{"identifier":"allow-cache-write-recursive","description":"This allows full recursive write access to the complete `$CACHE` folder, files and subdirectories.","permissions":["write-all","scope-cache-recursive"]},"allow-config-meta":{"identifier":"allow-config-meta","description":"This allows non-recursive read access to metadata of the `$CONFIG` folder, including file listing and statistics.","permissions":["read-meta","scope-config-index"]},"allow-config-meta-recursive":{"identifier":"allow-config-meta-recursive","description":"This allows full recursive read access to metadata of the `$CONFIG` folder, including file listing and statistics.","permissions":["read-meta","scope-config-recursive"]},"allow-config-read":{"identifier":"allow-config-read","description":"This allows non-recursive read access to the `$CONFIG` folder.","permissions":["read-all","scope-config"]},"allow-config-read-recursive":{"identifier":"allow-config-read-recursive","description":"This allows full recursive read access to the complete `$CONFIG` folder, files and subdirectories.","permissions":["read-all","scope-config-recursive"]},"allow-config-write":{"identifier":"allow-config-write","description":"This allows non-recursive write access to the `$CONFIG` folder.","permissions":["write-all","scope-config"]},"allow-config-write-recursive":{"identifier":"allow-config-write-recursive","description":"This allows full recursive write access to the complete `$CONFIG` folder, files and subdirectories.","permissions":["write-all","scope-config-recursive"]},"allow-data-meta":{"identifier":"allow-data-meta","description":"This allows non-recursive read access to metadata of the `$DATA` folder, including file listing and statistics.","permissions":["read-meta","scope-data-index"]},"allow-data-meta-recursive":{"identifier":"allow-data-meta-recursive","description":"This allows full recursive read access to metadata of the `$DATA` folder, including file listing and statistics.","permissions":["read-meta","scope-data-recursive"]},"allow-data-read":{"identifier":"allow-data-read","description":"This allows non-recursive read access to the `$DATA` folder.","permissions":["read-all","scope-data"]},"allow-data-read-recursive":{"identifier":"allow-data-read-recursive","description":"This allows full recursive read access to the complete `$DATA` folder, files and subdirectories.","permissions":["read-all","scope-data-recursive"]},"allow-data-write":{"identifier":"allow-data-write","description":"This allows non-recursive write access to the `$DATA` folder.","permissions":["write-all","scope-data"]},"allow-data-write-recursive":{"identifier":"allow-data-write-recursive","description":"This allows full recursive write access to the complete `$DATA` folder, files and subdirectories.","permissions":["write-all","scope-data-recursive"]},"allow-desktop-meta":{"identifier":"allow-desktop-meta","description":"This allows non-recursive read access to metadata of the `$DESKTOP` folder, including file listing and statistics.","permissions":["read-meta","scope-desktop-index"]},"allow-desktop-meta-recursive":{"identifier":"allow-desktop-meta-recursive","description":"This allows full recursive read access to metadata of the `$DESKTOP` folder, including file listing and statistics.","permissions":["read-meta","scope-desktop-recursive"]},"allow-desktop-read":{"identifier":"allow-desktop-read","description":"This allows non-recursive read access to the `$DESKTOP` folder.","permissions":["read-all","scope-desktop"]},"allow-desktop-read-recursive":{"identifier":"allow-desktop-read-recursive","description":"This allows full recursive read access to the complete `$DESKTOP` folder, files and subdirectories.","permissions":["read-all","scope-desktop-recursive"]},"allow-desktop-write":{"identifier":"allow-desktop-write","description":"This allows non-recursive write access to the `$DESKTOP` folder.","permissions":["write-all","scope-desktop"]},"allow-desktop-write-recursive":{"identifier":"allow-desktop-write-recursive","description":"This allows full recursive write access to the complete `$DESKTOP` folder, files and subdirectories.","permissions":["write-all","scope-desktop-recursive"]},"allow-document-meta":{"identifier":"allow-document-meta","description":"This allows non-recursive read access to metadata of the `$DOCUMENT` folder, including file listing and statistics.","permissions":["read-meta","scope-document-index"]},"allow-document-meta-recursive":{"identifier":"allow-document-meta-recursive","description":"This allows full recursive read access to metadata of the `$DOCUMENT` folder, including file listing and statistics.","permissions":["read-meta","scope-document-recursive"]},"allow-document-read":{"identifier":"allow-document-read","description":"This allows non-recursive read access to the `$DOCUMENT` folder.","permissions":["read-all","scope-document"]},"allow-document-read-recursive":{"identifier":"allow-document-read-recursive","description":"This allows full recursive read access to the complete `$DOCUMENT` folder, files and subdirectories.","permissions":["read-all","scope-document-recursive"]},"allow-document-write":{"identifier":"allow-document-write","description":"This allows non-recursive write access to the `$DOCUMENT` folder.","permissions":["write-all","scope-document"]},"allow-document-write-recursive":{"identifier":"allow-document-write-recursive","description":"This allows full recursive write access to the complete `$DOCUMENT` folder, files and subdirectories.","permissions":["write-all","scope-document-recursive"]},"allow-download-meta":{"identifier":"allow-download-meta","description":"This allows non-recursive read access to metadata of the `$DOWNLOAD` folder, including file listing and statistics.","permissions":["read-meta","scope-download-index"]},"allow-download-meta-recursive":{"identifier":"allow-download-meta-recursive","description":"This allows full recursive read access to metadata of the `$DOWNLOAD` folder, including file listing and statistics.","permissions":["read-meta","scope-download-recursive"]},"allow-download-read":{"identifier":"allow-download-read","description":"This allows non-recursive read access to the `$DOWNLOAD` folder.","permissions":["read-all","scope-download"]},"allow-download-read-recursive":{"identifier":"allow-download-read-recursive","description":"This allows full recursive read access to the complete `$DOWNLOAD` folder, files and subdirectories.","permissions":["read-all","scope-download-recursive"]},"allow-download-write":{"identifier":"allow-download-write","description":"This allows non-recursive write access to the `$DOWNLOAD` folder.","permissions":["write-all","scope-download"]},"allow-download-write-recursive":{"identifier":"allow-download-write-recursive","description":"This allows full recursive write access to the complete `$DOWNLOAD` folder, files and subdirectories.","permissions":["write-all","scope-download-recursive"]},"allow-exe-meta":{"identifier":"allow-exe-meta","description":"This allows non-recursive read access to metadata of the `$EXE` folder, including file listing and statistics.","permissions":["read-meta","scope-exe-index"]},"allow-exe-meta-recursive":{"identifier":"allow-exe-meta-recursive","description":"This allows full recursive read access to metadata of the `$EXE` folder, including file listing and statistics.","permissions":["read-meta","scope-exe-recursive"]},"allow-exe-read":{"identifier":"allow-exe-read","description":"This allows non-recursive read access to the `$EXE` folder.","permissions":["read-all","scope-exe"]},"allow-exe-read-recursive":{"identifier":"allow-exe-read-recursive","description":"This allows full recursive read access to the complete `$EXE` folder, files and subdirectories.","permissions":["read-all","scope-exe-recursive"]},"allow-exe-write":{"identifier":"allow-exe-write","description":"This allows non-recursive write access to the `$EXE` folder.","permissions":["write-all","scope-exe"]},"allow-exe-write-recursive":{"identifier":"allow-exe-write-recursive","description":"This allows full recursive write access to the complete `$EXE` folder, files and subdirectories.","permissions":["write-all","scope-exe-recursive"]},"allow-font-meta":{"identifier":"allow-font-meta","description":"This allows non-recursive read access to metadata of the `$FONT` folder, including file listing and statistics.","permissions":["read-meta","scope-font-index"]},"allow-font-meta-recursive":{"identifier":"allow-font-meta-recursive","description":"This allows full recursive read access to metadata of the `$FONT` folder, including file listing and statistics.","permissions":["read-meta","scope-font-recursive"]},"allow-font-read":{"identifier":"allow-font-read","description":"This allows non-recursive read access to the `$FONT` folder.","permissions":["read-all","scope-font"]},"allow-font-read-recursive":{"identifier":"allow-font-read-recursive","description":"This allows full recursive read access to the complete `$FONT` folder, files and subdirectories.","permissions":["read-all","scope-font-recursive"]},"allow-font-write":{"identifier":"allow-font-write","description":"This allows non-recursive write access to the `$FONT` folder.","permissions":["write-all","scope-font"]},"allow-font-write-recursive":{"identifier":"allow-font-write-recursive","description":"This allows full recursive write access to the complete `$FONT` folder, files and subdirectories.","permissions":["write-all","scope-font-recursive"]},"allow-home-meta":{"identifier":"allow-home-meta","description":"This allows non-recursive read access to metadata of the `$HOME` folder, including file listing and statistics.","permissions":["read-meta","scope-home-index"]},"allow-home-meta-recursive":{"identifier":"allow-home-meta-recursive","description":"This allows full recursive read access to metadata of the `$HOME` folder, including file listing and statistics.","permissions":["read-meta","scope-home-recursive"]},"allow-home-read":{"identifier":"allow-home-read","description":"This allows non-recursive read access to the `$HOME` folder.","permissions":["read-all","scope-home"]},"allow-home-read-recursive":{"identifier":"allow-home-read-recursive","description":"This allows full recursive read access to the complete `$HOME` folder, files and subdirectories.","permissions":["read-all","scope-home-recursive"]},"allow-home-write":{"identifier":"allow-home-write","description":"This allows non-recursive write access to the `$HOME` folder.","permissions":["write-all","scope-home"]},"allow-home-write-recursive":{"identifier":"allow-home-write-recursive","description":"This allows full recursive write access to the complete `$HOME` folder, files and subdirectories.","permissions":["write-all","scope-home-recursive"]},"allow-localdata-meta":{"identifier":"allow-localdata-meta","description":"This allows non-recursive read access to metadata of the `$LOCALDATA` folder, including file listing and statistics.","permissions":["read-meta","scope-localdata-index"]},"allow-localdata-meta-recursive":{"identifier":"allow-localdata-meta-recursive","description":"This allows full recursive read access to metadata of the `$LOCALDATA` folder, including file listing and statistics.","permissions":["read-meta","scope-localdata-recursive"]},"allow-localdata-read":{"identifier":"allow-localdata-read","description":"This allows non-recursive read access to the `$LOCALDATA` folder.","permissions":["read-all","scope-localdata"]},"allow-localdata-read-recursive":{"identifier":"allow-localdata-read-recursive","description":"This allows full recursive read access to the complete `$LOCALDATA` folder, files and subdirectories.","permissions":["read-all","scope-localdata-recursive"]},"allow-localdata-write":{"identifier":"allow-localdata-write","description":"This allows non-recursive write access to the `$LOCALDATA` folder.","permissions":["write-all","scope-localdata"]},"allow-localdata-write-recursive":{"identifier":"allow-localdata-write-recursive","description":"This allows full recursive write access to the complete `$LOCALDATA` folder, files and subdirectories.","permissions":["write-all","scope-localdata-recursive"]},"allow-log-meta":{"identifier":"allow-log-meta","description":"This allows non-recursive read access to metadata of the `$LOG` folder, including file listing and statistics.","permissions":["read-meta","scope-log-index"]},"allow-log-meta-recursive":{"identifier":"allow-log-meta-recursive","description":"This allows full recursive read access to metadata of the `$LOG` folder, including file listing and statistics.","permissions":["read-meta","scope-log-recursive"]},"allow-log-read":{"identifier":"allow-log-read","description":"This allows non-recursive read access to the `$LOG` folder.","permissions":["read-all","scope-log"]},"allow-log-read-recursive":{"identifier":"allow-log-read-recursive","description":"This allows full recursive read access to the complete `$LOG` folder, files and subdirectories.","permissions":["read-all","scope-log-recursive"]},"allow-log-write":{"identifier":"allow-log-write","description":"This allows non-recursive write access to the `$LOG` folder.","permissions":["write-all","scope-log"]},"allow-log-write-recursive":{"identifier":"allow-log-write-recursive","description":"This allows full recursive write access to the complete `$LOG` folder, files and subdirectories.","permissions":["write-all","scope-log-recursive"]},"allow-picture-meta":{"identifier":"allow-picture-meta","description":"This allows non-recursive read access to metadata of the `$PICTURE` folder, including file listing and statistics.","permissions":["read-meta","scope-picture-index"]},"allow-picture-meta-recursive":{"identifier":"allow-picture-meta-recursive","description":"This allows full recursive read access to metadata of the `$PICTURE` folder, including file listing and statistics.","permissions":["read-meta","scope-picture-recursive"]},"allow-picture-read":{"identifier":"allow-picture-read","description":"This allows non-recursive read access to the `$PICTURE` folder.","permissions":["read-all","scope-picture"]},"allow-picture-read-recursive":{"identifier":"allow-picture-read-recursive","description":"This allows full recursive read access to the complete `$PICTURE` folder, files and subdirectories.","permissions":["read-all","scope-picture-recursive"]},"allow-picture-write":{"identifier":"allow-picture-write","description":"This allows non-recursive write access to the `$PICTURE` folder.","permissions":["write-all","scope-picture"]},"allow-picture-write-recursive":{"identifier":"allow-picture-write-recursive","description":"This allows full recursive write access to the complete `$PICTURE` folder, files and subdirectories.","permissions":["write-all","scope-picture-recursive"]},"allow-public-meta":{"identifier":"allow-public-meta","description":"This allows non-recursive read access to metadata of the `$PUBLIC` folder, including file listing and statistics.","permissions":["read-meta","scope-public-index"]},"allow-public-meta-recursive":{"identifier":"allow-public-meta-recursive","description":"This allows full recursive read access to metadata of the `$PUBLIC` folder, including file listing and statistics.","permissions":["read-meta","scope-public-recursive"]},"allow-public-read":{"identifier":"allow-public-read","description":"This allows non-recursive read access to the `$PUBLIC` folder.","permissions":["read-all","scope-public"]},"allow-public-read-recursive":{"identifier":"allow-public-read-recursive","description":"This allows full recursive read access to the complete `$PUBLIC` folder, files and subdirectories.","permissions":["read-all","scope-public-recursive"]},"allow-public-write":{"identifier":"allow-public-write","description":"This allows non-recursive write access to the `$PUBLIC` folder.","permissions":["write-all","scope-public"]},"allow-public-write-recursive":{"identifier":"allow-public-write-recursive","description":"This allows full recursive write access to the complete `$PUBLIC` folder, files and subdirectories.","permissions":["write-all","scope-public-recursive"]},"allow-resource-meta":{"identifier":"allow-resource-meta","description":"This allows non-recursive read access to metadata of the `$RESOURCE` folder, including file listing and statistics.","permissions":["read-meta","scope-resource-index"]},"allow-resource-meta-recursive":{"identifier":"allow-resource-meta-recursive","description":"This allows full recursive read access to metadata of the `$RESOURCE` folder, including file listing and statistics.","permissions":["read-meta","scope-resource-recursive"]},"allow-resource-read":{"identifier":"allow-resource-read","description":"This allows non-recursive read access to the `$RESOURCE` folder.","permissions":["read-all","scope-resource"]},"allow-resource-read-recursive":{"identifier":"allow-resource-read-recursive","description":"This allows full recursive read access to the complete `$RESOURCE` folder, files and subdirectories.","permissions":["read-all","scope-resource-recursive"]},"allow-resource-write":{"identifier":"allow-resource-write","description":"This allows non-recursive write access to the `$RESOURCE` folder.","permissions":["write-all","scope-resource"]},"allow-resource-write-recursive":{"identifier":"allow-resource-write-recursive","description":"This allows full recursive write access to the complete `$RESOURCE` folder, files and subdirectories.","permissions":["write-all","scope-resource-recursive"]},"allow-runtime-meta":{"identifier":"allow-runtime-meta","description":"This allows non-recursive read access to metadata of the `$RUNTIME` folder, including file listing and statistics.","permissions":["read-meta","scope-runtime-index"]},"allow-runtime-meta-recursive":{"identifier":"allow-runtime-meta-recursive","description":"This allows full recursive read access to metadata of the `$RUNTIME` folder, including file listing and statistics.","permissions":["read-meta","scope-runtime-recursive"]},"allow-runtime-read":{"identifier":"allow-runtime-read","description":"This allows non-recursive read access to the `$RUNTIME` folder.","permissions":["read-all","scope-runtime"]},"allow-runtime-read-recursive":{"identifier":"allow-runtime-read-recursive","description":"This allows full recursive read access to the complete `$RUNTIME` folder, files and subdirectories.","permissions":["read-all","scope-runtime-recursive"]},"allow-runtime-write":{"identifier":"allow-runtime-write","description":"This allows non-recursive write access to the `$RUNTIME` folder.","permissions":["write-all","scope-runtime"]},"allow-runtime-write-recursive":{"identifier":"allow-runtime-write-recursive","description":"This allows full recursive write access to the complete `$RUNTIME` folder, files and subdirectories.","permissions":["write-all","scope-runtime-recursive"]},"allow-temp-meta":{"identifier":"allow-temp-meta","description":"This allows non-recursive read access to metadata of the `$TEMP` folder, including file listing and statistics.","permissions":["read-meta","scope-temp-index"]},"allow-temp-meta-recursive":{"identifier":"allow-temp-meta-recursive","description":"This allows full recursive read access to metadata of the `$TEMP` folder, including file listing and statistics.","permissions":["read-meta","scope-temp-recursive"]},"allow-temp-read":{"identifier":"allow-temp-read","description":"This allows non-recursive read access to the `$TEMP` folder.","permissions":["read-all","scope-temp"]},"allow-temp-read-recursive":{"identifier":"allow-temp-read-recursive","description":"This allows full recursive read access to the complete `$TEMP` folder, files and subdirectories.","permissions":["read-all","scope-temp-recursive"]},"allow-temp-write":{"identifier":"allow-temp-write","description":"This allows non-recursive write access to the `$TEMP` folder.","permissions":["write-all","scope-temp"]},"allow-temp-write-recursive":{"identifier":"allow-temp-write-recursive","description":"This allows full recursive write access to the complete `$TEMP` folder, files and subdirectories.","permissions":["write-all","scope-temp-recursive"]},"allow-template-meta":{"identifier":"allow-template-meta","description":"This allows non-recursive read access to metadata of the `$TEMPLATE` folder, including file listing and statistics.","permissions":["read-meta","scope-template-index"]},"allow-template-meta-recursive":{"identifier":"allow-template-meta-recursive","description":"This allows full recursive read access to metadata of the `$TEMPLATE` folder, including file listing and statistics.","permissions":["read-meta","scope-template-recursive"]},"allow-template-read":{"identifier":"allow-template-read","description":"This allows non-recursive read access to the `$TEMPLATE` folder.","permissions":["read-all","scope-template"]},"allow-template-read-recursive":{"identifier":"allow-template-read-recursive","description":"This allows full recursive read access to the complete `$TEMPLATE` folder, files and subdirectories.","permissions":["read-all","scope-template-recursive"]},"allow-template-write":{"identifier":"allow-template-write","description":"This allows non-recursive write access to the `$TEMPLATE` folder.","permissions":["write-all","scope-template"]},"allow-template-write-recursive":{"identifier":"allow-template-write-recursive","description":"This allows full recursive write access to the complete `$TEMPLATE` folder, files and subdirectories.","permissions":["write-all","scope-template-recursive"]},"allow-video-meta":{"identifier":"allow-video-meta","description":"This allows non-recursive read access to metadata of the `$VIDEO` folder, including file listing and statistics.","permissions":["read-meta","scope-video-index"]},"allow-video-meta-recursive":{"identifier":"allow-video-meta-recursive","description":"This allows full recursive read access to metadata of the `$VIDEO` folder, including file listing and statistics.","permissions":["read-meta","scope-video-recursive"]},"allow-video-read":{"identifier":"allow-video-read","description":"This allows non-recursive read access to the `$VIDEO` folder.","permissions":["read-all","scope-video"]},"allow-video-read-recursive":{"identifier":"allow-video-read-recursive","description":"This allows full recursive read access to the complete `$VIDEO` folder, files and subdirectories.","permissions":["read-all","scope-video-recursive"]},"allow-video-write":{"identifier":"allow-video-write","description":"This allows non-recursive write access to the `$VIDEO` folder.","permissions":["write-all","scope-video"]},"allow-video-write-recursive":{"identifier":"allow-video-write-recursive","description":"This allows full recursive write access to the complete `$VIDEO` folder, files and subdirectories.","permissions":["write-all","scope-video-recursive"]},"deny-default":{"identifier":"deny-default","description":"This denies access to dangerous Tauri relevant files and folders by default.","permissions":["deny-webview-data-linux","deny-webview-data-windows"]}},"global_scope_schema":{"$schema":"http://json-schema.org/draft-07/schema#","anyOf":[{"description":"A path that can be accessed by the webview when using the fs APIs. FS scope path pattern.\n\nThe pattern can start with a variable that resolves to a system base directory. The variables are: `$AUDIO`, `$CACHE`, `$CONFIG`, `$DATA`, `$LOCALDATA`, `$DESKTOP`, `$DOCUMENT`, `$DOWNLOAD`, `$EXE`, `$FONT`, `$HOME`, `$PICTURE`, `$PUBLIC`, `$RUNTIME`, `$TEMPLATE`, `$VIDEO`, `$RESOURCE`, `$APP`, `$LOG`, `$TEMP`, `$APPCONFIG`, `$APPDATA`, `$APPLOCALDATA`, `$APPCACHE`, `$APPLOG`.","type":"string"},{"properties":{"path":{"description":"A path that can be accessed by the webview when using the fs APIs.\n\nThe pattern can start with a variable that resolves to a system base directory. The variables are: `$AUDIO`, `$CACHE`, `$CONFIG`, `$DATA`, `$LOCALDATA`, `$DESKTOP`, `$DOCUMENT`, `$DOWNLOAD`, `$EXE`, `$FONT`, `$HOME`, `$PICTURE`, `$PUBLIC`, `$RUNTIME`, `$TEMPLATE`, `$VIDEO`, `$RESOURCE`, `$APP`, `$LOG`, `$TEMP`, `$APPCONFIG`, `$APPDATA`, `$APPLOCALDATA`, `$APPCACHE`, `$APPLOG`.","type":"string"}},"required":["path"],"type":"object"}],"description":"FS scope entry.","title":"FsScopeEntry"}},"shell":{"default_permission":{"identifier":"default","description":"This permission set configures which\nshell functionality is exposed by default.\n\n#### Granted Permissions\n\nIt allows to use the `open` functionality with a reasonable\nscope pre-configured. It will allow opening `http(s)://`,\n`tel:` and `mailto:` links.\n","permissions":["allow-open"]},"permissions":{"allow-execute":{"identifier":"allow-execute","description":"Enables the execute command without any pre-configured scope.","commands":{"allow":["execute"],"deny":[]}},"allow-kill":{"identifier":"allow-kill","description":"Enables the kill command without any pre-configured scope.","commands":{"allow":["kill"],"deny":[]}},"allow-open":{"identifier":"allow-open","description":"Enables the open command without any pre-configured scope.","commands":{"allow":["open"],"deny":[]}},"allow-spawn":{"identifier":"allow-spawn","description":"Enables the spawn command without any pre-configured scope.","commands":{"allow":["spawn"],"deny":[]}},"allow-stdin-write":{"identifier":"allow-stdin-write","description":"Enables the stdin_write command without any pre-configured scope.","commands":{"allow":["stdin_write"],"deny":[]}},"deny-execute":{"identifier":"deny-execute","description":"Denies the execute command without any pre-configured scope.","commands":{"allow":[],"deny":["execute"]}},"deny-kill":{"identifier":"deny-kill","description":"Denies the kill command without any pre-configured scope.","commands":{"allow":[],"deny":["kill"]}},"deny-open":{"identifier":"deny-open","description":"Denies the open command without any pre-configured scope.","commands":{"allow":[],"deny":["open"]}},"deny-spawn":{"identifier":"deny-spawn","description":"Denies the spawn command without any pre-configured scope.","commands":{"allow":[],"deny":["spawn"]}},"deny-stdin-write":{"identifier":"deny-stdin-write","description":"Denies the stdin_write command without any pre-configured scope.","commands":{"allow":[],"deny":["stdin_write"]}}},"permission_sets":{},"global_scope_schema":{"$schema":"http://json-schema.org/draft-07/schema#","anyOf":[{"additionalProperties":false,"properties":{"args":{"allOf":[{"$ref":"#/definitions/ShellScopeEntryAllowedArgs"}],"description":"The allowed arguments for the command execution."},"cmd":{"description":"The command name. It can start with a variable that resolves to a system base directory. The variables are: `$AUDIO`, `$CACHE`, `$CONFIG`, `$DATA`, `$LOCALDATA`, `$DESKTOP`, `$DOCUMENT`, `$DOWNLOAD`, `$EXE`, `$FONT`, `$HOME`, `$PICTURE`, `$PUBLIC`, `$RUNTIME`, `$TEMPLATE`, `$VIDEO`, `$RESOURCE`, `$LOG`, `$TEMP`, `$APPCONFIG`, `$APPDATA`, `$APPLOCALDATA`, `$APPCACHE`, `$APPLOG`.","type":"string"},"name":{"description":"The name for this allowed shell command configuration.\n\nThis name will be used inside of the webview API to call this command along with any specified arguments.","type":"string"}},"required":["cmd","name"],"type":"object"},{"additionalProperties":false,"properties":{"args":{"allOf":[{"$ref":"#/definitions/ShellScopeEntryAllowedArgs"}],"description":"The allowed arguments for the command execution."},"name":{"description":"The name for this allowed shell command configuration.\n\nThis name will be used inside of the webview API to call this command along with any specified arguments.","type":"string"},"sidecar":{"description":"If this command is a sidecar command.","type":"boolean"}},"required":["name","sidecar"],"type":"object"}],"definitions":{"ShellScopeEntryAllowedArg":{"anyOf":[{"description":"A non-configurable argument that is passed to the command in the order it was specified.","type":"string"},{"additionalProperties":false,"description":"A variable that is set while calling the command from the webview API.","properties":{"raw":{"default":false,"description":"Marks the validator as a raw regex, meaning the plugin should not make any modification at runtime.\n\nThis means the regex will not match on the entire string by default, which might be exploited if your regex allow unexpected input to be considered valid. When using this option, make sure your regex is correct.","type":"boolean"},"validator":{"description":"[regex] validator to require passed values to conform to an expected input.\n\nThis will require the argument value passed to this variable to match the `validator` regex before it will be executed.\n\nThe regex string is by default surrounded by `^...$` to match the full string. For example the `https?://\\w+` regex would be registered as `^https?://\\w+$`.\n\n[regex]: <https://docs.rs/regex/latest/regex/#syntax>","type":"string"}},"required":["validator"],"type":"object"}],"description":"A command argument allowed to be executed by the webview API."},"ShellScopeEntryAllowedArgs":{"anyOf":[{"description":"Use a simple boolean to allow all or disable all arguments to this command configuration.","type":"boolean"},{"description":"A specific set of [`ShellScopeEntryAllowedArg`] that are valid to call for the command configuration.","items":{"$ref":"#/definitions/ShellScopeEntryAllowedArg"},"type":"array"}],"description":"A set of command arguments allowed to be executed by the webview API.\n\nA value of `true` will allow any arguments to be passed to the command. `false` will disable all arguments. A list of [`ShellScopeEntryAllowedArg`] will set those arguments as the only valid arguments to be passed to the attached command configuration."}},"description":"Shell scope entry.","title":"ShellScopeEntry"}}}

--- FILE: src-tauri\gen\schemas\capabilities.json ---
{"main-capability":{"identifier":"main-capability","description":"PermissÃµes padrÃ£o para o AnimeHub","local":true,"windows":["main"],"permissions":["core:default","shell:allow-open","dialog:default",{"identifier":"fs:allow-read","allow":[{"path":"$HOME/**"}]},{"identifier":"fs:allow-write","allow":[{"path":"$HOME/**"}]},"fs:allow-exists","fs:allow-stat"]}}

--- FILE: src-tauri\schema.sql ---
-- AnimeHub Database Schema
-- SQLite 3.x
-- 
-- CRITICAL RULES:
-- 1. UUIDs stored as TEXT
-- 2. Timestamps in ISO 8601 UTC format
-- 3. Enums stored as TEXT with explicit values
-- 4. JSON for flexible/array data
-- 5. Foreign keys with explicit CASCADE behavior
-- 6. No implicit behavior - everything is visible

-- ============================================================================
-- SCHEMA VERSIONING
-- ============================================================================

CREATE TABLE IF NOT EXISTS schema_version (
    version INTEGER PRIMARY KEY,
    applied_at TEXT NOT NULL
);

-- ============================================================================
-- PRIMARY ENTITIES
-- ============================================================================

-- Anime: Root entity for Japanese animation works
CREATE TABLE anime (
    id TEXT PRIMARY KEY,
    titulo_principal TEXT NOT NULL CHECK(length(trim(titulo_principal)) > 0),
    titulos_alternativos TEXT NOT NULL, -- JSON array of strings
    tipo TEXT NOT NULL CHECK(tipo IN ('TV', 'Movie', 'OVA', 'Special')),
    status TEXT NOT NULL CHECK(status IN ('em_exibicao', 'finalizado', 'cancelado')),
    total_episodios INTEGER CHECK(total_episodios IS NULL OR total_episodios > 0),
    data_inicio TEXT, -- ISO 8601 or NULL
    data_fim TEXT,    -- ISO 8601 or NULL
    metadados_livres TEXT NOT NULL, -- JSON object
    criado_em TEXT NOT NULL,
    atualizado_em TEXT NOT NULL
);

CREATE INDEX idx_anime_tipo ON anime(tipo);
CREATE INDEX idx_anime_status ON anime(status);
CREATE INDEX idx_anime_atualizado ON anime(atualizado_em);

-- Episodes: Individual viewing units belonging to an Anime
CREATE TABLE episodes (
    id TEXT PRIMARY KEY,
    anime_id TEXT NOT NULL,
    numero_tipo TEXT NOT NULL CHECK(numero_tipo IN ('regular', 'special')),
    numero_valor TEXT NOT NULL, -- For regular: "1", "2", etc. For special: label
    titulo TEXT,
    duracao_esperada INTEGER CHECK(duracao_esperada IS NULL OR duracao_esperada > 0),
    progresso_atual INTEGER NOT NULL CHECK(progresso_atual >= 0),
    estado TEXT NOT NULL CHECK(estado IN ('nao_visto', 'em_progresso', 'concluido')),
    criado_em TEXT NOT NULL,
    atualizado_em TEXT NOT NULL,
    FOREIGN KEY (anime_id) REFERENCES anime(id) ON DELETE CASCADE
);

CREATE INDEX idx_episodes_anime ON episodes(anime_id);
CREATE INDEX idx_episodes_estado ON episodes(estado);
CREATE INDEX idx_episodes_numero ON episodes(anime_id, numero_tipo, numero_valor);

-- Files: Physical files on disk
CREATE TABLE files (
    id TEXT PRIMARY KEY,
    caminho_absoluto TEXT NOT NULL UNIQUE,
    tipo TEXT NOT NULL CHECK(tipo IN ('video', 'legenda', 'imagem', 'outro')),
    tamanho INTEGER NOT NULL CHECK(tamanho >= 0),
    hash TEXT,
    data_modificacao TEXT NOT NULL,
    origem TEXT NOT NULL CHECK(origem IN ('scan', 'importacao', 'manual')),
    criado_em TEXT NOT NULL,
    atualizado_em TEXT NOT NULL
);

CREATE INDEX idx_files_tipo ON files(tipo);
CREATE INDEX idx_files_caminho ON files(caminho_absoluto);

-- Episode-File association (N:M)
CREATE TABLE episode_files (
    episode_id TEXT NOT NULL,
    file_id TEXT NOT NULL,
    is_primary INTEGER NOT NULL CHECK(is_primary IN (0, 1)),
    criado_em TEXT NOT NULL,
    PRIMARY KEY (episode_id, file_id),
    FOREIGN KEY (episode_id) REFERENCES episodes(id) ON DELETE CASCADE,
    FOREIGN KEY (file_id) REFERENCES files(id) ON DELETE CASCADE
);

CREATE INDEX idx_episode_files_episode ON episode_files(episode_id);
CREATE INDEX idx_episode_files_file ON episode_files(file_id);
CREATE INDEX idx_episode_files_primary ON episode_files(episode_id, is_primary);

-- Subtitles: Transformable subtitle data
CREATE TABLE subtitles (
    id TEXT PRIMARY KEY,
    file_id TEXT NOT NULL,
    formato TEXT NOT NULL CHECK(formato IN ('SRT', 'ASS', 'VTT')),
    idioma TEXT NOT NULL CHECK(length(trim(idioma)) > 0),
    versao INTEGER NOT NULL CHECK(versao > 0),
    eh_original INTEGER NOT NULL CHECK(eh_original IN (0, 1)),
    criado_em TEXT NOT NULL,
    FOREIGN KEY (file_id) REFERENCES files(id) ON DELETE CASCADE
);

CREATE INDEX idx_subtitles_file ON subtitles(file_id);
CREATE INDEX idx_subtitles_idioma ON subtitles(idioma);
CREATE INDEX idx_subtitles_original ON subtitles(eh_original);

-- Subtitle transformations: History of subtitle modifications
CREATE TABLE subtitle_transformations (
    id TEXT PRIMARY KEY,
    subtitle_id_origem TEXT NOT NULL,
    tipo TEXT NOT NULL CHECK(tipo IN ('style', 'timing', 'conversao')),
    parametros_aplicados TEXT NOT NULL, -- JSON object
    criado_em TEXT NOT NULL,
    FOREIGN KEY (subtitle_id_origem) REFERENCES subtitles(id) ON DELETE CASCADE
);

CREATE INDEX idx_subtitle_transformations_origem ON subtitle_transformations(subtitle_id_origem);
CREATE INDEX idx_subtitle_transformations_tipo ON subtitle_transformations(tipo);

-- Collections: User-defined organizational groups
CREATE TABLE collections (
    id TEXT PRIMARY KEY,
    nome TEXT NOT NULL CHECK(length(trim(nome)) > 0),
    descricao TEXT,
    criado_em TEXT NOT NULL
);

-- Anime-Collection association (N:M)
CREATE TABLE anime_collections (
    anime_id TEXT NOT NULL,
    collection_id TEXT NOT NULL,
    criado_em TEXT NOT NULL,
    PRIMARY KEY (anime_id, collection_id),
    FOREIGN KEY (anime_id) REFERENCES anime(id) ON DELETE CASCADE,
    FOREIGN KEY (collection_id) REFERENCES collections(id) ON DELETE CASCADE
);

CREATE INDEX idx_anime_collections_anime ON anime_collections(anime_id);
CREATE INDEX idx_anime_collections_collection ON anime_collections(collection_id);

-- ============================================================================
-- RELATIONSHIPS & AUXILIARY ENTITIES
-- ============================================================================

-- External references: Links to external services (AniList, etc.)
CREATE TABLE external_references (
    id TEXT PRIMARY KEY,
    anime_id TEXT NOT NULL,
    fonte TEXT NOT NULL CHECK(length(trim(fonte)) > 0),
    external_id TEXT NOT NULL CHECK(length(trim(external_id)) > 0),
    criado_em TEXT NOT NULL,
    UNIQUE(anime_id, fonte),
    FOREIGN KEY (anime_id) REFERENCES anime(id) ON DELETE CASCADE
);

CREATE INDEX idx_external_references_anime ON external_references(anime_id);
CREATE INDEX idx_external_references_fonte ON external_references(fonte);
CREATE INDEX idx_external_references_external_id ON external_references(external_id);

-- Anime aliases: Tracks merge history
CREATE TABLE anime_aliases (
    id TEXT PRIMARY KEY,
    anime_principal_id TEXT NOT NULL,
    anime_alias_id TEXT NOT NULL,
    criado_em TEXT NOT NULL,
    UNIQUE(anime_alias_id),
    FOREIGN KEY (anime_principal_id) REFERENCES anime(id) ON DELETE CASCADE,
    FOREIGN KEY (anime_alias_id) REFERENCES anime(id) ON DELETE CASCADE,
    CHECK(anime_principal_id != anime_alias_id)
);

CREATE INDEX idx_anime_aliases_principal ON anime_aliases(anime_principal_id);
CREATE INDEX idx_anime_aliases_alias ON anime_aliases(anime_alias_id);

-- ============================================================================
-- DERIVED DATA (NOT SOURCE OF TRUTH)
-- ============================================================================

-- âš ï¸ DERIVED DATA - CAN BE DELETED WITHOUT AFFECTING DOMAINS
-- Statistics snapshots: Cached aggregate data
CREATE TABLE statistics_snapshots (
    id TEXT PRIMARY KEY,
    tipo TEXT NOT NULL, -- "global", "por_anime:{uuid}", "por_periodo:{start}:{end}"
    valor TEXT NOT NULL, -- JSON snapshot
    gerado_em TEXT NOT NULL
);

CREATE INDEX idx_statistics_tipo ON statistics_snapshots(tipo);
CREATE INDEX idx_statistics_gerado ON statistics_snapshots(gerado_em);

-- ============================================================================
-- EVENT STORE (OPTIONAL - APPEND-ONLY AUDIT LOG)
-- ============================================================================

-- Domain events: Immutable event log for debugging/audit
CREATE TABLE domain_events (
    event_id TEXT PRIMARY KEY,
    event_type TEXT NOT NULL,
    payload TEXT NOT NULL, -- JSON
    occurred_at TEXT NOT NULL
);

CREATE INDEX idx_domain_events_type ON domain_events(event_type);
CREATE INDEX idx_domain_events_occurred ON domain_events(occurred_at);

-- ============================================================================
-- CONSTRAINTS & VALIDATION
-- ============================================================================

-- Ensure progress never exceeds duration (when known)
-- This is a database-level safety check, NOT business logic
-- The domain should prevent this from ever being violated
CREATE TRIGGER check_episode_progress_invariant
BEFORE UPDATE ON episodes
FOR EACH ROW
WHEN NEW.duracao_esperada IS NOT NULL AND NEW.progresso_atual > NEW.duracao_esperada
BEGIN
    SELECT RAISE(ABORT, 'INVARIANT VIOLATION: Progress exceeds duration');
END;

-- Ensure anime dates are logical (if both present)
CREATE TRIGGER check_anime_dates_invariant
BEFORE UPDATE ON anime
FOR EACH ROW
WHEN NEW.data_inicio IS NOT NULL AND NEW.data_fim IS NOT NULL AND NEW.data_inicio > NEW.data_fim
BEGIN
    SELECT RAISE(ABORT, 'INVARIANT VIOLATION: Start date after end date');
END;

-- ============================================================================
-- INITIAL DATA
-- ============================================================================

-- Insert initial schema version
INSERT OR IGNORE INTO schema_version (version, applied_at)
VALUES (1, datetime('now'));

--- FILE: src-tauri\src\application\commands\anime_commands.rs ---
// src-tauri/src/application/commands/anime_commands.rs
//
// Anime Command Handlers
//
// RULES:
// - Accept DTOs
// - Call sealed services
// - Return DTOs
// - Never contain business logic

use tauri::State;
use uuid::Uuid;
use chrono::DateTime;

use crate::application::{
    state::AppState,
    dto::*,
};
use crate::services::*;
use crate::domain::{AnimeType, AnimeStatus};

/// List all animes
#[tauri::command]
pub async fn list_animes(state: State<'_, AppState>) -> Result<Vec<AnimeDto>, String> {
    let animes = state.anime_service
        .list_all_animes()
        .map_err(|e| e.to_string())?;
    
    Ok(animes.into_iter().map(AnimeDto::from).collect())
}

/// Get a single anime by ID
#[tauri::command]
pub async fn get_anime(
    anime_id: String,
    state: State<'_, AppState>
) -> Result<Option<AnimeDto>, String> {
    let id = Uuid::parse_str(&anime_id)
        .map_err(|e| format!("Invalid UUID: {}", e))?;
    
    let anime = state.anime_service
        .get_anime(id)
        .map_err(|e| e.to_string())?;
    
    Ok(anime.map(AnimeDto::from))
}

/// Create a new anime
#[tauri::command]
pub async fn create_anime(
    dto: CreateAnimeDto,
    state: State<'_, AppState>
) -> Result<String, String> {
    // Parse type
    let tipo = match dto.tipo.as_str() {
        "TV" => AnimeType::TV,
        "Movie" => AnimeType::Movie,
        "OVA" => AnimeType::OVA,
        "Special" => AnimeType::Special,
        _ => return Err("Invalid anime type".to_string()),
    };
    
    // Parse status
    let status = match dto.status.as_str() {
        "em_exibicao" => AnimeStatus::EmExibicao,
        "finalizado" => AnimeStatus::Finalizado,
        "cancelado" => AnimeStatus::Cancelado,
        _ => return Err("Invalid status".to_string()),
    };
    
    // Parse dates
    let data_inicio = dto.data_inicio
        .map(|s| DateTime::parse_from_rfc3339(&s))
        .transpose()
        .map_err(|e| format!("Invalid start date: {}", e))?
        .map(|dt| dt.with_timezone(&chrono::Utc));
    
    let data_fim = dto.data_fim
        .map(|s| DateTime::parse_from_rfc3339(&s))
        .transpose()
        .map_err(|e| format!("Invalid end date: {}", e))?
        .map(|dt| dt.with_timezone(&chrono::Utc));
    
    // Create request
    let request = CreateAnimeRequest {
        titulo_principal: dto.titulo_principal,
        titulos_alternativos: dto.titulos_alternativos,
        tipo,
        status,
        total_episodios: dto.total_episodios,
        data_inicio,
        data_fim,
        metadados_livres: dto.metadados_livres.unwrap_or(serde_json::Value::Object(serde_json::Map::new())),
    };
    
    let anime_id = state.anime_service
        .create_anime(request)
        .map_err(|e| e.to_string())?;
    
    Ok(anime_id.to_string())
}

/// Update an anime's metadata
#[tauri::command]
pub async fn update_anime(
    anime_id: String,
    titulo_principal: Option<String>,
    status: Option<String>,
    state: State<'_, AppState>
) -> Result<(), String> {
    let id = Uuid::parse_str(&anime_id)
        .map_err(|e| format!("Invalid UUID: {}", e))?;
    
    let parsed_status = status
        .map(|s| match s.as_str() {
            "em_exibicao" => Ok(AnimeStatus::EmExibicao),
            "finalizado" => Ok(AnimeStatus::Finalizado),
            "cancelado" => Ok(AnimeStatus::Cancelado),
            _ => Err("Invalid status".to_string()),
        })
        .transpose()?;
    
    let request = UpdateAnimeRequest {
        anime_id: id,
        titulo_principal,
        titulos_alternativos: None,
        tipo: None,
        status: parsed_status,
        total_episodios: None,
        data_inicio: None,
        data_fim: None,
        metadados_livres: None,
    };
    
    state.anime_service
        .update_anime(request)
        .map_err(|e| e.to_string())?;
    
    Ok(())
}

--- FILE: src-tauri\src\application\commands\episode_commands.rs ---
// src-tauri/src/application/commands/episode_commands.rs

use tauri::State;
use uuid::Uuid;

use crate::application::{
    state::AppState,
    dto::*,
};
use crate::services::*;
use crate::domain::EpisodeNumber;

/// List all episodes for an anime
#[tauri::command]
pub async fn list_episodes(
    anime_id: String,
    state: State<'_, AppState>
) -> Result<Vec<EpisodeDto>, String> {
    let id = Uuid::parse_str(&anime_id)
        .map_err(|e| format!("Invalid UUID: {}", e))?;
    
    let episodes = state.episode_service
        .list_episodes_for_anime(id)
        .map_err(|e| e.to_string())?;
    
    Ok(episodes.into_iter().map(EpisodeDto::from).collect())
}

/// Get a single episode by ID
#[tauri::command]
pub async fn get_episode(
    episode_id: String,
    state: State<'_, AppState>
) -> Result<Option<EpisodeDto>, String> {
    let id = Uuid::parse_str(&episode_id)
        .map_err(|e| format!("Invalid UUID: {}", e))?;
    
    let episode = state.episode_service
        .get_episode(id)
        .map_err(|e| e.to_string())?;
    
    Ok(episode.map(EpisodeDto::from))
}

/// Create a new episode
#[tauri::command]
pub async fn create_episode(
    dto: CreateEpisodeDto,
    state: State<'_, AppState>
) -> Result<String, String> {
    let anime_id = Uuid::parse_str(&dto.anime_id)
        .map_err(|e| format!("Invalid anime UUID: {}", e))?;
    
    let numero = match dto.numero_tipo.as_str() {
        "regular" => {
            let num: u32 = dto.numero.parse()
                .map_err(|e| format!("Invalid episode number: {}", e))?;
            EpisodeNumber::regular(num)
        },
        "special" => EpisodeNumber::special(dto.numero.clone()),
        _ => return Err("Invalid numero_tipo, must be 'regular' or 'special'".to_string()),
    };
    
    let request = CreateEpisodeRequest {
        anime_id,
        numero,
        titulo: dto.titulo,
        duracao_esperada: dto.duracao_esperada,
    };
    
    let episode_id = state.episode_service
        .create_episode(request)
        .map_err(|e| e.to_string())?;
    
    Ok(episode_id.to_string())
}

/// Update episode progress
#[tauri::command]
pub async fn update_progress(
    dto: UpdateProgressDto,
    state: State<'_, AppState>
) -> Result<(), String> {
    let episode_id = Uuid::parse_str(&dto.episode_id)
        .map_err(|e| format!("Invalid UUID: {}", e))?;
    
    state.episode_service
        .update_progress(episode_id, dto.progress_seconds)
        .map_err(|e| e.to_string())?;
    
    Ok(())
}

/// Mark episode as completed
#[tauri::command]
pub async fn mark_episode_completed(
    episode_id: String,
    state: State<'_, AppState>
) -> Result<(), String> {
    let id = Uuid::parse_str(&episode_id)
        .map_err(|e| format!("Invalid UUID: {}", e))?;
    
    state.episode_service
        .mark_completed(id)
        .map_err(|e| e.to_string())?;
    
    Ok(())
}

/// Reset episode progress
#[tauri::command]
pub async fn reset_episode_progress(
    episode_id: String,
    state: State<'_, AppState>
) -> Result<(), String> {
    let id = Uuid::parse_str(&episode_id)
        .map_err(|e| format!("Invalid UUID: {}", e))?;
    
    state.episode_service
        .reset_progress(id)
        .map_err(|e| e.to_string())?;
    
    Ok(())
}

--- FILE: src-tauri\src\application\commands\file_commands.rs ---
// src-tauri/src/application/commands/file_commands.rs

use tauri::State;
use std::path::PathBuf;

use crate::application::{
    state::AppState,
    dto::*,
};

/// Scan a directory for video and subtitle files
#[tauri::command]
pub async fn scan_directory(
    dto: ScanDirectoryDto,
    state: State<'_, AppState>
) -> Result<usize, String> {
    let path = PathBuf::from(dto.directory_path);
    
    let files_found = state.file_service
        .scan_directory(path)
        .map_err(|e| e.to_string())?;
    
    Ok(files_found)
}

/// Get linked files for an episode
#[tauri::command]
pub async fn get_episode_files(
    episode_id: String,
    state: State<'_, AppState>
) -> Result<Vec<String>, String> {
    let id = uuid::Uuid::parse_str(&episode_id)
        .map_err(|e| format!("Invalid UUID: {}", e))?;
    
    let linked_files = state.episode_service
        .get_linked_files(id)
        .map_err(|e| e.to_string())?;
    
    Ok(linked_files.into_iter().map(|(file_id, _)| file_id.to_string()).collect())
}

--- FILE: src-tauri\src\application\commands\mod.rs ---
// src-tauri/src/application/commands/mod.rs
//
// Tauri Command Handlers
//
// ARCHITECTURE:
// - Commands are thin adapters between UI and Services
// - Commands accept DTOs, return DTOs
// - Commands handle error conversion for Tauri
// - Commands NEVER contain business logic

pub mod anime_commands;
pub mod episode_commands;
pub mod file_commands;
pub mod playback_commands;
pub mod statistics_commands;

pub use anime_commands::*;
pub use episode_commands::*;
pub use file_commands::*;
pub use playback_commands::*;
pub use statistics_commands::*;

--- FILE: src-tauri\src\application\commands\playback_commands.rs ---
// src-tauri/src/application/commands/playback_commands.rs

use tauri::State;
use uuid::Uuid;

use crate::application::state::AppState;
use crate::services::{PlaybackService, StartPlaybackRequest};

#[tauri::command]
pub async fn start_playback(
    state: State<'_, AppState>,
    episode_id: Uuid,
    file_id: Option<Uuid>,
) -> Result<String, String> {
    let playback_service: std::sync::Arc<PlaybackService> = state.playback_service.clone();

    let request = StartPlaybackRequest {
        episode_id,
        file_id,
    };

    let file_path = playback_service
        .start_playback(request)
        .map_err(|e| e.to_string())?;

    Ok(file_path.to_string_lossy().to_string())
}

#[tauri::command]
pub async fn toggle_pause_playback(state: State<'_, AppState>) -> Result<(), String> {
    let playback_service: std::sync::Arc<PlaybackService> = state.playback_service.clone();

    playback_service
        .toggle_pause()
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn seek_playback(
    state: State<'_, AppState>,
    episode_id: Uuid,
    position_seconds: u64,
) -> Result<(), String> {
    let playback_service: std::sync::Arc<PlaybackService> = state.playback_service.clone();

    playback_service
        .seek_to(episode_id, position_seconds)
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn stop_playback(
    state: State<'_, AppState>,
    episode_id: Uuid,
) -> Result<(), String> {
    let playback_service: std::sync::Arc<PlaybackService> = state.playback_service.clone();

    playback_service
        .stop_playback(episode_id)
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn get_episode_progress(
    state: State<'_, AppState>,
    episode_id: Uuid,
) -> Result<u64, String> {
    let playback_service: std::sync::Arc<PlaybackService> = state.playback_service.clone();

    playback_service
        .get_current_position(episode_id)
        .map_err(|e| e.to_string())
}

--- FILE: src-tauri\src\application\commands\statistics_commands.rs ---
// src-tauri/src/application/commands/statistics_commands.rs

use tauri::State;

use crate::application::{
    state::AppState,
    dto::*,
};

/// Get global statistics
#[tauri::command]
pub async fn get_global_statistics(
    state: State<'_, AppState>
) -> Result<GlobalStatisticsDto, String> {
    let stats = state.statistics_service
        .calculate_global_statistics()
        .map_err(|e| e.to_string())?;
    
    Ok(GlobalStatisticsDto::from(stats))
}

--- FILE: src-tauri\src\application\dto\mod.rs ---
// src-tauri/src/application/dto/mod.rs
//
// Data Transfer Objects
//
// CRITICAL PRINCIPLES:
// - DTOs are UI-friendly representations
// - DTOs NEVER leak domain invariants
// - DTOs are simple, serializable structs
// - Conversion FROM domain entities only (never TO)

use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

// ============================================================================
// ANIME DTOs
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnimeDto {
    pub id: String,
    pub titulo_principal: String,
    pub titulos_alternativos: Vec<String>,
    pub tipo: String,
    pub status: String,
    pub total_episodios: Option<u32>,
    pub data_inicio: Option<String>,
    pub data_fim: Option<String>,
    pub metadados_livres: serde_json::Value,
    pub criado_em: String,
    pub atualizado_em: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateAnimeDto {
    pub titulo_principal: String,
    pub titulos_alternativos: Vec<String>,
    pub tipo: String,
    pub status: String,
    pub total_episodios: Option<u32>,
    pub data_inicio: Option<String>,
    pub data_fim: Option<String>,
    pub metadados_livres: Option<serde_json::Value>,
}

// ============================================================================
// EPISODE DTOs
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EpisodeDto {
    pub id: String,
    pub anime_id: String,
    pub numero: String,
    pub titulo: Option<String>,
    pub duracao_esperada: Option<u64>,
    pub progresso_atual: u64,
    pub estado: String,
    pub criado_em: String,
    pub atualizado_em: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateEpisodeDto {
    pub anime_id: String,
    pub numero: String,
    pub numero_tipo: String, // "regular" or "special"
    pub titulo: Option<String>,
    pub duracao_esperada: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateProgressDto {
    pub episode_id: String,
    pub progress_seconds: u64,
}

// ============================================================================
// FILE DTOs
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileDto {
    pub id: String,
    pub caminho_absoluto: String,
    pub tipo: String,
    pub tamanho: u64,
    pub hash: Option<String>,
    pub data_modificacao: String,
    pub origem: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanDirectoryDto {
    pub directory_path: String,
}

// ============================================================================
// PLAYBACK DTOs
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StartPlaybackDto {
    pub episode_id: String,
    pub file_id: Option<String>,
    pub start_position: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackStatusDto {
    pub episode_id: String,
    pub current_position: u64,
    pub is_playing: bool,
}

// ============================================================================
// STATISTICS DTOs
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GlobalStatisticsDto {
    pub total_animes: u32,
    pub total_episodes: u32,
    pub episodes_assistidos: u32,
    pub tempo_total_assistido: u64,
    pub animes_em_progresso: u32,
    pub animes_completos: u32,
}

// ============================================================================
// RESPONSE DTOs
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuccessResponse<T> {
    pub success: bool,
    pub data: T,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorResponse {
    pub success: bool,
    pub error: String,
}

impl<T> SuccessResponse<T> {
    pub fn new(data: T) -> Self {
        Self {
            success: true,
            data,
        }
    }
}

impl ErrorResponse {
    pub fn new(error: String) -> Self {
        Self {
            success: false,
            error,
        }
    }
}

// ============================================================================
// CONVERSION HELPERS (Domain â†’ DTO)
// ============================================================================

impl From<crate::domain::Anime> for AnimeDto {
    fn from(anime: crate::domain::Anime) -> Self {
        Self {
            id: anime.id.to_string(),
            titulo_principal: anime.titulo_principal,
            titulos_alternativos: anime.titulos_alternativos,
            tipo: anime.tipo.to_string(),
            status: anime.status.to_string(),
            total_episodios: anime.total_episodios,
            data_inicio: anime.data_inicio.map(|d| d.to_rfc3339()),
            data_fim: anime.data_fim.map(|d| d.to_rfc3339()),
            metadados_livres: anime.metadados_livres,
            criado_em: anime.criado_em.to_rfc3339(),
            atualizado_em: anime.atualizado_em.to_rfc3339(),
        }
    }
}

impl From<crate::domain::Episode> for EpisodeDto {
    fn from(episode: crate::domain::Episode) -> Self {
        Self {
            id: episode.id.to_string(),
            anime_id: episode.anime_id.to_string(),
            numero: episode.numero.to_string(),
            titulo: episode.titulo,
            duracao_esperada: episode.duracao_esperada,
            progresso_atual: episode.progresso_atual,
            estado: episode.estado.to_string(),
            criado_em: episode.criado_em.to_rfc3339(),
            atualizado_em: episode.atualizado_em.to_rfc3339(),
        }
    }
}

impl From<crate::domain::File> for FileDto {
    fn from(file: crate::domain::File) -> Self {
        Self {
            id: file.id.to_string(),
            caminho_absoluto: file.caminho_absoluto.to_string_lossy().to_string(),
            tipo: file.tipo.to_string(),
            tamanho: file.tamanho,
            hash: file.hash,
            data_modificacao: file.data_modificacao.to_rfc3339(),
            origem: file.origem.to_string(),
        }
    }
}

impl From<crate::domain::GlobalStatistics> for GlobalStatisticsDto {
    fn from(stats: crate::domain::GlobalStatistics) -> Self {
        Self {
            total_animes: stats.total_animes,
            total_episodes: stats.total_episodes,
            episodes_assistidos: stats.episodes_assistidos,
            tempo_total_assistido: stats.tempo_total_assistido,
            animes_em_progresso: stats.animes_em_progresso,
            animes_completos: stats.animes_completos,
        }
    }
}

--- FILE: src-tauri\src\application\error_handling.rs ---
// src-tauri/src/application/error_handling.rs
//
// Enhanced Error Handling for Commands
//
// ARCHITECTURE:
// - Maps internal errors â†’ user-friendly responses
// - Provides consistent error format for UI
// - Never exposes internal implementation details
// - Logs errors for debugging

use serde::{Serialize, Deserialize};
use crate::error::AppError;

/// Standard error response for UI
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorResponse {
    pub success: bool,
    pub error_type: ErrorType,
    pub message: String,
    pub details: Option<String>,
}

/// Error categories for UI
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ErrorType {
    /// Resource not found (404)
    NotFound,
    
    /// Invalid input/validation error (400)
    Validation,
    
    /// Domain invariant violation (422)
    DomainError,
    
    /// Database/persistence error (500)
    Database,
    
    /// External service error (502)
    ExternalService,
    
    /// File system error (500)
    FileSystem,
    
    /// Other/unknown error (500)
    Internal,
}

impl ErrorResponse {
    /// Create error response from AppError
    pub fn from_app_error(error: AppError) -> Self {
        match error {
            AppError::NotFound => Self {
                success: false,
                error_type: ErrorType::NotFound,
                message: "Resource not found".to_string(),
                details: None,
            },
            
            AppError::Domain(domain_error) => Self {
                success: false,
                error_type: ErrorType::DomainError,
                message: "Domain validation failed".to_string(),
                details: Some(domain_error.to_string()),
            },
            
            AppError::Database(db_error) => {
                // Log full error for debugging
                eprintln!("Database error: {:?}", db_error);
                
                Self {
                    success: false,
                    error_type: ErrorType::Database,
                    message: "Database operation failed".to_string(),
                    details: Some("Check logs for details".to_string()),
                }
            },
            
            AppError::Serialization(serde_error) => {
                eprintln!("Serialization error: {:?}", serde_error);
                
                Self {
                    success: false,
                    error_type: ErrorType::Internal,
                    message: "Data serialization failed".to_string(),
                    details: None,
                }
            },
            
            AppError::Io(io_error) => {
                eprintln!("IO error: {:?}", io_error);
                
                Self {
                    success: false,
                    error_type: ErrorType::FileSystem,
                    message: "File system operation failed".to_string(),
                    details: Some(io_error.to_string()),
                }
            },
            
            AppError::Pool(pool_error) => {
                eprintln!("Connection pool error: {}", pool_error);
                
                Self {
                    success: false,
                    error_type: ErrorType::Database,
                    message: "Database connection failed".to_string(),
                    details: None,
                }
            },
            
            AppError::Other(message) => {
                // Check if it's an external service error
                if message.contains("AniList") || message.contains("MPV") {
                    Self {
                        success: false,
                        error_type: ErrorType::ExternalService,
                        message: "External service error".to_string(),
                        details: Some(message),
                    }
                } else {
                    eprintln!("Other error: {}", message);
                    
                    Self {
                        success: false,
                        error_type: ErrorType::Internal,
                        message,
                        details: None,
                    }
                }
            },
        }
    }
    
    /// Create validation error
    pub fn validation(message: String) -> Self {
        Self {
            success: false,
            error_type: ErrorType::Validation,
            message,
            details: None,
        }
    }
    
    /// Create not found error
    pub fn not_found(resource: &str) -> Self {
        Self {
            success: false,
            error_type: ErrorType::NotFound,
            message: format!("{} not found", resource),
            details: None,
        }
    }
}

/// Helper trait to convert Results to ErrorResponse
pub trait ToErrorResponse<T> {
    fn to_error_response(self) -> Result<T, String>;
}

impl<T> ToErrorResponse<T> for Result<T, AppError> {
    fn to_error_response(self) -> Result<T, String> {
        self.map_err(|e| {
            let error_response = ErrorResponse::from_app_error(e);
            serde_json::to_string(&error_response)
                .unwrap_or_else(|_| "Internal error".to_string())
        })
    }
}

/// Macro to wrap command results with error handling
#[macro_export]
macro_rules! handle_command {
    ($expr:expr) => {
        match $expr {
            Ok(value) => Ok(value),
            Err(e) => {
                let error_response = ErrorResponse::from_app_error(e);
                Err(serde_json::to_string(&error_response)
                    .unwrap_or_else(|_| "Internal error".to_string()))
            }
        }
    };
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_not_found_error() {
        let error = ErrorResponse::from_app_error(AppError::NotFound);
        assert_eq!(error.error_type, ErrorType::NotFound);
        assert_eq!(error.message, "Resource not found");
    }
    
    #[test]
    fn test_validation_error() {
        let error = ErrorResponse::validation("Invalid input".to_string());
        assert_eq!(error.error_type, ErrorType::Validation);
        assert_eq!(error.message, "Invalid input");
    }
    
    #[test]
    fn test_serialization() {
        let error = ErrorResponse::not_found("Anime");
        let json = serde_json::to_string(&error).unwrap();
        assert!(json.contains("not_found"));
        assert!(json.contains("Anime not found"));
    }
}

--- FILE: src-tauri\src\application\mod.rs ---
// src-tauri/src/application/mod.rs
//
// Application Layer - Phase 4
//
// ARCHITECTURE:
// - This layer sits ABOVE the sealed foundation
// - It provides the boundary between UI (Tauri) and Domain (Services)
// - It never modifies sealed components
// - It translates between DTOs and domain entities

pub mod dto;
pub mod commands;
pub mod state;

pub use dto::*;
pub use commands::*;
pub use state::AppState;

--- FILE: src-tauri\src\application\state.rs ---
// src-tauri/src/application/state.rs
// CORRECTED VERSION

use std::sync::Arc;

use crate::events::EventBus;
use crate::services::{
    AnimeService, EpisodeService, FileService, PlaybackService,
    StatisticsService, ExternalIntegrationService, SubtitleService,
};

/// Application state managed by Tauri.
/// All fields are Arc-wrapped for thread-safe sharing across commands.
/// Services are initialized in main.rs and passed here.
pub struct AppState {
    pub event_bus: Arc<EventBus>,
    pub anime_service: Arc<AnimeService>,
    pub episode_service: Arc<EpisodeService>,
    pub file_service: Arc<FileService>,
    pub playback_service: Arc<PlaybackService>,
    pub statistics_service: Arc<StatisticsService>,
    pub external_integration_service: Arc<ExternalIntegrationService>,
    pub subtitle_service: Arc<SubtitleService>,
}


--- FILE: src-tauri\src\db\connection.rs ---
// src-tauri/src/db/connection.rs
//
// Database connection management
//
// PRINCIPLES:
// - Explicit connection pooling
// - No hidden connection creation
// - Clear error propagation
// - Thread-safe access

use r2d2::{Pool, PooledConnection};
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::Connection;
use std::path::PathBuf;

use crate::error::{AppError, AppResult};

/// Type alias for connection pool
pub type ConnectionPool = Pool<SqliteConnectionManager>;

/// Type alias for a pooled connection
pub type PooledConn = PooledConnection<SqliteConnectionManager>;

/// Get the database file path
/// 
/// Database is stored in the application data directory.
/// Path structure: {APP_DATA}/animehub/animehub.db
pub fn get_database_path() -> AppResult<PathBuf> {
    let app_data_dir = dirs::data_dir()
        .ok_or_else(|| AppError::Other("Could not determine app data directory".to_string()))?;
    
    let animehub_dir = app_data_dir.join("animehub");
    
    // Ensure directory exists
    std::fs::create_dir_all(&animehub_dir)
        .map_err(|e| AppError::Io(e))?;
    
    Ok(animehub_dir.join("animehub.db"))
}

/// Create a connection pool
/// 
/// Pool configuration:
/// - Max 15 connections (reasonable for desktop app)
/// - SQLite in WAL mode for better concurrency
/// - Foreign keys enabled
/// - Busy timeout set to avoid immediate errors
pub fn create_connection_pool() -> AppResult<ConnectionPool> {
    let db_path = get_database_path()?;
    
    let manager = SqliteConnectionManager::file(&db_path)
        .with_init(|conn| {
            // Enable foreign key support (not default in SQLite)
            conn.execute_batch(
                "PRAGMA foreign_keys = ON;
                 PRAGMA journal_mode = WAL;
                 PRAGMA synchronous = NORMAL;
                 PRAGMA busy_timeout = 5000;"
            )?;
            Ok(())
        });
    
    let pool = Pool::builder()
        .max_size(15)
        .build(manager)
        .map_err(|e| AppError::Other(format!("Failed to create connection pool: {}", e)))?;
    
    Ok(pool)
}

/// Get a connection from the pool
/// 
/// This is a convenience wrapper that provides better error messages.
pub fn get_connection(pool: &ConnectionPool) -> AppResult<PooledConn> {
    pool.get()
        .map_err(|e| AppError::Other(format!("Failed to get database connection: {}", e)))
}

/// Create a standalone connection (for testing)
/// 
/// This creates an in-memory database, useful for unit tests.
pub fn create_test_connection() -> AppResult<Connection> {
    let conn = Connection::open_in_memory()
        .map_err(AppError::Database)?;
    
    // Enable foreign keys
    conn.execute_batch(
        "PRAGMA foreign_keys = ON;"
    ).map_err(AppError::Database)?;
    
    Ok(conn)
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_database_path_creation() {
        let path = get_database_path().unwrap();
        assert!(path.ends_with("animehub/animehub.db"));
    }
    
    #[test]
    fn test_connection_pool_creation() {
        // This will create actual database file in app data
        let pool = create_connection_pool().unwrap();
        let conn = get_connection(&pool).unwrap();
        
        // Verify foreign keys are enabled
        let fk_enabled: i32 = conn
            .query_row("PRAGMA foreign_keys", [], |row| row.get(0))
            .unwrap();
        assert_eq!(fk_enabled, 1);
    }
    
    #[test]
    fn test_test_connection() {
        let conn = create_test_connection().unwrap();
        
        // Verify it's a working connection
        let result: i32 = conn
            .query_row("SELECT 1 + 1", [], |row| row.get(0))
            .unwrap();
        assert_eq!(result, 2);
        
        // Verify foreign keys are enabled
        let fk_enabled: i32 = conn
            .query_row("PRAGMA foreign_keys", [], |row| row.get(0))
            .unwrap();
        assert_eq!(fk_enabled, 1);
    }
}

--- FILE: src-tauri\src\db\migrations.rs ---
// src-tauri/src/db/migrations.rs
//
// Database schema initialization and migrations
//
// PRINCIPLES:
// - Explicit schema versions
// - No automatic migrations
// - Clear error messages
// - Idempotent operations

use rusqlite::Connection;
use crate::error::{AppError, AppResult};

/// Current schema version
/// Increment this when adding migrations
const CURRENT_SCHEMA_VERSION: i32 = 1;

/// Initialize the database schema
/// 
/// This function:
/// 1. Checks current schema version
/// 2. Applies necessary migrations
/// 3. Updates version tracking
/// 
/// Safe to call multiple times (idempotent).
pub fn initialize_database(conn: &Connection) -> AppResult<()> {
    let current_version = get_schema_version(conn)?;
    
    if current_version == 0 {
        // Fresh database - apply initial schema
        apply_initial_schema(conn)?;
        set_schema_version(conn, 1)?;
    } else if current_version < CURRENT_SCHEMA_VERSION {
        // Future: apply incremental migrations here
        // For now, we only have version 1
        return Err(AppError::Other(
            format!("Schema version {} is outdated. Expected {}. Manual migration required.",
                current_version, CURRENT_SCHEMA_VERSION)
        ));
    } else if current_version > CURRENT_SCHEMA_VERSION {
        return Err(AppError::Other(
            format!("Schema version {} is newer than supported {}. Update the application.",
                current_version, CURRENT_SCHEMA_VERSION)
        ));
    }
    
    Ok(())
}

/// Get current schema version
/// Returns 0 if schema_version table doesn't exist (fresh database)
fn get_schema_version(conn: &Connection) -> AppResult<i32> {
    // Check if schema_version table exists
    let table_exists: bool = conn
        .query_row(
            "SELECT EXISTS(SELECT 1 FROM sqlite_master WHERE type='table' AND name='schema_version')",
            [],
            |row| row.get(0)
        )
        .map_err(AppError::Database)?;
    
    if !table_exists {
        return Ok(0);
    }
    
    // Get the highest version number
    let version: Option<i32> = conn
        .query_row(
            "SELECT MAX(version) FROM schema_version",
            [],
            |row| row.get(0)
        )
        .map_err(AppError::Database)?;
    
    Ok(version.unwrap_or(0))
}

/// Set schema version
fn set_schema_version(conn: &Connection, version: i32) -> AppResult<()> {
    conn.execute(
        "INSERT OR IGNORE INTO schema_version (version, applied_at) VALUES (?1, datetime('now'))",
        [version]
    ).map_err(AppError::Database)?;
    
    Ok(())
}

/// Apply initial schema (version 1)
/// 
/// This includes all tables defined in schema.sql
fn apply_initial_schema(conn: &Connection) -> AppResult<()> {
    // Read schema from embedded file
    let schema = include_str!("../../schema.sql");
    
    // Execute as batch
    conn.execute_batch(schema)
        .map_err(|e| AppError::Other(format!("Failed to apply initial schema: {}", e)))?;
    
    Ok(())
}

/// Verify database integrity
/// 
/// Runs SQLite's integrity check. Should be called periodically.
pub fn verify_database_integrity(conn: &Connection) -> AppResult<()> {
    let result: String = conn
        .query_row("PRAGMA integrity_check", [], |row| row.get(0))
        .map_err(AppError::Database)?;
    
    if result != "ok" {
        return Err(AppError::Other(format!("Database integrity check failed: {}", result)));
    }
    
    Ok(())
}

/// Get database statistics
/// 
/// Returns useful info for debugging and monitoring
pub fn get_database_stats(conn: &Connection) -> AppResult<DatabaseStats> {
    let page_count: i64 = conn
        .query_row("PRAGMA page_count", [], |row| row.get(0))
        .map_err(AppError::Database)?;
    
    let page_size: i64 = conn
        .query_row("PRAGMA page_size", [], |row| row.get(0))
        .map_err(AppError::Database)?;
    
    let size_bytes = page_count * page_size;
    
    // Get row counts for main tables
    let anime_count: i64 = conn
        .query_row("SELECT COUNT(*) FROM anime", [], |row| row.get(0))
        .unwrap_or(0);
    
    let episode_count: i64 = conn
        .query_row("SELECT COUNT(*) FROM episodes", [], |row| row.get(0))
        .unwrap_or(0);
    
    let file_count: i64 = conn
        .query_row("SELECT COUNT(*) FROM files", [], |row| row.get(0))
        .unwrap_or(0);
    
    Ok(DatabaseStats {
        size_bytes,
        page_count,
        page_size,
        anime_count,
        episode_count,
        file_count,
    })
}

/// Database statistics
#[derive(Debug)]
pub struct DatabaseStats {
    pub size_bytes: i64,
    pub page_count: i64,
    pub page_size: i64,
    pub anime_count: i64,
    pub episode_count: i64,
    pub file_count: i64,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::db::connection::create_test_connection;
    
    #[test]
    fn test_initialize_fresh_database() {
        let conn = create_test_connection().unwrap();
        
        // Should be version 0 initially
        let version = get_schema_version(&conn).unwrap();
        assert_eq!(version, 0);
        
        // Initialize
        initialize_database(&conn).unwrap();
        
        // Should now be version 1
        let version = get_schema_version(&conn).unwrap();
        assert_eq!(version, 1);
        
        // Verify tables exist
        let table_count: i64 = conn
            .query_row(
                "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'",
                [],
                |row| row.get(0)
            )
            .unwrap();
        
        assert!(table_count > 10, "Expected at least 10 tables, got {}", table_count);
    }
    
    #[test]
    fn test_initialize_idempotent() {
        let conn = create_test_connection().unwrap();
        
        // Initialize twice
        initialize_database(&conn).unwrap();
        initialize_database(&conn).unwrap();
        
        // Should still be version 1
        let version = get_schema_version(&conn).unwrap();
        assert_eq!(version, 1);
    }
    
    #[test]
    fn test_foreign_keys_enabled() {
        let conn = create_test_connection().unwrap();
        initialize_database(&conn).unwrap();
        
        // Try to insert episode without anime (should fail)
        let result = conn.execute(
            "INSERT INTO episodes (id, anime_id, numero_tipo, numero_valor, progresso_atual, estado, criado_em, atualizado_em)
             VALUES ('test-ep', 'nonexistent-anime', 'regular', '1', 0, 'nao_visto', datetime('now'), datetime('now'))",
            []
        );
        
        assert!(result.is_err(), "Foreign key constraint should have been violated");
    }
    
    #[test]
    fn test_database_stats() {
        let conn = create_test_connection().unwrap();
        initialize_database(&conn).unwrap();
        
        let stats = get_database_stats(&conn).unwrap();
        
        assert!(stats.size_bytes > 0);
        assert_eq!(stats.anime_count, 0);
        assert_eq!(stats.episode_count, 0);
        assert_eq!(stats.file_count, 0);
    }
    
    #[test]
    fn test_integrity_check() {
        let conn = create_test_connection().unwrap();
        initialize_database(&conn).unwrap();
        
        // Fresh database should pass integrity check
        verify_database_integrity(&conn).unwrap();
    }
}

--- FILE: src-tauri\src\db\mod.rs ---
// src-tauri/src/db/mod.rs
//
// Database module
//
// Provides:
// - Connection pooling
// - Schema migrations
// - Database utilities

pub mod connection;
pub mod migrations;

pub use connection::{
    ConnectionPool,
    PooledConn,
    create_connection_pool,
    get_connection,
    get_database_path,
};

pub use migrations::{
    initialize_database,
    verify_database_integrity,
    get_database_stats,
    DatabaseStats,
};

--- FILE: src-tauri\src\domain\anime\entity.rs ---
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Represents a Japanese anime work (TV, Movie, OVA, Special)
/// This is the root entity for all anime-related data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Anime {
    /// Internal immutable identifier
    pub id: Uuid,
    
    /// Primary title (usually Japanese)
    pub titulo_principal: String,
    
    /// Alternative titles (romaji, english, synonyms)
    pub titulos_alternativos: Vec<String>,
    
    /// Type of anime work
    pub tipo: AnimeType,
    
    /// Current status
    pub status: AnimeStatus,
    
    /// Total number of episodes (if known)
    pub total_episodios: Option<u32>,
    
    /// Start date (if known)
    pub data_inicio: Option<DateTime<Utc>>,
    
    /// End date (if known)
    pub data_fim: Option<DateTime<Utc>>,
    
    /// Free-form metadata (genres, studio, etc.)
    /// Stored as JSON internally
    pub metadados_livres: serde_json::Value,
    
    /// Creation timestamp
    pub criado_em: DateTime<Utc>,
    
    /// Last update timestamp
    pub atualizado_em: DateTime<Utc>,
}

/// Type of anime work
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
pub enum AnimeType {
    TV,
    Movie,
    OVA,
    Special,
}

/// Current status of the anime
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum AnimeStatus {
    EmExibicao,
    Finalizado,
    Cancelado,
}

impl Anime {
    /// Create a new Anime entity
    /// This is the only way to construct a valid Anime
    pub fn new(
        titulo_principal: String,
        tipo: AnimeType,
    ) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            titulo_principal,
            titulos_alternativos: Vec::new(),
            tipo,
            status: AnimeStatus::EmExibicao,
            total_episodios: None,
            data_inicio: None,
            data_fim: None,
            metadados_livres: serde_json::Value::Object(serde_json::Map::new()),
            criado_em: now,
            atualizado_em: now,
        }
    }
    
    /// Update metadata
    /// This preserves the creation timestamp and updates the modification timestamp
    pub fn update_metadata(
        &mut self,
        titulo_principal: Option<String>,
        titulos_alternativos: Option<Vec<String>>,
        tipo: Option<AnimeType>,
        status: Option<AnimeStatus>,
        total_episodios: Option<Option<u32>>,
        data_inicio: Option<Option<DateTime<Utc>>>,
        data_fim: Option<Option<DateTime<Utc>>>,
        metadados_livres: Option<serde_json::Value>,
    ) {
        if let Some(titulo) = titulo_principal {
            self.titulo_principal = titulo;
        }
        if let Some(titulos) = titulos_alternativos {
            self.titulos_alternativos = titulos;
        }
        if let Some(t) = tipo {
            self.tipo = t;
        }
        if let Some(s) = status {
            self.status = s;
        }
        if let Some(total) = total_episodios {
            self.total_episodios = total;
        }
        if let Some(inicio) = data_inicio {
            self.data_inicio = inicio;
        }
        if let Some(fim) = data_fim {
            self.data_fim = fim;
        }
        if let Some(meta) = metadados_livres {
            self.metadados_livres = meta;
        }
        
        self.atualizado_em = Utc::now();
    }
}

impl std::fmt::Display for AnimeType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnimeType::TV => write!(f, "TV"),
            AnimeType::Movie => write!(f, "Movie"),
            AnimeType::OVA => write!(f, "OVA"),
            AnimeType::Special => write!(f, "Special"),
        }
    }
}

impl std::fmt::Display for AnimeStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnimeStatus::EmExibicao => write!(f, "em_exibicao"),
            AnimeStatus::Finalizado => write!(f, "finalizado"),
            AnimeStatus::Cancelado => write!(f, "cancelado"),
        }
    }
}

--- FILE: src-tauri\src\domain\anime\invariants.rs ---
use super::entity::Anime;
use crate::domain::{DomainError, DomainResult};

/// Validates all Anime invariants
/// These are the absolute rules that must hold for an Anime to be valid
pub fn validate_anime(anime: &Anime) -> DomainResult<()> {
    validate_titulo_principal(&anime.titulo_principal)?;
    validate_dates(anime)?;
    Ok(())
}

/// Titulo principal cannot be empty
fn validate_titulo_principal(titulo: &str) -> DomainResult<()> {
    if titulo.trim().is_empty() {
        return Err(DomainError::InvariantViolation(
            "Anime title cannot be empty".to_string()
        ));
    }
    Ok(())
}

/// If both dates are present, start must be before or equal to end
fn validate_dates(anime: &Anime) -> DomainResult<()> {
    if let (Some(inicio), Some(fim)) = (anime.data_inicio, anime.data_fim) {
        if inicio > fim {
            return Err(DomainError::InvariantViolation(
                format!("Start date {:?} cannot be after end date {:?}", inicio, fim)
            ));
        }
    }
    Ok(())
}

/// Invariants that must hold true for Anime domain:
/// 
/// 1. Anime can exist without episodes
/// 2. Anime can exist without files
/// 3. Anime can exist without external references
/// 4. Identity (UUID) is immutable
/// 5. Duplicates are allowed until explicit resolution
/// 6. Title cannot be empty
/// 7. If both dates exist, start <= end
/// 8. Created timestamp never changes
/// 9. Updated timestamp reflects last modification

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::anime::{AnimeType, AnimeStatus};

    #[test]
    fn test_valid_anime() {
        let anime = Anime::new(
            "Steins;Gate".to_string(),
            AnimeType::TV,
        );
        assert!(validate_anime(&anime).is_ok());
    }

    #[test]
    fn test_empty_title_fails() {
        let anime = Anime::new(
            "   ".to_string(),
            AnimeType::TV,
        );
        assert!(validate_anime(&anime).is_err());
    }
}

--- FILE: src-tauri\src\domain\anime\mod.rs ---
pub mod entity;
pub mod invariants;

pub use entity::{Anime, AnimeType, AnimeStatus};
pub use invariants::validate_anime;

--- FILE: src-tauri\src\domain\anime_alias.rs ---
// src-tauri/src/domain/anime_alias.rs
//
// Anime Alias Entity
//
// Tracks merge history when duplicate animes are resolved
// Preserves historical relationships

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::domain::{DomainError, DomainResult};

/// Represents an alias relationship from anime merge
/// 
/// CRITICAL INVARIANTS:
/// - Never deleted (preserves history)
/// - One anime becomes "principal", other becomes "alias"
/// - Self-referential aliases are forbidden
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnimeAlias {
    /// Internal identifier
    pub id: Uuid,
    
    /// The principal (surviving) anime
    pub anime_principal_id: Uuid,
    
    /// The alias (merged into principal) anime
    pub anime_alias_id: Uuid,
    
    /// When this merge occurred
    pub criado_em: DateTime<Utc>,
}

impl AnimeAlias {
    /// Create a new anime alias relationship
    pub fn new(anime_principal_id: Uuid, anime_alias_id: Uuid) -> Result<Self, String> {
        if anime_principal_id == anime_alias_id {
            return Err("Anime cannot be an alias of itself".to_string());
        }
        
        Ok(Self {
            id: Uuid::new_v4(),
            anime_principal_id,
            anime_alias_id,
            criado_em: Utc::now(),
        })
    }
}

/// Validates AnimeAlias invariants
pub fn validate_anime_alias(alias: &AnimeAlias) -> DomainResult<()> {
    if alias.anime_principal_id == alias.anime_alias_id {
        return Err(DomainError::InvariantViolation(
            "Anime cannot be an alias of itself".to_string()
        ));
    }
    
    Ok(())
}

--- FILE: src-tauri\src\domain\collection\entity.rs ---
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Represents a user-defined collection of anime
/// Collections are purely organizational and do not affect anime state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Collection {
    /// Internal immutable identifier
    pub id: Uuid,
    
    /// Collection name
    pub nome: String,
    
    /// Optional description
    pub descricao: Option<String>,
    
    /// Creation timestamp
    pub criado_em: DateTime<Utc>,
}

impl Collection {
    /// Create a new Collection
    pub fn new(nome: String, descricao: Option<String>) -> Self {
        Self {
            id: Uuid::new_v4(),
            nome,
            descricao,
            criado_em: Utc::now(),
        }
    }
    
    /// Update collection metadata
    pub fn update(&mut self, nome: Option<String>, descricao: Option<Option<String>>) {
        if let Some(n) = nome {
            self.nome = n;
        }
        if let Some(d) = descricao {
            self.descricao = d;
        }
    }
}

impl std::fmt::Display for Collection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.nome)
    }
}

--- FILE: src-tauri\src\domain\collection\mod.rs ---
//! Critical Collection Invariants:
//! 
//! 1. Collections do NOT affect anime state
//! 2. Collections do NOT affect progress
//! 3. Collections are purely organizational
//! 4. Anime can belong to multiple collections
//! 5. Deleting a collection does NOT delete anime
//! 6. Collection name cannot be empty

pub mod entity;

pub use entity::Collection;

use crate::domain::{DomainError, DomainResult};

/// Validates Collection invariants
pub fn validate_collection(collection: &Collection) -> DomainResult<()> {
    if collection.nome.trim().is_empty() {
        return Err(DomainError::InvariantViolation(
            "Collection name cannot be empty".to_string()
        ));
    }
    Ok(())
}

--- FILE: src-tauri\src\domain\episode\entity.rs ---
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Represents a single episode belonging to an Anime
/// Episodes are the unit of viewing progress
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Episode {
    /// Internal immutable identifier
    pub id: Uuid,
    
    /// Reference to parent Anime (REQUIRED)
    pub anime_id: Uuid,
    
    /// Episode number (regular or special)
    pub numero: EpisodeNumber,
    
    /// Episode title (optional)
    pub titulo: Option<String>,
    
    /// Expected duration in seconds (optional)
    pub duracao_esperada: Option<u64>,
    
    /// Current playback progress in seconds
    pub progresso_atual: u64,
    
    /// Viewing state
    pub estado: EpisodeState,
    
    /// Creation timestamp
    pub criado_em: DateTime<Utc>,
    
    /// Last update timestamp
    pub atualizado_em: DateTime<Utc>,
}

/// Episode number can be regular (1, 2, 3...) or special (OVA, Special)
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum EpisodeNumber {
    Regular { numero: u32 },
    Special { label: String },
}

/// Current viewing state of an episode
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum EpisodeState {
    NaoVisto,
    EmProgresso,
    Concluido,
}

impl Episode {
    /// Create a new Episode
    /// anime_id MUST be valid (checked by caller)
    pub fn new(anime_id: Uuid, numero: EpisodeNumber) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            anime_id,
            numero,
            titulo: None,
            duracao_esperada: None,
            progresso_atual: 0,
            estado: EpisodeState::NaoVisto,
            criado_em: now,
            atualizado_em: now,
        }
    }
    
    /// Update episode metadata
    pub fn update_metadata(
        &mut self,
        titulo: Option<String>,
        duracao_esperada: Option<Option<u64>>,
    ) {
        if let Some(t) = titulo {
            self.titulo = Some(t);
        }
        if let Some(d) = duracao_esperada {
            self.duracao_esperada = d;
        }
        self.atualizado_em = Utc::now();
    }
    
    /// Update progress
    /// Returns error if progress violates invariants
    pub fn update_progress(&mut self, progresso: u64) -> Result<(), String> {
        // Progress cannot exceed duration (if known)
        if let Some(duracao) = self.duracao_esperada {
            if progresso > duracao {
                return Err(format!(
                    "Progress {} exceeds duration {}", 
                    progresso, 
                    duracao
                ));
            }
        }
        
        // Progress should not decrease (except explicit reset)
        if progresso < self.progresso_atual && progresso != 0 {
            // Allow reset to 0, but not arbitrary decreases
            return Err(format!(
                "Progress cannot decrease from {} to {} (use reset if intentional)",
                self.progresso_atual,
                progresso
            ));
        }
        
        self.progresso_atual = progresso;
        
        // Update state based on progress
        self.estado = if progresso == 0 {
            EpisodeState::NaoVisto
        } else if let Some(duracao) = self.duracao_esperada {
            if progresso >= (duracao * 90 / 100) {
                EpisodeState::Concluido
            } else {
                EpisodeState::EmProgresso
            }
        } else {
            EpisodeState::EmProgresso
        };
        
        self.atualizado_em = Utc::now();
        Ok(())
    }
    
    /// Mark as completed
    pub fn mark_completed(&mut self) {
        self.estado = EpisodeState::Concluido;
        if let Some(duracao) = self.duracao_esperada {
            self.progresso_atual = duracao;
        }
        self.atualizado_em = Utc::now();
    }
    
    /// Reset progress
    pub fn reset_progress(&mut self) {
        self.progresso_atual = 0;
        self.estado = EpisodeState::NaoVisto;
        self.atualizado_em = Utc::now();
    }
}

impl EpisodeNumber {
    pub fn regular(numero: u32) -> Self {
        Self::Regular { numero }
    }
    
    pub fn special(label: String) -> Self {
        Self::Special { label }
    }
}

impl std::fmt::Display for EpisodeNumber {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EpisodeNumber::Regular { numero } => write!(f, "{}", numero),
            EpisodeNumber::Special { label } => write!(f, "{}", label),
        }
    }
}

impl std::fmt::Display for EpisodeState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EpisodeState::NaoVisto => write!(f, "nao_visto"),
            EpisodeState::EmProgresso => write!(f, "em_progresso"),
            EpisodeState::Concluido => write!(f, "concluido"),
        }
    }
}

--- FILE: src-tauri\src\domain\episode\invariants.rs ---
use super::entity::Episode;
use crate::domain::{DomainError, DomainResult};

/// Validates all Episode invariants
pub fn validate_episode(episode: &Episode) -> DomainResult<()> {
    validate_progress(episode)?;
    Ok(())
}

/// Progress invariants:
/// 1. Progress cannot be negative (enforced by u64)
/// 2. Progress cannot exceed duration (if known)
fn validate_progress(episode: &Episode) -> DomainResult<()> {
    if let Some(duracao) = episode.duracao_esperada {
        if episode.progresso_atual > duracao {
            return Err(DomainError::ProgressExceedsDuration {
                progress: episode.progresso_atual,
                duration: duracao,
            });
        }
    }
    Ok(())
}

/// Critical Episode Invariants:
/// 
/// 1. Episode MUST belong to exactly one Anime (anime_id required)
/// 2. Episode can exist without a file
/// 3. Episode assumes one practical version (no implicit multi-version)
/// 4. Progress never decreases automatically
/// 5. Progress never exceeds duration (if known)
/// 6. State transitions are explicit
/// 7. Episode ID is immutable
/// 8. anime_id is immutable (episode cannot change parent)

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::episode::{Episode, EpisodeNumber};
    use uuid::Uuid;

    #[test]
    fn test_valid_episode() {
        let anime_id = Uuid::new_v4();
        let episode = Episode::new(anime_id, EpisodeNumber::regular(1));
        assert!(validate_episode(&episode).is_ok());
    }

    #[test]
    fn test_progress_within_duration() {
        let anime_id = Uuid::new_v4();
        let mut episode = Episode::new(anime_id, EpisodeNumber::regular(1));
        episode.duracao_esperada = Some(1440); // 24 minutes
        episode.progresso_atual = 1200; // 20 minutes
        assert!(validate_episode(&episode).is_ok());
    }

    #[test]
    fn test_progress_exceeds_duration_fails() {
        let anime_id = Uuid::new_v4();
        let mut episode = Episode::new(anime_id, EpisodeNumber::regular(1));
        episode.duracao_esperada = Some(1440);
        episode.progresso_atual = 1500; // Exceeds duration
        assert!(validate_episode(&episode).is_err());
    }
}

--- FILE: src-tauri\src\domain\episode\mod.rs ---
pub mod entity;
pub mod invariants;

pub use entity::{Episode, EpisodeNumber, EpisodeState};
pub use invariants::validate_episode;

--- FILE: src-tauri\src\domain\external_reference.rs ---
// src-tauri/src/domain/external_reference.rs
//
// External Reference Entity
//
// Links local anime to external services (AniList, etc.)
// These are auxiliary references, never authoritative.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::domain::{DomainError, DomainResult};

/// Represents a link to an external service
/// 
/// CRITICAL INVARIANTS:
/// - Never replaces local data
/// - Can be removed without structural impact
/// - Source never becomes authoritative
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExternalReference {
    /// Internal identifier
    pub id: Uuid,
    
    /// Local anime this references
    pub anime_id: Uuid,
    
    /// External service name (e.g., "AniList")
    pub fonte: String,
    
    /// ID in the external service
    pub external_id: String,
    
    /// When this reference was created
    pub criado_em: DateTime<Utc>,
}

impl ExternalReference {
    /// Create a new external reference
    pub fn new(anime_id: Uuid, fonte: String, external_id: String) -> Self {
        Self {
            id: Uuid::new_v4(),
            anime_id,
            fonte,
            external_id,
            criado_em: Utc::now(),
        }
    }
}

/// Validates ExternalReference invariants
pub fn validate_external_reference(reference: &ExternalReference) -> DomainResult<()> {
    if reference.fonte.trim().is_empty() {
        return Err(DomainError::InvariantViolation(
            "External reference source cannot be empty".to_string()
        ));
    }
    
    if reference.external_id.trim().is_empty() {
        return Err(DomainError::InvariantViolation(
            "External reference ID cannot be empty".to_string()
        ));
    }
    
    Ok(())
}

--- FILE: src-tauri\src\domain\file\entity.rs ---
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use uuid::Uuid;

/// Represents a physical file on disk
/// Files are observable entities, not controlled by the system
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct File {
    /// Internal immutable identifier
    pub id: Uuid,
    
    /// Absolute path to the file
    pub caminho_absoluto: PathBuf,
    
    /// Type of file
    pub tipo: FileType,
    
    /// File size in bytes
    pub tamanho: u64,
    
    /// SHA256 hash (optional, computed on demand)
    pub hash: Option<String>,
    
    /// Last modification timestamp from filesystem
    pub data_modificacao: DateTime<Utc>,
    
    /// How this file was discovered
    pub origem: FileOrigin,
    
    /// Creation timestamp in our database
    pub criado_em: DateTime<Utc>,
    
    /// Last update timestamp in our database
    pub atualizado_em: DateTime<Utc>,
}

/// Type of file based on its purpose
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FileType {
    Video,
    Legenda,
    Imagem,
    Outro,
}

/// How the file was discovered or added
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FileOrigin {
    /// Discovered via directory scan
    Scan,
    
    /// Explicitly imported by user
    Importacao,
    
    /// Manually added
    Manual,
}

impl File {
    /// Create a new File entity
    pub fn new(
        caminho_absoluto: PathBuf,
        tipo: FileType,
        tamanho: u64,
        data_modificacao: DateTime<Utc>,
        origem: FileOrigin,
    ) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            caminho_absoluto,
            tipo,
            tamanho,
            hash: None,
            data_modificacao,
            origem,
            criado_em: now,
            atualizado_em: now,
        }
    }
    
    /// Update file metadata (size, modification date)
    /// This is called when the file changes on disk
    pub fn update_metadata(
        &mut self,
        tamanho: u64,
        data_modificacao: DateTime<Utc>,
    ) {
        self.tamanho = tamanho;
        self.data_modificacao = data_modificacao;
        // Hash is invalidated when file changes
        self.hash = None;
        self.atualizado_em = Utc::now();
    }
    
    /// Set the hash after computation
    pub fn set_hash(&mut self, hash: String) {
        self.hash = Some(hash);
        self.atualizado_em = Utc::now();
    }
    
    /// Check if file likely changed based on metadata
    pub fn has_changed(&self, tamanho: u64, data_modificacao: DateTime<Utc>) -> bool {
        self.tamanho != tamanho || self.data_modificacao != data_modificacao
    }
}

impl FileType {
    /// Infer file type from extension
    pub fn from_extension(path: &PathBuf) -> Self {
        match path.extension().and_then(|e| e.to_str()) {
            Some("mkv") | Some("mp4") | Some("avi") | Some("webm") => FileType::Video,
            Some("srt") | Some("ass") | Some("vtt") => FileType::Legenda,
            Some("jpg") | Some("jpeg") | Some("png") | Some("webp") => FileType::Imagem,
            _ => FileType::Outro,
        }
    }
}

impl std::fmt::Display for FileType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FileType::Video => write!(f, "video"),
            FileType::Legenda => write!(f, "legenda"),
            FileType::Imagem => write!(f, "imagem"),
            FileType::Outro => write!(f, "outro"),
        }
    }
}

impl std::fmt::Display for FileOrigin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FileOrigin::Scan => write!(f, "scan"),
            FileOrigin::Importacao => write!(f, "importacao"),
            FileOrigin::Manual => write!(f, "manual"),
        }
    }
}

--- FILE: src-tauri\src\domain\file\invariants.rs ---
use super::entity::File;
use crate::domain::{DomainError, DomainResult};

/// Validates all File invariants
pub fn validate_file(file: &File) -> DomainResult<()> {
    validate_path(file)?;
    Ok(())
}

/// Path must be absolute and non-empty
fn validate_path(file: &File) -> DomainResult<()> {
    if !file.caminho_absoluto.is_absolute() {
        return Err(DomainError::InvariantViolation(
            format!("File path must be absolute: {:?}", file.caminho_absoluto)
        ));
    }
    
    if file.caminho_absoluto.as_os_str().is_empty() {
        return Err(DomainError::InvariantViolation(
            "File path cannot be empty".to_string()
        ));
    }
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::file::{File, FileType, FileOrigin};
    use std::path::PathBuf;
    use chrono::Utc;

    #[test]
    fn test_valid_file() {
        // SoluÃ§Ã£o multiplataforma: usa o diretÃ³rio atual do sistema para garantir um path absoluto
        let mut path = std::env::current_dir().unwrap();
        path.push("episode1.mkv");

        let file = File::new(
            path,
            FileType::Video,
            1024 * 1024 * 500, // 500MB
            Utc::now(),
            FileOrigin::Scan,
        );
        assert!(validate_file(&file).is_ok());
    }

    #[test]
    fn test_relative_path_fails() {
        let file = File::new(
            PathBuf::from("relative/path/ep1.mkv"),
            FileType::Video,
            1024,
            Utc::now(),
            FileOrigin::Manual,
        );
        
        let result = validate_file(&file);
        assert!(result.is_err());
        
        if let Err(DomainError::InvariantViolation(msg)) = result {
            assert!(msg.contains("must be absolute"));
        } else {
            panic!("Expected InvariantViolation error");
        }
    }
}

--- FILE: src-tauri\src\domain\file\mod.rs ---
pub mod entity;
pub mod invariants;

pub use entity::{File, FileType, FileOrigin};
pub use invariants::validate_file;

--- FILE: src-tauri\src\domain\mod.rs ---
// src-tauri/src/domain/mod.rs
//
// Domain Root - The Single Source of Truth for Domain API
//
// This file MUST declare all domain modules and re-export their public API.
// All other modules import from `crate::domain::*`

// ============================================================================
// MODULE DECLARATIONS
// ============================================================================

pub mod anime;
pub mod episode;
pub mod file;
pub mod subtitle;
pub mod collection;
pub mod statistics;
pub mod external_reference;
pub mod anime_alias;
pub mod resolution;

// ============================================================================
// PUBLIC API RE-EXPORTS
// ============================================================================

// Anime Domain
pub use anime::{Anime, AnimeType, AnimeStatus, validate_anime};

// Episode Domain
pub use episode::{Episode, EpisodeNumber, EpisodeState, validate_episode};

// File Domain
pub use file::{File, FileType, FileOrigin, validate_file};

// Subtitle Domain
pub use subtitle::{
    Subtitle, 
    SubtitleFormat, 
    SubtitleTransformation, 
    TransformationType,
    validate_subtitle
};

// Collection Domain
pub use collection::{Collection, validate_collection};

// Statistics Domain (Derived Data)
pub use statistics::{StatisticsSnapshot, StatisticsType, GlobalStatistics, AnimeStatistics};

// External Reference
pub use external_reference::{ExternalReference, validate_external_reference};

// Anime Alias
pub use anime_alias::{AnimeAlias, validate_anime_alias};

// ============================================================================
// DOMAIN ERROR TYPES
// ============================================================================

use thiserror::Error;

/// Domain-level errors
/// These represent violations of business rules and invariants
#[derive(Debug, Error)]
pub enum DomainError {
    #[error("Invariant violation: {0}")]
    InvariantViolation(String),
    
    #[error("Progress {progress}s exceeds duration {duration}s")]
    ProgressExceedsDuration { progress: u64, duration: u64 },
    
    #[error("Invalid state transition: {0}")]
    InvalidStateTransition(String),
    
    #[error("Entity not found: {0}")]
    NotFound(String),
}

/// Domain result type
pub type DomainResult<T> = Result<T, DomainError>;

--- FILE: src-tauri\src\domain\models\statistics.rs ---
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use std::collections::HashMap;
use std::str::FromStr;
use crate::shared::errors::{AppError, AppResult};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StatisticsType {
    Global,
    Genre(String),
    Status(String),
    Year(i32),
}

impl std::fmt::Display for StatisticsType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Global => write!(f, "global"),
            Self::Genre(g) => write!(f, "genre:{}", g),
            Self::Status(s) => write!(f, "status:{}", s),
            Self::Year(y) => write!(f, "year:{}", y),
        }
    }
}

// Melhoria Arquitetural: LÃ³gica de parsing extraÃ­da do repositÃ³rio para o domÃ­nio
impl FromStr for StatisticsType {
    type Err = AppError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s == "global" {
            Ok(Self::Global)
        } else if let Some(genre) = s.strip_prefix("genre:") {
            Ok(Self::Genre(genre.to_string()))
        } else if let Some(status) = s.strip_prefix("status:") {
            Ok(Self::Status(status.to_string()))
        } else if let Some(year_str) = s.strip_prefix("year:") {
            let year = year_str.parse::<i32>()
                .map_err(|_| AppError::Validation("Invalid year format in statistics type".into()))?;
            Ok(Self::Year(year))
        } else {
            Err(AppError::Validation(format!("Unknown statistics type: {}", s)))
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StatisticsSnapshot {
    pub id: Uuid,
    pub tipo: StatisticsType,
    pub data: HashMap<String, f64>,
    pub captured_at: i64,
}

--- FILE: src-tauri\src\domain\resolution\mod.rs ---
// src-tauri/src/domain/resolution/mod.rs
//
// Resolution Domain - Phase 4
//
// This module contains value objects representing the outcome of file resolution.
// Resolution transforms detected files into domain intent without committing state.
//
// CRITICAL RULES:
// - All types are pure value objects (immutable)
// - No side effects
// - No persistence
// - No event emission (that's the service's job)
// - Deterministic: same input â†’ same output

pub mod value_objects;

pub use value_objects::{
    ResolutionResult,
    ResolvedFile,
    FileRole,
    ResolutionFailure,
    ResolutionFailureReason,
    ResolvedAnimeIntent,
    ResolvedEpisodeIntent,
    ResolvedEpisodeNumber,
    ResolutionSource,
    ResolutionConfidence,
};


--- FILE: src-tauri\src\domain\resolution\value_objects.rs ---
// src-tauri/src/domain/resolution/value_objects.rs
//
// Resolution Value Objects - Phase 4
//
// Pure, immutable data structures representing resolution outcomes.
// These are the bridge between raw scan data and domain mutation.
//
// CRITICAL INVARIANTS:
// - All fields are immutable (no &mut self methods)
// - No side effects
// - No I/O operations
// - Deterministic construction
// - Clone + Debug + Serialize for traceability

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use uuid::Uuid;

// ============================================================================
// RESOLUTION RESULT (TOP-LEVEL OUTCOME)
// ============================================================================

/// The outcome of attempting to resolve a file.
/// Either a successful resolution or an explicit failure.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ResolutionResult {
    /// File was successfully resolved to domain intent
    Success(ResolvedFile),
    
    /// Resolution failed with an explicit, structured reason
    Failure(ResolutionFailure),
}

impl ResolutionResult {
    /// Returns true if resolution succeeded
    pub fn is_success(&self) -> bool {
        matches!(self, ResolutionResult::Success(_))
    }
    
    /// Returns true if resolution failed
    pub fn is_failure(&self) -> bool {
        matches!(self, ResolutionResult::Failure(_))
    }
    
    /// Extracts the resolved file if successful
    pub fn resolved_file(&self) -> Option<&ResolvedFile> {
        match self {
            ResolutionResult::Success(rf) => Some(rf),
            ResolutionResult::Failure(_) => None,
        }
    }
    
    /// Extracts the failure if unsuccessful
    pub fn failure(&self) -> Option<&ResolutionFailure> {
        match self {
            ResolutionResult::Success(_) => None,
            ResolutionResult::Failure(f) => Some(f),
        }
    }
}

// ============================================================================
// RESOLVED FILE (SUCCESSFUL RESOLUTION)
// ============================================================================

/// A file that has been successfully resolved to domain intent.
/// This represents knowledge about what the file is, not a mutation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResolvedFile {
    /// The file ID from the File domain (already persisted by scan phase)
    pub file_id: Uuid,
    
    /// The absolute path of the file (for traceability)
    pub file_path: PathBuf,
    
    /// The role this file plays (video, subtitle, etc.)
    pub role: FileRole,
    
    /// The resolved anime intent (what anime this file belongs to)
    pub anime_intent: ResolvedAnimeIntent,
    
    /// The resolved episode intent (what episode this file represents)
    pub episode_intent: ResolvedEpisodeIntent,
    
    /// Confidence score of the resolution (0.0 to 1.0)
    pub confidence: ResolutionConfidence,
    
    /// When this resolution was computed
    pub resolved_at: DateTime<Utc>,
}

impl ResolvedFile {
    /// Creates a new ResolvedFile
    pub fn new(
        file_id: Uuid,
        file_path: PathBuf,
        role: FileRole,
        anime_intent: ResolvedAnimeIntent,
        episode_intent: ResolvedEpisodeIntent,
        confidence: ResolutionConfidence,
    ) -> Self {
        Self {
            file_id,
            file_path,
            role,
            anime_intent,
            episode_intent,
            confidence,
            resolved_at: Utc::now(),
        }
    }
}

// ============================================================================
// FILE ROLE
// ============================================================================

/// The role a file plays in the context of an episode.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FileRole {
    /// Primary video file for the episode
    Video,
    
    /// Subtitle file associated with the episode
    Subtitle,
    
    /// Cover image or thumbnail
    Image,
    
    /// Other auxiliary file (e.g., NFO, sample)
    Auxiliary,
}

impl std::fmt::Display for FileRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FileRole::Video => write!(f, "video"),
            FileRole::Subtitle => write!(f, "subtitle"),
            FileRole::Image => write!(f, "image"),
            FileRole::Auxiliary => write!(f, "auxiliary"),
        }
    }
}

// ============================================================================
// RESOLVED ANIME INTENT
// ============================================================================

/// Represents the resolved intent for which anime a file belongs to.
/// This is knowledge, not a committed entity.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResolvedAnimeIntent {
    /// The parsed/inferred anime title
    pub title: String,
    
    /// Alternative titles found during parsing (if any)
    pub alternative_titles: Vec<String>,
    
    /// If an existing anime was matched, its ID
    pub matched_anime_id: Option<Uuid>,
    
    /// The source of this resolution (filename, folder, etc.)
    pub source: ResolutionSource,
}

impl ResolvedAnimeIntent {
    /// Creates a new anime intent from a parsed title
    pub fn from_parsed_title(title: String, source: ResolutionSource) -> Self {
        Self {
            title,
            alternative_titles: Vec::new(),
            matched_anime_id: None,
            source,
        }
    }
    
    /// Creates a new anime intent matched to an existing anime
    pub fn matched(anime_id: Uuid, title: String, source: ResolutionSource) -> Self {
        Self {
            title,
            alternative_titles: Vec::new(),
            matched_anime_id: Some(anime_id),
            source,
        }
    }
}

// ============================================================================
// RESOLVED EPISODE INTENT
// ============================================================================

/// Represents the resolved intent for which episode a file represents.
/// This is knowledge, not a committed entity.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResolvedEpisodeIntent {
    /// The parsed episode number
    pub number: ResolvedEpisodeNumber,
    
    /// The parsed episode title (if found)
    pub title: Option<String>,
    
    /// If an existing episode was matched, its ID
    pub matched_episode_id: Option<Uuid>,
    
    /// The source of this resolution
    pub source: ResolutionSource,
}

impl ResolvedEpisodeIntent {
    /// Creates a new episode intent from a parsed number
    pub fn from_parsed_number(number: ResolvedEpisodeNumber, source: ResolutionSource) -> Self {
        Self {
            number,
            title: None,
            matched_episode_id: None,
            source,
        }
    }
    
    /// Creates a new episode intent matched to an existing episode
    pub fn matched(
        episode_id: Uuid,
        number: ResolvedEpisodeNumber,
        source: ResolutionSource,
    ) -> Self {
        Self {
            number,
            title: None,
            matched_episode_id: Some(episode_id),
            source,
        }
    }
}

/// Resolved episode number (regular or special)
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ResolvedEpisodeNumber {
    /// Regular numbered episode (1, 2, 3, ...)
    Regular { number: u32 },
    
    /// Special episode with a label (OVA, OAD, Special, etc.)
    Special { label: String },
    
    /// Range of episodes (for batch files, rare)
    Range { start: u32, end: u32 },
}

impl std::fmt::Display for ResolvedEpisodeNumber {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ResolvedEpisodeNumber::Regular { number } => write!(f, "{}", number),
            ResolvedEpisodeNumber::Special { label } => write!(f, "{}", label),
            ResolvedEpisodeNumber::Range { start, end } => write!(f, "{}-{}", start, end),
        }
    }
}

// ============================================================================
// RESOLUTION SOURCE
// ============================================================================

/// Where the resolution information was extracted from.
/// Used for traceability and debugging.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ResolutionSource {
    /// Parsed from the filename
    Filename,
    
    /// Inferred from the parent folder name
    FolderName,
    
    /// Inferred from the folder hierarchy
    FolderHierarchy,
    
    /// Matched against existing database records
    DatabaseMatch,
    
    /// Multiple sources combined
    Combined,
}

impl std::fmt::Display for ResolutionSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ResolutionSource::Filename => write!(f, "filename"),
            ResolutionSource::FolderName => write!(f, "folder_name"),
            ResolutionSource::FolderHierarchy => write!(f, "folder_hierarchy"),
            ResolutionSource::DatabaseMatch => write!(f, "database_match"),
            ResolutionSource::Combined => write!(f, "combined"),
        }
    }
}

// ============================================================================
// RESOLUTION CONFIDENCE
// ============================================================================

/// Confidence score for a resolution.
/// Used to determine if resolution should proceed or fail.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct ResolutionConfidence {
    /// Score from 0.0 (no confidence) to 1.0 (absolute certainty)
    score: f64,
}

impl ResolutionConfidence {
    /// Minimum confidence threshold for a resolution to be considered valid
    pub const THRESHOLD: f64 = 0.6;
    
    /// Creates a new confidence score, clamped to [0.0, 1.0]
    pub fn new(score: f64) -> Self {
        Self {
            score: score.clamp(0.0, 1.0),
        }
    }
    
    /// Returns the raw score
    pub fn score(&self) -> f64 {
        self.score
    }
    
    /// Returns true if confidence meets the threshold
    pub fn meets_threshold(&self) -> bool {
        self.score >= Self::THRESHOLD
    }
    
    /// High confidence (>= 0.9)
    pub fn high() -> Self {
        Self::new(0.95)
    }
    
    /// Medium confidence (>= 0.7)
    pub fn medium() -> Self {
        Self::new(0.75)
    }
    
    /// Low confidence (>= 0.5)
    pub fn low() -> Self {
        Self::new(0.55)
    }
    
    /// No confidence
    pub fn none() -> Self {
        Self::new(0.0)
    }
}

impl PartialEq for ResolutionConfidence {
    fn eq(&self, other: &Self) -> bool {
        (self.score - other.score).abs() < f64::EPSILON
    }
}

impl std::fmt::Display for ResolutionConfidence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:.2}%", self.score * 100.0)
    }
}

// ============================================================================
// RESOLUTION FAILURE
// ============================================================================

/// Represents an explicit, structured resolution failure.
/// Failures are non-fatal and traceable.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResolutionFailure {
    /// The file ID that failed to resolve
    pub file_id: Uuid,
    
    /// The file path (for traceability)
    pub file_path: PathBuf,
    
    /// The reason for failure
    pub reason: ResolutionFailureReason,
    
    /// Human-readable description
    pub description: String,
    
    /// When this failure occurred
    pub failed_at: DateTime<Utc>,
}

impl ResolutionFailure {
    /// Creates a new resolution failure
    pub fn new(
        file_id: Uuid,
        file_path: PathBuf,
        reason: ResolutionFailureReason,
        description: String,
    ) -> Self {
        Self {
            file_id,
            file_path,
            reason,
            description,
            failed_at: Utc::now(),
        }
    }
}

/// Reasons why resolution can fail
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ResolutionFailureReason {
    /// Could not parse anime title from filename or folder
    UnparsableTitle,
    
    /// Could not parse episode number from filename
    UnparsableEpisodeNumber,
    
    /// Confidence score below threshold
    LowConfidence,
    
    /// File type not supported for resolution
    UnsupportedFileType,
    
    /// Ambiguous resolution (multiple equally valid interpretations)
    AmbiguousResolution,
    
    /// File path structure does not match expected patterns
    UnexpectedPathStructure,
}

impl std::fmt::Display for ResolutionFailureReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ResolutionFailureReason::UnparsableTitle => write!(f, "unparsable_title"),
            ResolutionFailureReason::UnparsableEpisodeNumber => write!(f, "unparsable_episode_number"),
            ResolutionFailureReason::LowConfidence => write!(f, "low_confidence"),
            ResolutionFailureReason::UnsupportedFileType => write!(f, "unsupported_file_type"),
            ResolutionFailureReason::AmbiguousResolution => write!(f, "ambiguous_resolution"),
            ResolutionFailureReason::UnexpectedPathStructure => write!(f, "unexpected_path_structure"),
        }
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_resolution_confidence_clamping() {
        let high = ResolutionConfidence::new(1.5);
        assert_eq!(high.score(), 1.0);
        
        let low = ResolutionConfidence::new(-0.5);
        assert_eq!(low.score(), 0.0);
        
        let normal = ResolutionConfidence::new(0.75);
        assert_eq!(normal.score(), 0.75);
    }

    #[test]
    fn test_resolution_confidence_threshold() {
        let above = ResolutionConfidence::new(0.7);
        assert!(above.meets_threshold());
        
        let below = ResolutionConfidence::new(0.5);
        assert!(!below.meets_threshold());
        
        let exact = ResolutionConfidence::new(0.6);
        assert!(exact.meets_threshold());
    }

    #[test]
    fn test_resolution_result_accessors() {
        let success = ResolutionResult::Success(ResolvedFile::new(
            Uuid::new_v4(),
            PathBuf::from("/test/file.mkv"),
            FileRole::Video,
            ResolvedAnimeIntent::from_parsed_title("Test Anime".to_string(), ResolutionSource::Filename),
            ResolvedEpisodeIntent::from_parsed_number(
                ResolvedEpisodeNumber::Regular { number: 1 },
                ResolutionSource::Filename,
            ),
            ResolutionConfidence::high(),
        ));
        
        assert!(success.is_success());
        assert!(!success.is_failure());
        assert!(success.resolved_file().is_some());
        assert!(success.failure().is_none());
        
        let failure = ResolutionResult::Failure(ResolutionFailure::new(
            Uuid::new_v4(),
            PathBuf::from("/test/unknown.bin"),
            ResolutionFailureReason::UnsupportedFileType,
            "Binary file not supported".to_string(),
        ));
        
        assert!(!failure.is_success());
        assert!(failure.is_failure());
        assert!(failure.resolved_file().is_none());
        assert!(failure.failure().is_some());
    }

    #[test]
    fn test_episode_number_display() {
        let regular = ResolvedEpisodeNumber::Regular { number: 5 };
        assert_eq!(regular.to_string(), "5");
        
        let special = ResolvedEpisodeNumber::Special { label: "OVA 1".to_string() };
        assert_eq!(special.to_string(), "OVA 1");
        
        let range = ResolvedEpisodeNumber::Range { start: 1, end: 3 };
        assert_eq!(range.to_string(), "1-3");
    }

    #[test]
    fn test_file_role_display() {
        assert_eq!(FileRole::Video.to_string(), "video");
        assert_eq!(FileRole::Subtitle.to_string(), "subtitle");
        assert_eq!(FileRole::Image.to_string(), "image");
        assert_eq!(FileRole::Auxiliary.to_string(), "auxiliary");
    }
}


--- FILE: src-tauri\src\domain\statistics\entity.rs ---
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Represents a derived statistics snapshot
/// Statistics are NEVER a source of truth and can be recalculated
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StatisticsSnapshot {
    /// Snapshot identifier
    pub id: Uuid,
    
    /// Type of statistics
    pub tipo: StatisticsType,
    
    /// The actual data (stored as JSON for flexibility)
    pub valor: serde_json::Value,
    
    /// When this snapshot was generated
    pub gerado_em: DateTime<Utc>,
}

/// Types of statistics that can be tracked
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum StatisticsType {
    /// Global statistics across all anime
    Global,
    
    /// Statistics for a specific anime
    PorAnime { anime_id: Uuid },
    
    /// Statistics for a time period
    PorPeriodo { inicio: DateTime<Utc>, fim: DateTime<Utc> },
}

impl StatisticsSnapshot {
    /// Create a new statistics snapshot
    pub fn new(tipo: StatisticsType, valor: serde_json::Value) -> Self {
        Self {
            id: Uuid::new_v4(),
            tipo,
            valor,
            gerado_em: Utc::now(),
        }
    }
}

/// Common global statistics structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GlobalStatistics {
    pub total_animes: u32,
    pub total_episodes: u32,
    pub episodes_assistidos: u32,
    pub tempo_total_assistido: u64, // in seconds
    pub animes_em_progresso: u32,
    pub animes_completos: u32,
}

/// Per-anime statistics structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnimeStatistics {
    pub anime_id: Uuid,
    pub total_episodes: u32,
    pub episodes_assistidos: u32,
    pub tempo_assistido: u64, // in seconds
    pub progresso_percentual: f32,
    pub ultimo_episodio_assistido: Option<Uuid>,
    pub data_ultima_visualizacao: Option<DateTime<Utc>>,
}

impl std::fmt::Display for StatisticsType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            StatisticsType::Global => write!(f, "global"),
            StatisticsType::PorAnime { anime_id } => write!(f, "por_anime:{}", anime_id),
            StatisticsType::PorPeriodo { inicio, fim } => {
                write!(f, "por_periodo:{}:{}", inicio, fim)
            }
        }
    }
}

--- FILE: src-tauri\src\domain\statistics\mod.rs ---
//! Critical Statistics Invariants:
//! 
//! 1. Statistics are ALWAYS derived, NEVER primary
//! 2. Statistics can be recalculated at any time
//! 3. Statistics can be deleted without affecting domains
//! 4. Statistics NEVER alter domain state
//! 5. If statistics conflict with domain data, domain wins
//! 6. Statistics are snapshots in time
//! 7. Stale statistics are acceptable (eventual consistency)

pub mod entity;
pub use entity::{StatisticsSnapshot, StatisticsType, GlobalStatistics, AnimeStatistics};

--- FILE: src-tauri\src\domain\subtitle\entity.rs ---
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Represents a subtitle as transformable data
/// Subtitles are versioned and never destructively edited
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Subtitle {
    /// Internal immutable identifier
    pub id: Uuid,
    
    /// Source file (REQUIRED)
    pub file_id: Uuid,
    
    /// Subtitle format
    pub formato: SubtitleFormat,
    
    /// Language (ISO 639-1 code preferred)
    pub idioma: String,
    
    /// Version identifier (for tracking transformations)
    pub versao: u32,
    
    /// Whether this is the original, unmodified subtitle
    pub eh_original: bool,
    
    /// Creation timestamp
    pub criado_em: DateTime<Utc>,
}

/// Supported subtitle formats
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
pub enum SubtitleFormat {
    SRT,
    ASS,
    VTT,
}

/// Represents a transformation applied to a subtitle
/// Transformations create new subtitle versions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubtitleTransformation {
    /// Transformation identifier
    pub id: Uuid,
    
    /// Source subtitle that was transformed
    pub subtitle_id_origem: Uuid,
    
    /// Type of transformation
    pub tipo: TransformationType,
    
    /// Parameters applied (stored as JSON)
    pub parametros_aplicados: serde_json::Value,
    
    /// Creation timestamp
    pub criado_em: DateTime<Utc>,
}

/// Types of subtitle transformations
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum TransformationType {
    /// Style changes (font, size, colors, outline)
    Style,
    
    /// Timing adjustments (sync, offset)
    Timing,
    
    /// Format conversion (SRT -> ASS, etc)
    Conversao,
}

impl Subtitle {
    /// Create a new Subtitle entity
    /// This is typically the original subtitle from a file
    pub fn new(
        file_id: Uuid,
        formato: SubtitleFormat,
        idioma: String,
    ) -> Self {
        Self {
            id: Uuid::new_v4(),
            file_id,
            formato,
            idioma,
            versao: 1,
            eh_original: true,
            criado_em: Utc::now(),
        }
    }
    
    /// Create a derived subtitle from a transformation
    /// This increments the version and marks as non-original
    pub fn derive_from(&self, new_file_id: Uuid, formato: SubtitleFormat) -> Self {
        Self {
            id: Uuid::new_v4(),
            file_id: new_file_id,
            formato,
            idioma: self.idioma.clone(),
            versao: self.versao + 1,
            eh_original: false,
            criado_em: Utc::now(),
        }
    }
}

impl SubtitleTransformation {
    /// Create a new transformation record
    pub fn new(
        subtitle_id_origem: Uuid,
        tipo: TransformationType,
        parametros: serde_json::Value,
    ) -> Self {
        Self {
            id: Uuid::new_v4(),
            subtitle_id_origem,
            tipo,
            parametros_aplicados: parametros,
            criado_em: Utc::now(),
        }
    }
}

impl SubtitleFormat {
    /// Infer format from file extension
    pub fn from_extension(ext: &str) -> Option<Self> {
        match ext.to_lowercase().as_str() {
            "srt" => Some(SubtitleFormat::SRT),
            "ass" | "ssa" => Some(SubtitleFormat::ASS),
            "vtt" => Some(SubtitleFormat::VTT),
            _ => None,
        }
    }
}

impl std::fmt::Display for SubtitleFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SubtitleFormat::SRT => write!(f, "SRT"),
            SubtitleFormat::ASS => write!(f, "ASS"),
            SubtitleFormat::VTT => write!(f, "VTT"),
        }
    }
}

impl std::fmt::Display for TransformationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TransformationType::Style => write!(f, "style"),
            TransformationType::Timing => write!(f, "timing"),
            TransformationType::Conversao => write!(f, "conversao"),
        }
    }
}

--- FILE: src-tauri\src\domain\subtitle\invariants.rs ---
use super::entity::Subtitle;
use crate::domain::{DomainError, DomainResult};

/// Validates all Subtitle invariants
pub fn validate_subtitle(subtitle: &Subtitle) -> DomainResult<()> {
    validate_language(subtitle)?;
    validate_version(subtitle)?;
    Ok(())
}

/// Language code cannot be empty
fn validate_language(subtitle: &Subtitle) -> DomainResult<()> {
    if subtitle.idioma.trim().is_empty() {
        return Err(DomainError::InvariantViolation(
            "Subtitle language cannot be empty".to_string()
        ));
    }
    Ok(())
}

/// Version must be positive
fn validate_version(subtitle: &Subtitle) -> DomainResult<()> {
    if subtitle.versao == 0 {
        return Err(DomainError::InvariantViolation(
            "Subtitle version must be at least 1".to_string()
        ));
    }
    Ok(())
}

/// Critical Subtitle Invariants:
/// 
/// 1. Every Subtitle MUST have a source File
/// 2. Original subtitle is NEVER overwritten
/// 3. Transformations ALWAYS create new versions
/// 4. Transformations are reversible (history preserved)
/// 5. Original files remain untouched on disk
/// 6. file_id is immutable (subtitle tied to specific file)
/// 7. Versions increment monotonically
/// 8. Original subtitles have eh_original = true, versao = 1

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::subtitle::{Subtitle, SubtitleFormat};
    use uuid::Uuid;

    #[test]
    fn test_valid_subtitle() {
        let file_id = Uuid::new_v4();
        let subtitle = Subtitle::new(
            file_id,
            SubtitleFormat::SRT,
            "pt-BR".to_string(),
        );
        assert!(validate_subtitle(&subtitle).is_ok());
        assert_eq!(subtitle.versao, 1);
        assert!(subtitle.eh_original);
    }

    #[test]
    fn test_derived_subtitle_increments_version() {
        let file_id = Uuid::new_v4();
        let original = Subtitle::new(
            file_id,
            SubtitleFormat::SRT,
            "en".to_string(),
        );
        
        let new_file_id = Uuid::new_v4();
        let derived = original.derive_from(new_file_id, SubtitleFormat::ASS);
        
        assert_eq!(derived.versao, 2);
        assert!(!derived.eh_original);
        assert_eq!(derived.idioma, original.idioma);
    }

    #[test]
    fn test_empty_language_fails() {
        let file_id = Uuid::new_v4();
        let subtitle = Subtitle::new(
            file_id,
            SubtitleFormat::SRT,
            "".to_string(),
        );
        assert!(validate_subtitle(&subtitle).is_err());
    }
}

--- FILE: src-tauri\src\domain\subtitle\mod.rs ---
pub mod entity;
pub mod invariants;

pub use entity::{Subtitle, SubtitleFormat, SubtitleTransformation, TransformationType};
pub use invariants::validate_subtitle;

--- FILE: src-tauri\src\error\mod.rs ---
pub mod types;

pub use types::{AppError, AppResult};

--- FILE: src-tauri\src\error\types.rs ---
// src-tauri/src/error/types.rs
use serde::Serialize;
use thiserror::Error;
use crate::domain::DomainError;

#[derive(Debug, Error)]
pub enum AppError {
    #[error("Database error: {0}")]
    Database(#[from] rusqlite::Error),

    #[error("Pool error: {0}")]
    Pool(String),

    #[error("Domain error: {0}")]
    Domain(#[from] DomainError),

    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Resource not found")]
    NotFound,

    #[error("Other error: {0}")]
    Other(String),
}

impl Serialize for AppError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl From<uuid::Error> for AppError {
    fn from(err: uuid::Error) -> Self {
        AppError::Other(format!("UUID error: {}", err))
    }
}

impl From<chrono::ParseError> for AppError {
    fn from(err: chrono::ParseError) -> Self {
        AppError::Other(format!("Date parse error: {}", err))
    }
}

impl From<r2d2::Error> for AppError {
    fn from(err: r2d2::Error) -> Self {
        AppError::Pool(err.to_string())
    }
}

pub type AppResult<T> = Result<T, AppError>;

--- FILE: src-tauri\src\events\bus\event_bus.rs ---
// events/bus/event_bus.rs
//
// Core event bus implementation.
//
// DESIGN PRINCIPLES:
// 1. Synchronous - handlers execute immediately in subscription order
// 2. Deterministic - same events â†’ same result
// 3. Observable - every emission is logged
// 4. Type-safe - events are strongly typed
// 5. No magic - explicit, straightforward code

use std::sync::{Arc, RwLock};
use std::collections::HashMap;
use std::any::{Any, TypeId};

use crate::events::types::DomainEvent;

/// Type-erased event handler function
/// Takes a reference to Any (downcasted to concrete event type inside)
type EventHandler = Box<dyn Fn(&dyn Any) + Send + Sync>;

/// The Event Bus
///
/// This is the central coordination point for all domain events.
/// It allows services to emit events and subscribe to events without
/// direct dependencies on each other.
///
/// Key characteristics:
/// - Synchronous execution (no async, no threads)
/// - Handlers execute in subscription order
/// - Type-safe through generics
/// - Observable through logging
pub struct EventBus {
    /// Map from event TypeId to list of handlers
    handlers: Arc<RwLock<HashMap<TypeId, Vec<EventHandler>>>>,
    
    /// Event emission log (for debugging)
    event_log: Arc<RwLock<Vec<EventLogEntry>>>,
}

/// A logged event for debugging and tracing
#[derive(Debug, Clone)]
pub struct EventLogEntry {
    pub event_type: String,
    pub event_id: String,
    pub occurred_at: String,
    pub handler_count: usize,
}

impl EventBus {
    /// Create a new event bus
    pub fn new() -> Self {
        Self {
            handlers: Arc::new(RwLock::new(HashMap::new())),
            event_log: Arc::new(RwLock::new(Vec::new())),
        }
    }
    
    /// Subscribe to a specific event type
    ///
    /// Generic parameter E must implement DomainEvent + 'static
    /// The handler function receives a reference to the concrete event
    ///
    /// Handlers are executed in the order they are subscribed.
    ///
    /// Example:
    /// ```ignore
    /// bus.subscribe::<AnimeCreated>(|event| {
    ///     println!("Anime created: {}", event.titulo_principal);
    /// });
    /// ```
    pub fn subscribe<E, F>(&self, handler: F)
    where
        E: DomainEvent + 'static,
        F: Fn(&E) + Send + Sync + 'static,
    {
        let type_id = TypeId::of::<E>();
        
        // Wrap the typed handler in a type-erased closure
        let wrapped: EventHandler = Box::new(move |event_any: &dyn Any| {
            // Downcast to concrete type
            if let Some(event) = event_any.downcast_ref::<E>() {
                handler(event);
            } else {
                eprintln!(
                    "ERROR: Failed to downcast event in handler for {}",
                    std::any::type_name::<E>()
                );
            }
        });
        
        let mut handlers = self.handlers.write().unwrap();
        handlers
            .entry(type_id)
            .or_insert_with(Vec::new)
            .push(wrapped);
    }
    
    /// Emit an event
    ///
    /// This will:
    /// 1. Log the event
    /// 2. Execute all handlers for this event type (in subscription order)
    /// 3. Return immediately (synchronous)
    ///
    /// If a handler panics, the panic is caught and logged, but other handlers
    /// still execute.
    pub fn emit<E>(&self, event: E)
    where
        E: DomainEvent + 'static,
    {
        let type_id = TypeId::of::<E>();
        
        // Log the event
        let log_entry = EventLogEntry {
            event_type: event.event_type().to_string(),
            event_id: event.event_id().to_string(),
            occurred_at: event.occurred_at().to_rfc3339(),
            handler_count: 0, // will be updated below
        };
        
        // Get handlers
        let handlers = self.handlers.read().unwrap();
        let event_handlers = handlers.get(&type_id);
        
        let handler_count = event_handlers.map(|h| h.len()).unwrap_or(0);
        
        // Update log entry with handler count
        let log_entry = EventLogEntry {
            handler_count,
            ..log_entry
        };
        
        // Add to event log
        {
            let mut log = self.event_log.write().unwrap();
            log.push(log_entry.clone());
        }
        
        // Log to console (observable behavior)
        println!(
            "[EVENT] {} (id: {}) | {} handlers",
            log_entry.event_type,
            log_entry.event_id,
            log_entry.handler_count
        );
        
        // Execute handlers
        if let Some(handlers) = event_handlers {
            for (idx, handler) in handlers.iter().enumerate() {
                // Catch panics to prevent one handler from breaking others
                let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                    handler(&event as &dyn Any);
                }));
                
                if let Err(e) = result {
                    eprintln!(
                        "ERROR: Handler {} for {} panicked: {:?}",
                        idx,
                        event.event_type(),
                        e
                    );
                }
            }
        }
    }
    
    /// Get the event log (for debugging)
    pub fn get_event_log(&self) -> Vec<EventLogEntry> {
        self.event_log.read().unwrap().clone()
    }
    
    /// Clear the event log
    pub fn clear_event_log(&self) {
        self.event_log.write().unwrap().clear();
    }
    
    /// Get the number of subscribers for a specific event type
    pub fn subscriber_count<E>(&self) -> usize
    where
        E: 'static,
    {
        let type_id = TypeId::of::<E>();
        let handlers = self.handlers.read().unwrap();
        handlers.get(&type_id).map(|h| h.len()).unwrap_or(0)
    }
}

impl Default for EventBus {
    fn default() -> Self {
        Self::new()
    }
}

// Make EventBus cloneable (shared reference)
impl Clone for EventBus {
    fn clone(&self) -> Self {
        Self {
            handlers: Arc::clone(&self.handlers),
            event_log: Arc::clone(&self.event_log),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::events::types::*;
    use std::sync::atomic::{AtomicUsize, Ordering};
    use std::sync::Arc;
    use uuid::Uuid;
    
    #[test]
    fn test_subscribe_and_emit() {
        let bus = EventBus::new();
        let counter = Arc::new(AtomicUsize::new(0));
        let counter_clone = Arc::clone(&counter);
        
        bus.subscribe::<AnimeCreated, _>(move |_event| {
            counter_clone.fetch_add(1, Ordering::SeqCst);
        });
        
        let event = AnimeCreated::new(
            Uuid::new_v4(),
            "Steins;Gate".to_string(),
            "TV".to_string(),
        );
        
        bus.emit(event);
        
        assert_eq!(counter.load(Ordering::SeqCst), 1);
    }
    
    #[test]
    fn test_multiple_handlers_execute_in_order() {
        let bus = EventBus::new();
        let sequence = Arc::new(RwLock::new(Vec::new()));
        
        let seq1 = Arc::clone(&sequence);
        bus.subscribe::<EpisodeCreated, _>(move |_| {
            seq1.write().unwrap().push(1);
        });
        
        let seq2 = Arc::clone(&sequence);
        bus.subscribe::<EpisodeCreated, _>(move |_| {
            seq2.write().unwrap().push(2);
        });
        
        let seq3 = Arc::clone(&sequence);
        bus.subscribe::<EpisodeCreated, _>(move |_| {
            seq3.write().unwrap().push(3);
        });
        
        let event = EpisodeCreated::new(
            Uuid::new_v4(),
            Uuid::new_v4(),
            "1".to_string(),
        );
        
        bus.emit(event);
        
        let result = sequence.read().unwrap();
        assert_eq!(*result, vec![1, 2, 3]);
    }
    
    #[test]
    fn test_event_log_records_emissions() {
        let bus = EventBus::new();
        
        let event1 = AnimeCreated::new(
            Uuid::new_v4(),
            "Cowboy Bebop".to_string(),
            "TV".to_string(),
        );
        
        let event2 = EpisodeCreated::new(
            Uuid::new_v4(),
            Uuid::new_v4(),
            "1".to_string(),
        );
        
        bus.emit(event1);
        bus.emit(event2);
        
        let log = bus.get_event_log();
        assert_eq!(log.len(), 2);
        assert_eq!(log[0].event_type, "AnimeCreated");
        assert_eq!(log[1].event_type, "EpisodeCreated");
    }
    
    #[test]
    fn test_subscriber_count() {
        let bus = EventBus::new();
        
        assert_eq!(bus.subscriber_count::<AnimeCreated>(), 0);
        
        bus.subscribe::<AnimeCreated, _>(|_| {});
        assert_eq!(bus.subscriber_count::<AnimeCreated>(), 1);
        
        bus.subscribe::<AnimeCreated, _>(|_| {});
        assert_eq!(bus.subscriber_count::<AnimeCreated>(), 2);
        
        // Different event type
        assert_eq!(bus.subscriber_count::<EpisodeCreated>(), 0);
    }
    
    #[test]
    fn test_handler_panic_doesnt_break_bus() {
        let bus = EventBus::new();
        let counter = Arc::new(AtomicUsize::new(0));
        
        // First handler panics
        bus.subscribe::<AnimeCreated, _>(|_| {
            panic!("Intentional panic");
        });
        
        // Second handler should still execute
        let counter_clone = Arc::clone(&counter);
        bus.subscribe::<AnimeCreated, _>(move |_| {
            counter_clone.fetch_add(1, Ordering::SeqCst);
        });
        
        let event = AnimeCreated::new(
            Uuid::new_v4(),
            "Test".to_string(),
            "TV".to_string(),
        );
        
        bus.emit(event);
        
        // Second handler executed despite first one panicking
        assert_eq!(counter.load(Ordering::SeqCst), 1);
    }
}

--- FILE: src-tauri\src\events\bus\mod.rs ---
// events/bus/mod.rs

pub mod event_bus;

pub use event_bus::{EventBus, EventLogEntry};

--- FILE: src-tauri\src\events\handlers\mod.rs ---
// src-tauri/src/events/handlers/mod.rs
//
// Event Handlers - INTERNAL MODULE
//
// This module contains handler implementations but does NOT
// export the EventHandler type (that stays internal to the bus)

use crate::events::bus::EventBus;
use crate::events::types::*;

// ============================================================================
// INTERNAL TRAIT (NOT EXPORTED)
// ============================================================================

// This trait is for internal organization only
// It is NOT re-exported from this module
trait RegisterHandler {
    fn register(self, bus: &EventBus);
}

// ============================================================================
// EXAMPLE HANDLERS (INTERNAL)
// ============================================================================

// Example handler implementation
// In production, these would be in services that subscribe to events
pub struct LoggingHandler;

impl LoggingHandler {
    pub fn new() -> Self {
        Self
    }
    
    pub fn handle_anime_created(&self, event: &AnimeCreated) {
        println!("Anime Created: {} (ID: {})", event.titulo_principal, event.anime_id);
    }
    
    pub fn register(&self, bus: &EventBus) {
        let handler = Self;
        bus.subscribe::<AnimeCreated, _>(move |event| {
            handler.handle_anime_created(event);
        });
    }
}

// More handlers will be added here as services are implemented

--- FILE: src-tauri\src\events\mod.rs ---
// src-tauri/src/events/mod.rs
//
// Internal Event System - Public API
//
// CRITICAL: EventHandler is INTERNAL and must NOT be exported

pub mod types;
pub mod bus;
pub mod handlers;
pub mod resolution_events;

// ============================================================================
// PUBLIC EXPORTS - Event Types and Bus Only
// ============================================================================

pub use types::{
    DomainEvent,
    
    // File scanning
    DirectoryScanned,
    FileDetected,
    
    // Anime
    AnimeCreated,
    AnimeUpdated,
    AnimeMerged,
    
    // Episode
    EpisodeCreated,
    FileLinkedToEpisode,
    EpisodeBecamePlayable,
    EpisodeProgressUpdated,
    EpisodeCompleted,
    
    // Playback
    PlaybackStarted,
    PlaybackProgressUpdated,
    PlaybackStopped,
    
    // Subtitle
    SubtitleDetected,
    SubtitleStyleApplied,
    SubtitleTimingAdjusted,
    SubtitleVersionCreated,
    
    // Statistics
    StatisticsRebuilt,
    StatisticsUpdated,
    
    // External
    ExternalMetadataRequested,
    ExternalMetadataFetched,
    ExternalMetadataLinked,
};

pub use bus::{EventBus, EventLogEntry};

pub use resolution_events::*;

// ============================================================================
// INTERNAL ONLY - DO NOT EXPORT
// ============================================================================

// EventHandler type alias is internal to the bus module
// handlers::RegisterHandler is internal to handlers module

/// Initialize a new event bus
pub fn create_event_bus() -> EventBus {
    EventBus::new()
}

--- FILE: src-tauri\src\events\resolution_events.rs ---
// src-tauri/src/events/resolution_events.rs
//
// Resolution Events - Phase 4
//
// Events that represent knowledge derived from resolution, not actions.
// These events are the bridge between raw scan data and domain mutation.
//
// CRITICAL RULES:
// - Events are facts, not commands
// - Events are immutable
// - Events carry only the data needed to react
// - No business logic in event types
// - Resolution events represent knowledge, not action

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use uuid::Uuid;

use super::types::DomainEvent;

// ============================================================================
// FILE RESOLVED EVENT
// ============================================================================

/// Emitted when a file is successfully resolved to domain intent.
/// This represents knowledge about what the file is.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileResolved {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    
    /// The file ID that was resolved
    pub file_id: Uuid,
    
    /// The file path (for traceability)
    pub file_path: PathBuf,
    
    /// The resolved anime title
    pub anime_title: String,
    
    /// If matched to existing anime, its ID
    pub matched_anime_id: Option<Uuid>,
    
    /// The resolved episode number (as string for flexibility)
    pub episode_number: String,
    
    /// If matched to existing episode, its ID
    pub matched_episode_id: Option<Uuid>,
    
    /// The role of the file (video, subtitle, etc.)
    pub file_role: String,
    
    /// Confidence score (0.0 to 1.0)
    pub confidence: f64,
    
    /// Source of resolution (filename, folder, etc.)
    pub resolution_source: String,
}

impl FileResolved {
    pub fn new(
        file_id: Uuid,
        file_path: PathBuf,
        anime_title: String,
        matched_anime_id: Option<Uuid>,
        episode_number: String,
        matched_episode_id: Option<Uuid>,
        file_role: String,
        confidence: f64,
        resolution_source: String,
    ) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            file_id,
            file_path,
            anime_title,
            matched_anime_id,
            episode_number,
            matched_episode_id,
            file_role,
            confidence,
            resolution_source,
        }
    }
}

impl DomainEvent for FileResolved {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "FileResolved" }
}

// ============================================================================
// EPISODE RESOLVED EVENT
// ============================================================================

/// Emitted when an episode is resolved from one or more files.
/// This aggregates file resolutions into episode-level knowledge.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EpisodeResolved {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    
    /// The resolved anime title
    pub anime_title: String,
    
    /// If matched to existing anime, its ID
    pub matched_anime_id: Option<Uuid>,
    
    /// The resolved episode number
    pub episode_number: String,
    
    /// If matched to existing episode, its ID
    pub matched_episode_id: Option<Uuid>,
    
    /// The primary video file ID (if found)
    pub video_file_id: Option<Uuid>,
    
    /// Associated subtitle file IDs
    pub subtitle_file_ids: Vec<Uuid>,
    
    /// Overall confidence for this episode resolution
    pub confidence: f64,
}

impl EpisodeResolved {
    pub fn new(
        anime_title: String,
        matched_anime_id: Option<Uuid>,
        episode_number: String,
        matched_episode_id: Option<Uuid>,
        video_file_id: Option<Uuid>,
        subtitle_file_ids: Vec<Uuid>,
        confidence: f64,
    ) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            anime_title,
            matched_anime_id,
            episode_number,
            matched_episode_id,
            video_file_id,
            subtitle_file_ids,
            confidence,
        }
    }
}

impl DomainEvent for EpisodeResolved {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "EpisodeResolved" }
}

// ============================================================================
// RESOLUTION FAILED EVENT
// ============================================================================

/// Emitted when resolution fails for a file.
/// This is explicit, structured, and non-fatal.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResolutionFailed {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    
    /// The file ID that failed to resolve
    pub file_id: Uuid,
    
    /// The file path (for traceability)
    pub file_path: PathBuf,
    
    /// The reason for failure
    pub failure_reason: String,
    
    /// Human-readable description
    pub description: String,
}

impl ResolutionFailed {
    pub fn new(
        file_id: Uuid,
        file_path: PathBuf,
        failure_reason: String,
        description: String,
    ) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            file_id,
            file_path,
            failure_reason,
            description,
        }
    }
}

impl DomainEvent for ResolutionFailed {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "ResolutionFailed" }
}

// ============================================================================
// RESOLUTION BATCH COMPLETED EVENT
// ============================================================================

/// Emitted when a batch resolution operation completes.
/// Provides summary statistics for the batch.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResolutionBatchCompleted {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    
    /// Total files processed
    pub total_files: usize,
    
    /// Successfully resolved files
    pub resolved_count: usize,
    
    /// Failed resolutions
    pub failed_count: usize,
    
    /// Skipped files (already resolved or not applicable)
    pub skipped_count: usize,
    
    /// Duration of the batch operation in milliseconds
    pub duration_ms: u64,
}

impl ResolutionBatchCompleted {
    pub fn new(
        total_files: usize,
        resolved_count: usize,
        failed_count: usize,
        skipped_count: usize,
        duration_ms: u64,
    ) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            total_files,
            resolved_count,
            failed_count,
            skipped_count,
            duration_ms,
        }
    }
}

impl DomainEvent for ResolutionBatchCompleted {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "ResolutionBatchCompleted" }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_file_resolved_event_creation() {
        let event = FileResolved::new(
            Uuid::new_v4(),
            PathBuf::from("/anime/Steins Gate/Episode 01.mkv"),
            "Steins;Gate".to_string(),
            None,
            "1".to_string(),
            None,
            "video".to_string(),
            0.95,
            "filename".to_string(),
        );
        
        assert_eq!(event.event_type(), "FileResolved");
        assert_eq!(event.anime_title, "Steins;Gate");
        assert_eq!(event.episode_number, "1");
        assert_eq!(event.confidence, 0.95);
    }

    #[test]
    fn test_episode_resolved_event_creation() {
        let video_id = Uuid::new_v4();
        let sub_id = Uuid::new_v4();
        
        let event = EpisodeResolved::new(
            "Steins;Gate".to_string(),
            None,
            "1".to_string(),
            None,
            Some(video_id),
            vec![sub_id],
            0.90,
        );
        
        assert_eq!(event.event_type(), "EpisodeResolved");
        assert_eq!(event.video_file_id, Some(video_id));
        assert_eq!(event.subtitle_file_ids.len(), 1);
    }

    #[test]
    fn test_resolution_failed_event_creation() {
        let event = ResolutionFailed::new(
            Uuid::new_v4(),
            PathBuf::from("/unknown/file.bin"),
            "unsupported_file_type".to_string(),
            "Binary files are not supported for resolution".to_string(),
        );
        
        assert_eq!(event.event_type(), "ResolutionFailed");
        assert_eq!(event.failure_reason, "unsupported_file_type");
    }

    #[test]
    fn test_resolution_batch_completed_event() {
        let event = ResolutionBatchCompleted::new(100, 85, 10, 5, 1500);
        
        assert_eq!(event.event_type(), "ResolutionBatchCompleted");
        assert_eq!(event.total_files, 100);
        assert_eq!(event.resolved_count, 85);
        assert_eq!(event.failed_count, 10);
        assert_eq!(event.skipped_count, 5);
    }
}


--- FILE: src-tauri\src\events\types.rs ---
// events/types.rs
//
// All domain events in the system.
// Each event represents an immutable fact that has already occurred.
//
// CRITICAL RULES:
// - Events are facts, not commands
// - Events are immutable
// - Events carry only the data needed to react
// - No business logic in event types

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use std::path::PathBuf;

/// Trait that all domain events must implement
pub trait DomainEvent: std::fmt::Debug + Clone {
    /// Unique identifier for this event instance
    fn event_id(&self) -> Uuid;
    
    /// When this event occurred
    fn occurred_at(&self) -> DateTime<Utc>;
    
    /// Human-readable event type name
    fn event_type(&self) -> &'static str;
}

// ============================================================================
// FILE SCANNING EVENTS
// ============================================================================

/// Emitted when a directory scan completes
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DirectoryScanned {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub directory_path: PathBuf,
    pub files_found: usize,
}

impl DirectoryScanned {
    pub fn new(directory_path: PathBuf, files_found: usize) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            directory_path,
            files_found,
        }
    }
}

impl DomainEvent for DirectoryScanned {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "DirectoryScanned" }
}

/// Emitted for each relevant file detected during scan
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileDetected {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub file_path: PathBuf,
    pub file_size: u64,
    pub file_type: String, // "video", "subtitle", "image"
}

impl FileDetected {
    pub fn new(file_path: PathBuf, file_size: u64, file_type: String) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            file_path,
            file_size,
            file_type,
        }
    }
}

impl DomainEvent for FileDetected {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "FileDetected" }
}

// ============================================================================
// ANIME DOMAIN EVENTS
// ============================================================================

/// Emitted when a new Anime entity is created
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnimeCreated {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub anime_id: Uuid,
    pub titulo_principal: String,
    pub tipo: String, // "TV", "Movie", "OVA", "Special"
}

impl AnimeCreated {
    pub fn new(anime_id: Uuid, titulo_principal: String, tipo: String) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            anime_id,
            titulo_principal,
            tipo,
        }
    }
}

impl DomainEvent for AnimeCreated {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "AnimeCreated" }
}

/// Emitted when anime metadata is updated
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnimeUpdated {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub anime_id: Uuid,
}

impl AnimeUpdated {
    pub fn new(anime_id: Uuid) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            anime_id,
        }
    }
}

impl DomainEvent for AnimeUpdated {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "AnimeUpdated" }
}

/// Emitted when duplicate animes are merged
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnimeMerged {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub principal_anime_id: Uuid,
    pub merged_anime_id: Uuid,
}

impl AnimeMerged {
    pub fn new(principal_anime_id: Uuid, merged_anime_id: Uuid) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            principal_anime_id,
            merged_anime_id,
        }
    }
}

impl DomainEvent for AnimeMerged {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "AnimeMerged" }
}

// ============================================================================
// EPISODE DOMAIN EVENTS
// ============================================================================

/// Emitted when a new Episode is created
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EpisodeCreated {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub episode_id: Uuid,
    pub anime_id: Uuid,
    pub numero: String, // Can be "1", "2" or "OVA 1", etc
}

impl EpisodeCreated {
    pub fn new(episode_id: Uuid, anime_id: Uuid, numero: String) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            episode_id,
            anime_id,
            numero,
        }
    }
}

impl DomainEvent for EpisodeCreated {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "EpisodeCreated" }
}

/// Emitted when a file is linked to an episode
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileLinkedToEpisode {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub episode_id: Uuid,
    pub file_id: Uuid,
    pub is_primary: bool, // true = main video, false = auxiliary
}

impl FileLinkedToEpisode {
    pub fn new(episode_id: Uuid, file_id: Uuid, is_primary: bool) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            episode_id,
            file_id,
            is_primary,
        }
    }
}

impl DomainEvent for FileLinkedToEpisode {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "FileLinkedToEpisode" }
}

/// Emitted when an episode becomes playable (has valid video file)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EpisodeBecamePlayable {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub episode_id: Uuid,
}

impl EpisodeBecamePlayable {
    pub fn new(episode_id: Uuid) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            episode_id,
        }
    }
}

impl DomainEvent for EpisodeBecamePlayable {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "EpisodeBecamePlayable" }
}

/// Emitted when episode progress is updated
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EpisodeProgressUpdated {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub episode_id: Uuid,
    pub progress_seconds: u64,
    pub duration_seconds: Option<u64>,
}

impl EpisodeProgressUpdated {
    pub fn new(episode_id: Uuid, progress_seconds: u64, duration_seconds: Option<u64>) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            episode_id,
            progress_seconds,
            duration_seconds,
        }
    }
}

impl DomainEvent for EpisodeProgressUpdated {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "EpisodeProgressUpdated" }
}

/// Emitted when an episode is marked as completed
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EpisodeCompleted {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub episode_id: Uuid,
    pub anime_id: Uuid,
}

impl EpisodeCompleted {
    pub fn new(episode_id: Uuid, anime_id: Uuid) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            episode_id,
            anime_id,
        }
    }
}

impl DomainEvent for EpisodeCompleted {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "EpisodeCompleted" }
}

// ============================================================================
// PLAYBACK EVENTS
// ============================================================================

/// Emitted when playback starts
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackStarted {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub episode_id: Uuid,
}

impl PlaybackStarted {
    pub fn new(episode_id: Uuid) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            episode_id,
        }
    }
}

impl DomainEvent for PlaybackStarted {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "PlaybackStarted" }
}

/// Emitted periodically during playback
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackProgressUpdated {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub episode_id: Uuid,
    pub progress_seconds: u64,
}

impl PlaybackProgressUpdated {
    pub fn new(episode_id: Uuid, progress_seconds: u64) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            episode_id,
            progress_seconds,
        }
    }
}

impl DomainEvent for PlaybackProgressUpdated {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "PlaybackProgressUpdated" }
}

/// Emitted when playback stops
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackStopped {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub episode_id: Uuid,
    pub final_progress_seconds: u64,
}

impl PlaybackStopped {
    pub fn new(episode_id: Uuid, final_progress_seconds: u64) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            episode_id,
            final_progress_seconds,
        }
    }
}

impl DomainEvent for PlaybackStopped {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "PlaybackStopped" }
}

/// Emitted when playback is paused
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackPaused {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub episode_id: Uuid,
    pub position_seconds: u64,
}

impl PlaybackPaused {
    pub fn new(episode_id: Uuid, position_seconds: u64) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            episode_id,
            position_seconds,
        }
    }
}

impl DomainEvent for PlaybackPaused {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "PlaybackPaused" }
}

/// Emitted when playback is resumed after pause
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackResumed {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub episode_id: Uuid,
}

impl PlaybackResumed {
    pub fn new(episode_id: Uuid) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            episode_id,
        }
    }
}

impl DomainEvent for PlaybackResumed {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "PlaybackResumed" }
}

/// Emitted when playback finishes naturally (reached end)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackFinished {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub episode_id: Uuid,
    pub duration_seconds: u64,
}

impl PlaybackFinished {
    pub fn new(episode_id: Uuid, duration_seconds: u64) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            episode_id,
            duration_seconds,
        }
    }
}

impl DomainEvent for PlaybackFinished {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "PlaybackFinished" }
}

// ============================================================================
// SUBTITLE EVENTS
// ============================================================================

/// Emitted when a subtitle file is detected
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubtitleDetected {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub file_id: Uuid,
    pub format: String, // "SRT", "ASS", "VTT"
    pub language: String,
}

impl SubtitleDetected {
    pub fn new(file_id: Uuid, format: String, language: String) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            file_id,
            format,
            language,
        }
    }
}

impl DomainEvent for SubtitleDetected {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "SubtitleDetected" }
}

/// Emitted when subtitle style is applied
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubtitleStyleApplied {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub subtitle_id: Uuid,
    pub new_subtitle_id: Uuid, // The derived subtitle
}

impl SubtitleStyleApplied {
    pub fn new(subtitle_id: Uuid, new_subtitle_id: Uuid) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            subtitle_id,
            new_subtitle_id,
        }
    }
}

impl DomainEvent for SubtitleStyleApplied {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "SubtitleStyleApplied" }
}

/// Emitted when subtitle timing is adjusted
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubtitleTimingAdjusted {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub subtitle_id: Uuid,
    pub new_subtitle_id: Uuid, // The derived subtitle
    pub offset_ms: i64,
}

impl SubtitleTimingAdjusted {
    pub fn new(subtitle_id: Uuid, new_subtitle_id: Uuid, offset_ms: i64) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            subtitle_id,
            new_subtitle_id,
            offset_ms,
        }
    }
}

impl DomainEvent for SubtitleTimingAdjusted {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "SubtitleTimingAdjusted" }
}

/// Emitted when a new subtitle version is created from transformation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubtitleVersionCreated {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub subtitle_id: Uuid,
    pub version: u32,
}

impl SubtitleVersionCreated {
    pub fn new(subtitle_id: Uuid, version: u32) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            subtitle_id,
            version,
        }
    }
}

impl DomainEvent for SubtitleVersionCreated {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "SubtitleVersionCreated" }
}

// ============================================================================
// STATISTICS EVENTS
// ============================================================================

/// Emitted when statistics are recalculated
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StatisticsRebuilt {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub statistics_type: String, // "global", "per_anime", "per_period"
}

impl StatisticsRebuilt {
    pub fn new(statistics_type: String) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            statistics_type,
        }
    }
}

impl DomainEvent for StatisticsRebuilt {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "StatisticsRebuilt" }
}

/// Emitted when statistics are updated incrementally
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StatisticsUpdated {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
}

impl StatisticsUpdated {
    pub fn new() -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
        }
    }
}

impl DomainEvent for StatisticsUpdated {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "StatisticsUpdated" }
}

// ============================================================================
// EXTERNAL INTEGRATION EVENTS
// ============================================================================

/// Emitted when external metadata is requested
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExternalMetadataRequested {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub anime_id: Uuid,
    pub provider: String, // "AniList"
}

impl ExternalMetadataRequested {
    pub fn new(anime_id: Uuid, provider: String) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            anime_id,
            provider,
        }
    }
}

impl DomainEvent for ExternalMetadataRequested {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "ExternalMetadataRequested" }
}

/// Emitted when external metadata is fetched
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExternalMetadataFetched {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub anime_id: Uuid,
    pub provider: String,
    pub external_id: String,
}

impl ExternalMetadataFetched {
    pub fn new(anime_id: Uuid, provider: String, external_id: String) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            anime_id,
            provider,
            external_id,
        }
    }
}

impl DomainEvent for ExternalMetadataFetched {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "ExternalMetadataFetched" }
}

/// Emitted when external metadata is linked to an anime
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExternalMetadataLinked {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub anime_id: Uuid,
    pub provider: String,
    pub external_id: String,
}

impl ExternalMetadataLinked {
    pub fn new(anime_id: Uuid, provider: String, external_id: String) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            anime_id,
            provider,
            external_id,
        }
    }
}

impl DomainEvent for ExternalMetadataLinked {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "ExternalMetadataLinked" }
}

--- FILE: src-tauri\src\infrastructure\mod.rs ---
// src-tauri/src/infrastructure/mod.rs
//
// Infrastructure Layer
//
// Contains implementation details that support the domain
// but are not part of the domain itself.
//
// RULES:
// - Infrastructure serves the domain
// - Infrastructure never dictates domain behavior
// - Infrastructure is replaceable

pub mod subtitle_workspace;

pub use subtitle_workspace::{
    SubtitleWorkspace,
    SubtitleWorkspaceCreated,
    SubtitleWorkspaceCleaned,
};

--- FILE: src-tauri\src\infrastructure\subtitle_workspace.rs ---
// src-tauri/src/infrastructure/subtitle_workspace.rs
//
// Subtitle Workspace Management
//
// CRITICAL RULES:
// - One workspace per subtitle transformation session
// - Original files are NEVER modified
// - Cleanup requires explicit confirmation
// - All operations are traceable

use std::path::{Path, PathBuf};
use std::fs;
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::error::{AppError, AppResult};

/// Represents a temporary workspace for subtitle transformations
/// 
/// INVARIANTS:
/// - Each workspace has a unique ID
/// - Workspace contains a working copy of the subtitle
/// - Original file is never touched
/// - Cleanup must be explicit
#[derive(Debug, Clone)]
pub struct SubtitleWorkspace {
    /// Unique workspace identifier
    pub id: Uuid,
    
    /// Path to the workspace directory
    pub workspace_dir: PathBuf,
    
    /// Path to the original subtitle file (read-only)
    pub original_file: PathBuf,
    
    /// Path to the working copy in workspace
    pub working_file: PathBuf,
    
    /// When this workspace was created
    pub created_at: DateTime<Utc>,
    
    /// Whether this workspace has been cleaned up
    pub is_cleaned: bool,
}

impl SubtitleWorkspace {
    /// Create a new workspace for a subtitle file
    /// 
    /// This will:
    /// 1. Create a temporary directory
    /// 2. Copy the original file into it
    /// 3. Return a workspace handle
    /// 
    /// The original file is NEVER modified.
    pub fn new(original_file: PathBuf) -> AppResult<Self> {
        // Validate original file exists
        if !original_file.exists() {
            return Err(AppError::Other(format!(
                "Original subtitle file not found: {:?}",
                original_file
            )));
        }
        
        // Create workspace directory
        let workspace_id = Uuid::new_v4();
        let base_temp = std::env::temp_dir();
        let workspace_dir = base_temp
            .join("animehub")
            .join("subtitle_workspaces")
            .join(workspace_id.to_string());
        
        fs::create_dir_all(&workspace_dir)
            .map_err(|e| AppError::Io(e))?;
        
        // Copy original file to workspace
        let filename = original_file
            .file_name()
            .ok_or_else(|| AppError::Other("Invalid filename".to_string()))?;
        let working_file = workspace_dir.join(filename);
        
        fs::copy(&original_file, &working_file)
            .map_err(|e| AppError::Io(e))?;
        
        Ok(Self {
            id: workspace_id,
            workspace_dir,
            original_file,
            working_file,
            created_at: Utc::now(),
            is_cleaned: false,
        })
    }
    
    /// Get the path to the working file
    /// 
    /// This is the file that should be modified during transformations.
    pub fn working_file_path(&self) -> &Path {
        &self.working_file
    }
    
    /// Get the path to the original file (read-only)
    pub fn original_file_path(&self) -> &Path {
        &self.original_file
    }
    
    /// Check if the workspace is still valid
    pub fn is_valid(&self) -> bool {
        !self.is_cleaned && self.workspace_dir.exists()
    }
    
    /// Clean up the workspace
    /// 
    /// This removes the temporary directory and all its contents.
    /// 
    /// CRITICAL: This NEVER touches the original file.
    /// CRITICAL: This should only be called after success or explicit cancellation.
    pub fn cleanup(&mut self) -> AppResult<()> {
        if self.is_cleaned {
            return Ok(()); // Already cleaned
        }
        
        // Verify we're only deleting inside temp directory
        let temp_base = std::env::temp_dir().join("animehub").join("subtitle_workspaces");
        if !self.workspace_dir.starts_with(&temp_base) {
            return Err(AppError::Other(
                "Workspace directory is not in expected temp location".to_string()
            ));
        }
        
        // Delete workspace directory
        if self.workspace_dir.exists() {
            fs::remove_dir_all(&self.workspace_dir)
                .map_err(|e| AppError::Io(e))?;
        }
        
        self.is_cleaned = true;
        Ok(())
    }
    
    /// Copy the working file to a destination
    /// 
    /// This is used to save the transformed subtitle to its final location.
    pub fn copy_working_file_to(&self, destination: &Path) -> AppResult<()> {
        if !self.is_valid() {
            return Err(AppError::Other("Workspace is not valid".to_string()));
        }
        
        // Create parent directory if needed
        if let Some(parent) = destination.parent() {
            fs::create_dir_all(parent)
                .map_err(|e| AppError::Io(e))?;
        }
        
        fs::copy(&self.working_file, destination)
            .map_err(|e| AppError::Io(e))?;
        
        Ok(())
    }
}

impl Drop for SubtitleWorkspace {
    fn drop(&mut self) {
        // Attempt cleanup on drop, but don't panic if it fails
        if !self.is_cleaned {
            let _ = self.cleanup();
        }
    }
}

// ============================================================================
// WORKSPACE EVENTS
// ============================================================================

/// Events specific to workspace lifecycle
use crate::events::types::DomainEvent;
use serde::{Deserialize, Serialize};

/// Emitted when a subtitle workspace is created
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubtitleWorkspaceCreated {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub workspace_id: Uuid,
    pub subtitle_id: Uuid,
}

impl SubtitleWorkspaceCreated {
    pub fn new(workspace_id: Uuid, subtitle_id: Uuid) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            workspace_id,
            subtitle_id,
        }
    }
}

impl DomainEvent for SubtitleWorkspaceCreated {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "SubtitleWorkspaceCreated" }
}

/// Emitted when a subtitle workspace is cleaned up
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubtitleWorkspaceCleaned {
    pub event_id: Uuid,
    pub occurred_at: DateTime<Utc>,
    pub workspace_id: Uuid,
}

impl SubtitleWorkspaceCleaned {
    pub fn new(workspace_id: Uuid) -> Self {
        Self {
            event_id: Uuid::new_v4(),
            occurred_at: Utc::now(),
            workspace_id,
        }
    }
}

impl DomainEvent for SubtitleWorkspaceCleaned {
    fn event_id(&self) -> Uuid { self.event_id }
    fn occurred_at(&self) -> DateTime<Utc> { self.occurred_at }
    fn event_type(&self) -> &'static str { "SubtitleWorkspaceCleaned" }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs::File;
    use std::io::Write;
    
    fn create_test_subtitle() -> PathBuf {
        let temp_dir = std::env::temp_dir();
        let test_file = temp_dir.join(format!("test_subtitle_{}.srt", Uuid::new_v4()));
        
        let mut file = File::create(&test_file).unwrap();
        file.write_all(b"1\n00:00:01,000 --> 00:00:03,000\nTest subtitle\n").unwrap();
        
        test_file
    }
    
    #[test]
    fn test_workspace_creation() {
        let original = create_test_subtitle();
        let workspace = SubtitleWorkspace::new(original.clone()).unwrap();
        
        assert!(workspace.is_valid());
        assert!(workspace.workspace_dir.exists());
        assert!(workspace.working_file.exists());
        assert_eq!(workspace.original_file, original);
        
        // Cleanup
        let _ = fs::remove_file(&original);
    }
    
    #[test]
    fn test_workspace_cleanup() {
        let original = create_test_subtitle();
        let mut workspace = SubtitleWorkspace::new(original.clone()).unwrap();
        
        let workspace_dir = workspace.workspace_dir.clone();
        
        workspace.cleanup().unwrap();
        
        assert!(workspace.is_cleaned);
        assert!(!workspace_dir.exists());
        assert!(original.exists()); // Original untouched
        
        // Cleanup
        let _ = fs::remove_file(&original);
    }
    
    #[test]
    fn test_copy_working_file() {
        let original = create_test_subtitle();
        let workspace = SubtitleWorkspace::new(original.clone()).unwrap();
        
        let dest = std::env::temp_dir().join(format!("dest_{}.srt", Uuid::new_v4()));
        
        workspace.copy_working_file_to(&dest).unwrap();
        
        assert!(dest.exists());
        
        // Cleanup
        let _ = fs::remove_file(&original);
        let _ = fs::remove_file(&dest);
    }
    
    #[test]
    fn test_original_never_modified() {
        let original = create_test_subtitle();
        let original_content = fs::read_to_string(&original).unwrap();
        
        let mut workspace = SubtitleWorkspace::new(original.clone()).unwrap();
        
        // Modify working file
        fs::write(&workspace.working_file, "MODIFIED").unwrap();
        
        // Cleanup
        workspace.cleanup().unwrap();
        
        // Original should be unchanged
        let final_content = fs::read_to_string(&original).unwrap();
        assert_eq!(original_content, final_content);
        
        // Cleanup
        let _ = fs::remove_file(&original);
    }
}

--- FILE: src-tauri\src\integrations\anilist\client.rs ---
// src-tauri/src/integrations/anilist/client.rs
//
// AniList API Integration - Phase 5 Real Implementation
//
// ARCHITECTURE:
// - GraphQL client for AniList API
// - Handles authentication, rate limiting, pagination
// - Maps external data â†’ internal DTOs (NO domain mutation)
// - Used by ExternalIntegrationService
//
// CRITICAL RULES:
// - This is INFRASTRUCTURE, not DOMAIN
// - Never creates or modifies domain entities directly
// - Returns DTOs that services can map
// - Handles all external API concerns

use reqwest::{Client, header};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::time::{Duration, Instant};
use std::sync::{Arc, Mutex};
use crate::error::{AppError, AppResult};

/// AniList anime metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AniListAnime {
    pub id: i64,
    pub title: AniListTitle,
    pub episodes: Option<i32>,
    pub status: String,
    pub start_date: Option<AniListDate>,
    pub end_date: Option<AniListDate>,
    pub genres: Vec<String>,
    pub cover_image: String,
    pub description: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AniListTitle {
    pub romaji: Option<String>,
    pub english: Option<String>,
    pub native: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AniListDate {
    pub year: Option<i32>,
    pub month: Option<i32>,
    pub day: Option<i32>,
}

/// GraphQL response wrapper
#[derive(Debug, Deserialize)]
struct GraphQLResponse<T> {
    data: Option<T>,
    errors: Option<Vec<GraphQLError>>,
}

#[derive(Debug, Deserialize)]
struct GraphQLError {
    message: String,
    status: Option<i32>,
}

/// Search results wrapper
#[derive(Debug, Deserialize)]
struct SearchData {
    #[serde(rename = "Page")]
    page: PageData,
}

#[derive(Debug, Deserialize)]
struct PageData {
    media: Vec<MediaData>,
}

/// Single anime query wrapper
#[derive(Debug, Deserialize)]
struct AnimeData {
    #[serde(rename = "Media")]
    media: MediaData,
}

/// Media data from AniList
#[derive(Debug, Deserialize)]
struct MediaData {
    id: i64,
    title: TitleData,
    episodes: Option<i32>,
    status: String,
    #[serde(rename = "startDate")]
    start_date: Option<DateData>,
    #[serde(rename = "endDate")]
    end_date: Option<DateData>,
    genres: Vec<String>,
    #[serde(rename = "coverImage")]
    cover_image: CoverImageData,
    description: Option<String>,
}

#[derive(Debug, Deserialize)]
struct TitleData {
    romaji: Option<String>,
    english: Option<String>,
    native: Option<String>,
}

#[derive(Debug, Deserialize)]
struct DateData {
    year: Option<i32>,
    month: Option<i32>,
    day: Option<i32>,
}

#[derive(Debug, Deserialize)]
struct CoverImageData {
    large: String,
}

/// Rate limiter state
struct RateLimiter {
    last_request: Instant,
    min_interval: Duration,
}

impl RateLimiter {
    fn new() -> Self {
        Self {
            last_request: Instant::now() - Duration::from_secs(60),
            min_interval: Duration::from_millis(1000), // 1 request per second
        }
    }
    
    fn wait_if_needed(&mut self) {
        let elapsed = self.last_request.elapsed();
        if elapsed < self.min_interval {
            let wait_time = self.min_interval - elapsed;
            std::thread::sleep(wait_time);
        }
        self.last_request = Instant::now();
    }
}

/// AniList API Client
pub struct AniListClient {
    base_url: String,
    http_client: Client,
    rate_limiter: Arc<Mutex<RateLimiter>>,
    auth_token: Option<String>,
}

impl AniListClient {
    /// Create a new AniList client
    pub fn new() -> Self {
        let http_client = Client::builder()
            .timeout(Duration::from_secs(30))
            .build()
            .expect("Failed to create HTTP client");
        
        Self {
            base_url: "https://graphql.anilist.co".to_string(),
            http_client,
            rate_limiter: Arc::new(Mutex::new(RateLimiter::new())),
            auth_token: None,
        }
    }
    
    /// Create client with authentication token
    pub fn with_auth(token: String) -> Self {
        let mut client = Self::new();
        client.auth_token = Some(token);
        client
    }
    
    /// Search for anime by title
    /// 
    /// Returns up to 10 results
    pub async fn search_anime(&self, query: &str) -> AppResult<Vec<AniListAnime>> {
        // Rate limiting
        {
            let mut limiter = self.rate_limiter.lock().unwrap();
            limiter.wait_if_needed();
        }
        
        // GraphQL query
        let graphql_query = r#"
            query ($search: String) {
                Page(page: 1, perPage: 10) {
                    media(search: $search, type: ANIME) {
                        id
                        title {
                            romaji
                            english
                            native
                        }
                        episodes
                        status
                        startDate {
                            year
                            month
                            day
                        }
                        endDate {
                            year
                            month
                            day
                        }
                        genres
                        coverImage {
                            large
                        }
                        description
                    }
                }
            }
        "#;
        
        let variables = json!({
            "search": query
        });
        
        let response_data: SearchData = self.execute_query(graphql_query, variables).await?;
        
        // Map to AniListAnime
        let animes = response_data.page.media
            .into_iter()
            .map(Self::map_media_to_anime)
            .collect();
        
        Ok(animes)
    }
    
    /// Get anime by AniList ID
    pub async fn get_anime(&self, anilist_id: i64) -> AppResult<AniListAnime> {
        // Rate limiting
        {
            let mut limiter = self.rate_limiter.lock().unwrap();
            limiter.wait_if_needed();
        }
        
        // GraphQL query
        let graphql_query = r#"
            query ($id: Int) {
                Media(id: $id, type: ANIME) {
                    id
                    title {
                        romaji
                        english
                        native
                    }
                    episodes
                    status
                    startDate {
                        year
                        month
                        day
                    }
                    endDate {
                        year
                        month
                        day
                    }
                    genres
                    coverImage {
                        large
                    }
                    description
                }
            }
        "#;
        
        let variables = json!({
            "id": anilist_id
        });
        
        let response_data: AnimeData = self.execute_query(graphql_query, variables).await?;
        
        Ok(Self::map_media_to_anime(response_data.media))
    }
    
    /// Fetch detailed metadata (same as get_anime for now)
    pub async fn fetch_metadata(&self, anilist_id: i64) -> AppResult<AniListAnime> {
        self.get_anime(anilist_id).await
    }
    
    // ========================================================================
    // INTERNAL: GraphQL Execution
    // ========================================================================
    
    /// Execute a GraphQL query
    async fn execute_query<T>(&self, query: &str, variables: serde_json::Value) -> AppResult<T>
    where
        T: for<'de> Deserialize<'de>,
    {
        let body = json!({
            "query": query,
            "variables": variables
        });
        
        // Build request
        let mut request = self.http_client
            .post(&self.base_url)
            .header(header::CONTENT_TYPE, "application/json")
            .header(header::ACCEPT, "application/json");
        
        // Add auth token if present
        if let Some(token) = &self.auth_token {
            request = request.header(header::AUTHORIZATION, format!("Bearer {}", token));
        }
        
        // Send request
        let response = request
            .json(&body)
            .send()
            .await
            .map_err(|e| AppError::Other(format!("AniList API request failed: {}", e)))?;
        
        // Check HTTP status
        if !response.status().is_success() {
            return Err(AppError::Other(format!(
                "AniList API returned status: {}",
                response.status()
            )));
        }
        
        // Parse GraphQL response
        let graphql_response: GraphQLResponse<T> = response
            .json()
            .await
            .map_err(|e| AppError::Other(format!("Failed to parse AniList response: {}", e)))?;
        
        // Check for GraphQL errors
        if let Some(errors) = graphql_response.errors {
            let error_messages: Vec<String> = errors
                .iter()
                .map(|e| e.message.clone())
                .collect();
            
            return Err(AppError::Other(format!(
                "AniList API errors: {}",
                error_messages.join(", ")
            )));
        }
        
        // Extract data
        graphql_response.data
            .ok_or_else(|| AppError::Other("AniList API returned no data".to_string()))
    }
    
    /// Map MediaData to AniListAnime
    fn map_media_to_anime(media: MediaData) -> AniListAnime {
        AniListAnime {
            id: media.id,
            title: AniListTitle {
                romaji: media.title.romaji,
                english: media.title.english,
                native: media.title.native,
            },
            episodes: media.episodes,
            status: media.status,
            start_date: media.start_date.map(|d| AniListDate {
                year: d.year,
                month: d.month,
                day: d.day,
            }),
            end_date: media.end_date.map(|d| AniListDate {
                year: d.year,
                month: d.month,
                day: d.day,
            }),
            genres: media.genres,
            cover_image: media.cover_image.large,
            description: media.description,
        }
    }
}

impl Default for AniListClient {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_client_creation() {
        let client = AniListClient::new();
        assert_eq!(client.base_url, "https://graphql.anilist.co");
        assert!(client.auth_token.is_none());
    }
    
    #[test]
    fn test_client_with_auth() {
        let client = AniListClient::with_auth("test_token".to_string());
        assert!(client.auth_token.is_some());
    }
    
    // Note: Real API tests would be in integration test suite
    // and would use mocked responses or test against real API
}

--- FILE: src-tauri\src\integrations\anilist\mod.rs ---
// src-tauri/src/integrations/anilist/mod.rs

pub mod client;

pub use client::{AniListClient, AniListAnime, AniListTitle, AniListDate};

--- FILE: src-tauri\src\integrations\mod.rs ---
// src-tauri/src/integrations/mod.rs
//
// External Integrations Module
//
// Phase 4: Stub implementations
// Phase 5: Full implementation

pub mod anilist;
pub mod mpv;

pub use anilist::client::{AniListClient, AniListAnime, AniListTitle, AniListDate};
pub use mpv::client::MpvClient;

--- FILE: src-tauri\src\integrations\mpv\client.rs ---
// src-tauri/src/integrations/mpv/client.rs
//
// MPV Player Integration - Windows Implementation
//
// CRITICAL: Uses Windows Named Pipes for IPC as required.
// MPV launched with: --input-ipc-server=\\.\pipe\animehub-mpv
//
// WINDOWS API CONSTRAINTS (MANDATORY):
// - Use slices (&[u8], &mut [u8]) for WriteFile/ReadFile.
// - No raw pointers (as_ptr, as_mut_ptr).
// - No manual buffer lengths.
// - Synchronous IO (None for OVERLAPPED).

use std::path::{Path, PathBuf};
use std::process::{Command, Child, Stdio};
use std::sync::{Arc, Mutex};
use std::ffi::OsStr;
use std::os::windows::ffi::OsStrExt;
use serde::{Deserialize, Serialize};
use serde_json::json;

// Windows API imports from the 'windows' crate
use windows::core::PCWSTR;
use windows::Win32::Foundation::{HANDLE, CloseHandle, INVALID_HANDLE_VALUE};
use windows::Win32::Storage::FileSystem::{
    CreateFileW, ReadFile, WriteFile, FILE_GENERIC_READ, FILE_GENERIC_WRITE,
    FILE_SHARE_READ, FILE_SHARE_WRITE, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
};

use crate::error::{AppError, AppResult};

/// MPV IPC command envelope
#[derive(Debug, Serialize)]
struct MpvCommand {
    command: Vec<serde_json::Value>,
}

/// MPV IPC response envelope
#[derive(Debug, Deserialize)]
struct MpvResponse {
    error: String,
    #[serde(default)]
    data: Option<serde_json::Value>,
}

/// MPV Client for Windows
/// 
/// Handles process lifecycle and IPC communication.
/// Note: This client does not persist domain state or call services.
pub struct MpvClient {
    /// MPV process handle (Arc/Mutex for thread-safe access from commands)
    process: Arc<Mutex<Option<Child>>>,
    /// Predefined pipe name for AnimeHub
    pipe_name: String,
}

impl MpvClient {
    /// Creates a new instance of the MPV client.
    pub fn new() -> AppResult<Self> {
        Ok(Self {
            process: Arc::new(Mutex::new(None)),
            pipe_name: r"\\.\pipe\animehub-mpv".to_string(),
        })
    }

    /// Launches MPV with IPC enabled and starts playback.
    pub fn launch(&self, video_path: PathBuf) -> AppResult<PathBuf> {
        if !video_path.exists() {
            return Err(AppError::Other(format!("Video file not found: {:?}", video_path)));
        }

        // Cleanup existing process
        self.stop()?;

        let mut cmd = Command::new("mpv");
        cmd.arg(format!("--input-ipc-server={}", self.pipe_name))
            .arg("--idle=yes")
            .arg("--force-window=yes")
            .arg("--keep-open=yes")
            .arg(&video_path)
            .stdout(Stdio::null())
            .stderr(Stdio::null());

        let child = cmd.spawn()
            .map_err(|e| AppError::Other(format!("Failed to spawn MPV: {}", e)))?;

        {
            let mut proc_guard = self.process.lock().unwrap();
            *proc_guard = Some(child);
        }

        // Wait for MPV to create the pipe server
        std::thread::sleep(std::time::Duration::from_millis(600));

        Ok(video_path)
    }

    /// Stops playback and kills the MPV process.
    pub fn stop(&self) -> AppResult<()> {
        if self.is_running() {
            let _ = self.send_command(&["quit"]);
        }

        let mut proc_guard = self.process.lock().unwrap();
        if let Some(mut child) = proc_guard.take() {
            let _ = child.kill();
            let _ = child.wait();
        }

        Ok(())
    }

    /// Checks if MPV is currently active.
    pub fn is_running(&self) -> bool {
        let mut proc_guard = self.process.lock().unwrap();
        if let Some(ref mut child) = *proc_guard {
            match child.try_wait() {
                Ok(None) => true,
                _ => {
                    *proc_guard = None;
                    false
                }
            }
        } else {
            false
        }
    }

    // --- Media Control Commands ---

    pub fn pause(&self) -> AppResult<()> {
        self.send_command(&["set_property", "pause", "yes"])?;
        Ok(())
    }

    pub fn resume(&self) -> AppResult<()> {
        self.send_command(&["set_property", "pause", "no"])?;
        Ok(())
    }

    pub fn seek(&self, position_seconds: u64) -> AppResult<()> {
        self.send_command(&["seek", &position_seconds.to_string(), "absolute"])?;
        Ok(())
    }

    pub fn get_position(&self) -> AppResult<u64> {
        let response = self.send_command(&["get_property", "time-pos"])?;
        let pos = response.data
            .and_then(|v| v.as_f64())
            .unwrap_or(0.0);
        Ok(pos as u64)
    }

    pub fn get_duration(&self) -> AppResult<Option<u64>> {
        let response = self.send_command(&["get_property", "duration"])?;
        Ok(response.data.and_then(|v| v.as_f64()).map(|d| d as u64))
    }

    // --- IPC Implementation (Windows Named Pipes) ---

    /// Internal helper to communicate with MPV using the JSON IPC protocol.
    fn send_command(&self, command: &[&str]) -> AppResult<MpvResponse> {
        if !self.is_running() {
            return Err(AppError::Other("MPV is not running".to_string()));
        }

        // 1. Prepare Wide String for Windows API
        let pipe_path: Vec<u16> = OsStr::new(&self.pipe_name)
            .encode_wide()
            .chain(std::iter::once(0))
            .collect();

        // 2. Open the Named Pipe
        let handle = unsafe {
            CreateFileW(
                PCWSTR(pipe_path.as_ptr()),
                FILE_GENERIC_READ.0 | FILE_GENERIC_WRITE.0,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                None, // Security
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                HANDLE::default(),
            )
        }.map_err(|e| AppError::Other(format!("IPC Connection Error: {}", e)))?;

        if handle == INVALID_HANDLE_VALUE {
            return Err(AppError::Other("Invalid Pipe Handle".to_string()));
        }

        // Use RAII guard to ensure handle is closed
        let _guard = HandleGuard(handle);

        // 3. Serialize Command (MPV expects newline-delimited JSON)
        let cmd_json = MpvCommand {
            command: command.iter().map(|&s| json!(s)).collect(),
        };
        let mut payload = serde_json::to_string(&cmd_json)
            .map_err(|e| AppError::Serialization(e))?;
        payload.push('\n');

        // 4. Write to Pipe
        // Exactly as defined by windows crate: handle, Option<&[u8]>, Option<&mut u32>, Option<*mut OVERLAPPED>
        let mut written: u32 = 0;
        unsafe {
            WriteFile(
                handle,
                Some(payload.as_bytes()),
                Some(&mut written),
                None,
            )
        }.map_err(|e| AppError::Other(format!("IPC Write error: {}", e)))?;

        // 5. Read Response
        // Exactly as defined: handle, Option<&mut [u8]>, Option<&mut u32>, Option<*mut OVERLAPPED>
        let mut buffer = [0u8; 2048];
        let mut read: u32 = 0;
        unsafe {
            ReadFile(
                handle,
                Some(&mut buffer),
                Some(&mut read),
                None,
            )
        }.map_err(|e| AppError::Other(format!("IPC Read error: {}", e)))?;

        // 6. Parse and Validate
        let response_str = std::str::from_utf8(&buffer[..(read as usize)])
            .map_err(|_| AppError::Other("IPC response invalid UTF-8".to_string()))?;
        
        let response: MpvResponse = serde_json::from_str(response_str.trim())
            .map_err(|e| AppError::Serialization(e))?;

        if response.error != "success" {
            return Err(AppError::Other(format!("MPV IPC Error: {}", response.error)));
        }

        Ok(response)
    }
}

/// RAII Guard for Windows HANDLEs
struct HandleGuard(HANDLE);
impl Drop for HandleGuard {
    fn drop(&mut self) {
        if !self.0.is_invalid() {
            unsafe { let _ = CloseHandle(self.0); }
        }
    }
}

impl Drop for MpvClient {
    fn drop(&mut self) {
        let _ = self.stop();
    }
}

impl Default for MpvClient {
    fn default() -> Self {
        Self::new().expect("Critical: Failed to initialize MPV Client")
    }
}

--- FILE: src-tauri\src\integrations\mpv\mod.rs ---
// src-tauri/src/integrations/mpv/mod.rs

pub mod client;

pub use client::MpvClient;

--- FILE: src-tauri\src\integrations\mpv\windows.rs ---
use std::ffi::OsStr;
use std::iter::once;
use std::os::windows::ffi::OsStrExt;
use std::path::PathBuf;
use std::ptr::null_mut;
use std::process::{Command, Child};
use std::io::{Read, Write};

use windows::Win32::Foundation::*;
use windows::Win32::Storage::FileSystem::*;
use windows::Win32::System::Pipes::*;

use anyhow::{Result, anyhow};

const PIPE_NAME: &str = r"\\.\pipe\mpv-animehub";

pub struct MpvClient {
    process: Child,
    pipe: HANDLE,
}

impl MpvClient {
    pub fn launch(video: PathBuf) -> Result<Self> {
        let mut process = Command::new("mpv")
            .arg(video)
            .arg(format!("--input-ipc-server={}", PIPE_NAME))
            .spawn()
            .map_err(|e| anyhow!("Failed to start mpv: {}", e))?;

        // Espera MPV criar o pipe
        let pipe = loop {
            let wide: Vec<u16> = OsStr::new(PIPE_NAME)
                .encode_wide()
                .chain(once(0))
                .collect();

            unsafe {
                let handle = CreateFileW(
                    PCWSTR(wide.as_ptr()),
                    FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    None,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    None,
                );

                if handle != INVALID_HANDLE_VALUE {
                    break handle;
                }
            }

            std::thread::sleep(std::time::Duration::from_millis(50));
        };

        Ok(Self { process, pipe })
    }

    pub fn send(&self, command: &str) -> Result<()> {
        let mut bytes = command.as_bytes().to_vec();
        bytes.push(b'\n');

        unsafe {
            let mut written = 0;
            WriteFile(
                self.pipe,
                Some(bytes.as_ptr() as _),
                bytes.len() as u32,
                Some(&mut written),
                None,
            )
            .ok()
            .map_err(|_| anyhow!("Failed to write to MPV pipe"))?;
        }

        Ok(())
    }

    pub fn pause(&self) -> Result<()> {
        self.send(r#"{"command":["set_property","pause",true]}"#)
    }

    pub fn resume(&self) -> Result<()> {
        self.send(r#"{"command":["set_property","pause",false]}"#)
    }

    pub fn seek(&self, seconds: i64) -> Result<()> {
        self.send(&format!(
            r#"{{"command":["seek",{}, "absolute"]}}"#,
            seconds
        ))
    }

    pub fn stop(&mut self) -> Result<()> {
        self.send(r#"{"command":["quit"]}"#)?;
        self.process.kill().ok();
        unsafe { CloseHandle(self.pipe) };
        Ok(())
    }
}


--- FILE: src-tauri\src\lib.rs ---
// src-tauri/src/lib.rs
// AnimeHub - Local-first anime library manager
//
// Architecture:
// - Domain-centric: All business logic lives in domains (SEALED - Phase 3)
// - Event-driven: Services coordinate through events (SEALED - Phase 3)
// - Explicit: No implicit behavior, no magic
// - Local-first: User controls all data
// - Application Layer: UI boundary (NEW - Phase 4)

// ============================================================================
// SEALED FOUNDATION (Phase 3)
// ============================================================================

pub mod domain;
pub mod error;
pub mod events;
pub mod db;
pub mod repositories;
pub mod infrastructure;
pub mod services;

// ============================================================================
// APPLICATION LAYER (Phase 4)
// ============================================================================

pub mod application;
pub mod integrations;

// ============================================================================
// PUBLIC API - Domain Entities (Sealed)
// ============================================================================

pub use domain::*;

// ============================================================================
// PUBLIC API - Error Types (Sealed)
// ============================================================================

pub use error::{AppError, AppResult};

// ============================================================================
// PUBLIC API - Events (Sealed)
// ============================================================================

pub use events::{
    EventBus,
    create_event_bus,
    DomainEvent,
    // Common events
    AnimeCreated,
    EpisodeCreated,
    PlaybackStarted,
    EpisodeCompleted,
};

// ============================================================================
// PUBLIC API - Database (Sealed)
// ============================================================================

pub use db::{
    ConnectionPool,
    create_connection_pool,
    initialize_database,
};

// ============================================================================
// PUBLIC API - Repositories (Sealed)
// ============================================================================

pub use repositories::{
    AnimeRepository,
    SqliteAnimeRepository,
    EpisodeRepository,
    SqliteEpisodeRepository,
    FileRepository,
    SqliteFileRepository,
    SubtitleRepository,
    SqliteSubtitleRepository,
    CollectionRepository,
    SqliteCollectionRepository,
    ExternalReferenceRepository,
    SqliteExternalReferenceRepository,
    AnimeAliasRepository,
    SqliteAnimeAliasRepository,
    StatisticsRepository,
    SqliteStatisticsRepository,
};

// ============================================================================
// PUBLIC API - Infrastructure (Sealed)
// ============================================================================

pub use infrastructure::{
    SubtitleWorkspace,
    SubtitleWorkspaceCreated,
    SubtitleWorkspaceCleaned,
};

// ============================================================================
// PUBLIC API - Services (Sealed)
// ============================================================================

pub use services::{
    // Anime Service
    AnimeService,
    CreateAnimeRequest,
    UpdateAnimeRequest,
    MergeAnimesRequest,
    
    // Episode Service
    EpisodeService,
    CreateEpisodeRequest,
    UpdateEpisodeMetadataRequest,
    LinkFileRequest,
    
    // File Service
    FileService,
    RegisterFileRequest,
    
    // Playback Service
    PlaybackService,
    StartPlaybackRequest,
    
    // Statistics Service
    StatisticsService,
    
    // External Integration Service
    ExternalIntegrationService,
    FetchMetadataRequest,
    LinkExternalReferenceRequest,
    ExternalMetadata,
    MetadataSuggestions,
    
    // Subtitle Service
    SubtitleService,
    StyleTransformRequest,
    TimingTransformRequest,
};

// ============================================================================
// PUBLIC API - Application Layer (Phase 4)
// ============================================================================

pub use application::{
    AppState,
    dto::*,
    commands::*,
};

// ============================================================================
// PUBLIC API - Integrations (Phase 4 - Stubs)
// ============================================================================

pub use integrations::{
    AniListClient,
    AniListAnime,
    MpvClient,
};

--- FILE: src-tauri\src\main.rs ---
// src-tauri/src/main.rs
// CORRECTED VERSION

#![cfg_attr(
    all(not(debug_assertions), target_os = "windows"),
    windows_subsystem = "windows"
)]

use std::sync::Arc;

// --- Corrected Imports ---
// Direct imports for Tauri command handler macro
use animehub::application::commands::*;
// Correct path for database module
use animehub::db::{create_connection_pool, initialize_database};
// All other necessary components for initialization
use animehub::application::state::AppState;
use animehub::events::EventBus;
use animehub::integrations::MpvClient;
use animehub::repositories::*;
use animehub::services::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. INFRASTRUCTURE
    let event_bus = Arc::new(EventBus::new());
    let pool = Arc::new(create_connection_pool()?);
    let mpv_client = Arc::new(MpvClient::new()?);
    
    // Initialize schema (idempotent)
    {
        let conn = pool.get()?;
        initialize_database(&conn)?;
    }

    // 2. REPOSITORIES
    // The type `Arc<dyn Trait>` is used to match the service constructor signatures exactly.
    let anime_repo: Arc<dyn AnimeRepository> = Arc::new(SqliteAnimeRepository::new(pool.clone()));
    let episode_repo: Arc<dyn EpisodeRepository> = Arc::new(SqliteEpisodeRepository::new(pool.clone()));
    let file_repo: Arc<dyn FileRepository> = Arc::new(SqliteFileRepository::new(pool.clone()));
    let subtitle_repo: Arc<dyn SubtitleRepository> = Arc::new(SqliteSubtitleRepository::new(pool.clone()));
    let collection_repo: Arc<dyn CollectionRepository> = Arc::new(SqliteCollectionRepository::new(pool.clone()));
    let external_ref_repo: Arc<dyn ExternalReferenceRepository> = Arc::new(SqliteExternalReferenceRepository::new(pool.clone()));
    let anime_alias_repo: Arc<dyn AnimeAliasRepository> = Arc::new(SqliteAnimeAliasRepository::new(pool.clone()));
    let statistics_repo: Arc<dyn StatisticsRepository> = Arc::new(SqliteStatisticsRepository::new(pool.clone()));

    // 3. SERVICES
    let anime_service = Arc::new(AnimeService::new(
        anime_repo.clone(),
        anime_alias_repo.clone(),
        external_ref_repo.clone(),
        event_bus.clone(),
    ));
    let episode_service = Arc::new(EpisodeService::new(
        episode_repo.clone(),
        anime_repo.clone(),
        file_repo.clone(),
        event_bus.clone(),
    ));
    let file_service = Arc::new(FileService::new(file_repo.clone(), event_bus.clone()));
    let playback_service = Arc::new(PlaybackService::new(
        episode_repo.clone(),
        file_repo.clone(),
        event_bus.clone(),
        mpv_client.clone(),
    ));
    let statistics_service = Arc::new(StatisticsService::new(
        statistics_repo.clone(),
        anime_repo.clone(),
        episode_repo.clone(),
        event_bus.clone(),
    ));
    let external_integration_service = Arc::new(ExternalIntegrationService::new(
        external_ref_repo.clone(),
        anime_repo.clone(),
        event_bus.clone(),
    ));
    let subtitle_service = Arc::new(SubtitleService::new(
        subtitle_repo.clone(),
        file_repo.clone(),
        event_bus.clone(),
    ));

    // 4. EVENT HANDLER REGISTRATION (WIRING)
    episode_service.register_event_handlers();
    statistics_service.register_event_handlers();

    // 5. APPLICATION STATE
    let app_state = AppState {
        event_bus,
        anime_service,
        episode_service,
        file_service,
        playback_service,
        statistics_service,
        external_integration_service,
        subtitle_service,
    };

    // 6. TAURI BOOTSTRAP
    tauri::Builder::default()
        .manage(app_state)
        .invoke_handler(tauri::generate_handler![
            // Commands are now in scope via `use` statements
            list_animes,
            get_anime,
            create_anime,
            update_anime,
            list_episodes,
            get_episode,
            create_episode,
            update_progress,
            mark_episode_completed,
            reset_episode_progress,
            scan_directory,
            get_episode_files,
            start_playback,
            toggle_pause_playback,
            seek_playback,
            stop_playback,
            get_episode_progress,
            get_global_statistics,
        ])
        .run(tauri::generate_context!())?;

    Ok(())
}


--- FILE: src-tauri\src\repositories\anime_alias_repository.rs ---
// src-tauri/src/repositories/anime_alias_repository.rs

use std::sync::Arc;
use rusqlite::params;
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::db::ConnectionPool;
use crate::domain::AnimeAlias;
use crate::error::{AppError, AppResult};

pub trait AnimeAliasRepository: Send + Sync {
    fn save(&self, alias: &AnimeAlias) -> AppResult<()>;
    fn get_principal_for_alias(&self, anime_alias_id: Uuid) -> AppResult<Option<Uuid>>;
    fn list_aliases_for_principal(&self, anime_principal_id: Uuid) -> AppResult<Vec<AnimeAlias>>;
}

pub struct SqliteAnimeAliasRepository {
    pool: Arc<ConnectionPool>,
}

impl SqliteAnimeAliasRepository {
    pub fn new(pool: Arc<ConnectionPool>) -> Self {
        Self { pool }
    }
}

impl AnimeAliasRepository for SqliteAnimeAliasRepository {
    fn save(&self, alias: &AnimeAlias) -> AppResult<()> {
        let conn = self.pool.get()?;
        
        conn.execute(
            "INSERT OR REPLACE INTO anime_aliases (id, anime_principal_id, anime_alias_id, criado_em)
             VALUES (?1, ?2, ?3, ?4)",
            params![
                alias.id.to_string(),
                alias.anime_principal_id.to_string(),
                alias.anime_alias_id.to_string(),
                alias.criado_em.to_rfc3339(),
            ]
        )?;
        
        Ok(())
    }
    
    fn get_principal_for_alias(&self, anime_alias_id: Uuid) -> AppResult<Option<Uuid>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare(
            "SELECT anime_principal_id FROM anime_aliases WHERE anime_alias_id = ?1"
        )?;
        
        match stmt.query_row(params![anime_alias_id.to_string()], |row| {
            let id_str: String = row.get(0)?;
            Ok(id_str)
        }) {
            Ok(id_str) => Ok(Some(Uuid::parse_str(&id_str)?)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(e) => Err(AppError::Database(e)),
        }
    }
    
    fn list_aliases_for_principal(&self, anime_principal_id: Uuid) -> AppResult<Vec<AnimeAlias>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare(
            "SELECT id, anime_principal_id, anime_alias_id, criado_em 
             FROM anime_aliases 
             WHERE anime_principal_id = ?1"
        )?;
        
        let aliases: Vec<AnimeAlias> = stmt.query_map(
            params![anime_principal_id.to_string()],
            |row| {
                let id = Uuid::parse_str(&row.get::<_, String>(0)?)
                    .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
                let principal_id = Uuid::parse_str(&row.get::<_, String>(1)?)
                    .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
                let alias_id = Uuid::parse_str(&row.get::<_, String>(2)?)
                    .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
                let criado_em = DateTime::parse_from_rfc3339(&row.get::<_, String>(3)?)
                    .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?
                    .with_timezone(&Utc);
                
                Ok(AnimeAlias {
                    id,
                    anime_principal_id: principal_id,
                    anime_alias_id: alias_id,
                    criado_em,
                })
            }
        )?
        .collect::<Result<Vec<_>, _>>()?;
        
        Ok(aliases)
    }
}

--- FILE: src-tauri\src\repositories\anime_repository.rs ---
// src-tauri/src/repositories/anime_repository.rs
//
// Anime persistence - Fixed error conversion

use std::sync::Arc;
use rusqlite::{params, Row};
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::db::ConnectionPool;
use crate::domain::anime::{Anime, AnimeType, AnimeStatus};
use crate::error::{AppError, AppResult};

pub trait AnimeRepository: Send + Sync {
    fn save(&self, anime: &Anime) -> AppResult<()>;
    fn get_by_id(&self, id: Uuid) -> AppResult<Option<Anime>>;
    fn list_all(&self) -> AppResult<Vec<Anime>>;
    fn list_by_status(&self, status: AnimeStatus) -> AppResult<Vec<Anime>>;
    fn list_by_type(&self, tipo: AnimeType) -> AppResult<Vec<Anime>>;
    fn delete(&self, id: Uuid) -> AppResult<()>;
    fn exists(&self, id: Uuid) -> AppResult<bool>;
}

pub struct SqliteAnimeRepository {
    pool: Arc<ConnectionPool>,
}

impl SqliteAnimeRepository {
    pub fn new(pool: Arc<ConnectionPool>) -> Self {
        Self { pool }
    }
    
    /// Map database row to Anime - returns rusqlite::Error for query_map compatibility
    fn row_to_anime(row: &Row) -> Result<Anime, rusqlite::Error> {
        let id_str: String = row.get("id")?;
        let id = Uuid::parse_str(&id_str)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
        
        let titulo_principal: String = row.get("titulo_principal")?;
        
        let titulos_alt_json: String = row.get("titulos_alternativos")?;
        let titulos_alternativos: Vec<String> = serde_json::from_str(&titulos_alt_json)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
        
        let tipo_str: String = row.get("tipo")?;
        let tipo = match tipo_str.as_str() {
            "TV" => AnimeType::TV,
            "Movie" => AnimeType::Movie,
            "OVA" => AnimeType::OVA,
            "Special" => AnimeType::Special,
            _ => return Err(rusqlite::Error::InvalidQuery),
        };
        
        let status_str: String = row.get("status")?;
        let status = match status_str.as_str() {
            "em_exibicao" => AnimeStatus::EmExibicao,
            "finalizado" => AnimeStatus::Finalizado,
            "cancelado" => AnimeStatus::Cancelado,
            _ => return Err(rusqlite::Error::InvalidQuery),
        };
        
        let total_episodios: Option<i64> = row.get("total_episodios")?;
        let total_episodios = total_episodios.map(|v| v as u32);
        
        let data_inicio_str: Option<String> = row.get("data_inicio")?;
        let data_inicio = data_inicio_str
            .map(|s| DateTime::parse_from_rfc3339(&s)
                .map(|dt| dt.with_timezone(&Utc))
                .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e))))
            .transpose()?;
        
        let data_fim_str: Option<String> = row.get("data_fim")?;
        let data_fim = data_fim_str
            .map(|s| DateTime::parse_from_rfc3339(&s)
                .map(|dt| dt.with_timezone(&Utc))
                .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e))))
            .transpose()?;
        
        let metadados_json: String = row.get("metadados_livres")?;
        let metadados_livres: serde_json::Value = serde_json::from_str(&metadados_json)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
        
        let criado_em_str: String = row.get("criado_em")?;
        let criado_em = DateTime::parse_from_rfc3339(&criado_em_str)
            .map(|dt| dt.with_timezone(&Utc))
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
        
        let atualizado_em_str: String = row.get("atualizado_em")?;
        let atualizado_em = DateTime::parse_from_rfc3339(&atualizado_em_str)
            .map(|dt| dt.with_timezone(&Utc))
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
        
        Ok(Anime {
            id,
            titulo_principal,
            titulos_alternativos,
            tipo,
            status,
            total_episodios,
            data_inicio,
            data_fim,
            metadados_livres,
            criado_em,
            atualizado_em,
        })
    }
}

impl AnimeRepository for SqliteAnimeRepository {
    fn save(&self, anime: &Anime) -> AppResult<()> {
        let conn = self.pool.get()?;
        
        let titulos_alt_json = serde_json::to_string(&anime.titulos_alternativos)?;
        let metadados_json = serde_json::to_string(&anime.metadados_livres)?;
        
        conn.execute(
            "INSERT OR REPLACE INTO anime (
                id, titulo_principal, titulos_alternativos, tipo, status,
                total_episodios, data_inicio, data_fim, metadados_livres,
                criado_em, atualizado_em
            ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)",
            params![
                anime.id.to_string(),
                anime.titulo_principal,
                titulos_alt_json,
                anime.tipo.to_string(),
                anime.status.to_string(),
                anime.total_episodios.map(|v| v as i64),
                anime.data_inicio.map(|dt| dt.to_rfc3339()),
                anime.data_fim.map(|dt| dt.to_rfc3339()),
                metadados_json,
                anime.criado_em.to_rfc3339(),
                anime.atualizado_em.to_rfc3339(),
            ]
        )?;
        
        Ok(())
    }
    
    fn get_by_id(&self, id: Uuid) -> AppResult<Option<Anime>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare(
            "SELECT id, titulo_principal, titulos_alternativos, tipo, status,
                    total_episodios, data_inicio, data_fim, metadados_livres,
                    criado_em, atualizado_em
             FROM anime WHERE id = ?1"
        )?;
        
        match stmt.query_row(params![id.to_string()], Self::row_to_anime) {
            Ok(anime) => Ok(Some(anime)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(e) => Err(AppError::Database(e)),
        }
    }
    
    fn list_all(&self) -> AppResult<Vec<Anime>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare(
            "SELECT id, titulo_principal, titulos_alternativos, tipo, status,
                    total_episodios, data_inicio, data_fim, metadados_livres,
                    criado_em, atualizado_em
             FROM anime
             ORDER BY titulo_principal"
        )?;
        
        let animes: Vec<Anime> = stmt.query_map([], Self::row_to_anime)?
            .collect::<Result<Vec<_>, _>>()?;
        
        Ok(animes)
    }
    
    fn list_by_status(&self, status: AnimeStatus) -> AppResult<Vec<Anime>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare(
            "SELECT id, titulo_principal, titulos_alternativos, tipo, status,
                    total_episodios, data_inicio, data_fim, metadados_livres,
                    criado_em, atualizado_em
             FROM anime
             WHERE status = ?1
             ORDER BY titulo_principal"
        )?;
        
        let animes: Vec<Anime> = stmt.query_map(params![status.to_string()], Self::row_to_anime)?
            .collect::<Result<Vec<_>, _>>()?;
        
        Ok(animes)
    }
    
    fn list_by_type(&self, tipo: AnimeType) -> AppResult<Vec<Anime>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare(
            "SELECT id, titulo_principal, titulos_alternativos, tipo, status,
                    total_episodios, data_inicio, data_fim, metadados_livres,
                    criado_em, atualizado_em
             FROM anime
             WHERE tipo = ?1
             ORDER BY titulo_principal"
        )?;
        
        let animes: Vec<Anime> = stmt.query_map(params![tipo.to_string()], Self::row_to_anime)?
            .collect::<Result<Vec<_>, _>>()?;
        
        Ok(animes)
    }
    
    fn delete(&self, id: Uuid) -> AppResult<()> {
    let conn = self.pool.get()?;
    
    let rows_affected = conn.execute(
        "DELETE FROM anime WHERE id = ?1",
        params![id.to_string()]
    )?;
    
    if rows_affected == 0 {
        // âœ… FIXED: Changed from AppError::not_found(...) to AppError::NotFound
        return Err(AppError::NotFound);
    }
    
    Ok(())
    }
    
    fn exists(&self, id: Uuid) -> AppResult<bool> {
        let conn = self.pool.get()?;
        
        let count: i64 = conn.query_row(
            "SELECT COUNT(*) FROM anime WHERE id = ?1",
            params![id.to_string()],
            |row| row.get(0)
        )?;
        
        Ok(count > 0)
    }
}

--- FILE: src-tauri\src\repositories\collection_repository.rs ---
// src-tauri/src/repositories/collection_repository.rs

use std::sync::Arc;
use rusqlite::{params, Row};
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::db::ConnectionPool;
use crate::domain::collection::Collection;
use crate::error::{AppError, AppResult};

pub trait CollectionRepository: Send + Sync {
    fn save(&self, collection: &Collection) -> AppResult<()>;
    fn get_by_id(&self, id: Uuid) -> AppResult<Option<Collection>>;
    fn list_all(&self) -> AppResult<Vec<Collection>>;
    fn delete(&self, id: Uuid) -> AppResult<()>;
    fn add_anime(&self, collection_id: Uuid, anime_id: Uuid) -> AppResult<()>;
    fn remove_anime(&self, collection_id: Uuid, anime_id: Uuid) -> AppResult<()>;
    fn list_anime_in_collection(&self, collection_id: Uuid) -> AppResult<Vec<Uuid>>;
    fn list_collections_for_anime(&self, anime_id: Uuid) -> AppResult<Vec<Uuid>>;
}

pub struct SqliteCollectionRepository {
    pool: Arc<ConnectionPool>,
}

impl SqliteCollectionRepository {
    pub fn new(pool: Arc<ConnectionPool>) -> Self {
        Self { pool }
    }
    
    fn row_to_collection(row: &Row) -> Result<Collection, rusqlite::Error> {
        let id = Uuid::parse_str(&row.get::<_, String>("id")?)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
        let nome: String = row.get("nome")?;
        let descricao: Option<String> = row.get("descricao")?;
        
        let criado_em = DateTime::parse_from_rfc3339(&row.get::<_, String>("criado_em")?)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?
            .with_timezone(&Utc);
        
        Ok(Collection {
            id,
            nome,
            descricao,
            criado_em,
        })
    }
}

impl CollectionRepository for SqliteCollectionRepository {
    fn save(&self, collection: &Collection) -> AppResult<()> {
        let conn = self.pool.get()?;
        
        conn.execute(
            "INSERT OR REPLACE INTO collections (id, nome, descricao, criado_em)
             VALUES (?1, ?2, ?3, ?4)",
            params![
                collection.id.to_string(),
                collection.nome,
                collection.descricao,
                collection.criado_em.to_rfc3339(),
            ]
        )?;
        
        Ok(())
    }
    
    fn get_by_id(&self, id: Uuid) -> AppResult<Option<Collection>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare("SELECT * FROM collections WHERE id = ?1")?;
        
        match stmt.query_row(params![id.to_string()], Self::row_to_collection) {
            Ok(col) => Ok(Some(col)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(e) => Err(AppError::Database(e)),
        }
    }
    
    fn list_all(&self) -> AppResult<Vec<Collection>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare("SELECT * FROM collections ORDER BY nome")?;
        
        let collections: Vec<Collection> = stmt.query_map([], Self::row_to_collection)?
            .collect::<Result<Vec<_>, _>>()?;
        
        Ok(collections)
    }
    
    fn delete(&self, id: Uuid) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute("DELETE FROM collections WHERE id = ?1", params![id.to_string()])?;
        Ok(())
    }
    
    fn add_anime(&self, collection_id: Uuid, anime_id: Uuid) -> AppResult<()> {
        let conn = self.pool.get()?;
        
        conn.execute(
            "INSERT OR IGNORE INTO anime_collections (anime_id, collection_id, criado_em)
             VALUES (?1, ?2, datetime('now'))",
            params![anime_id.to_string(), collection_id.to_string()]
        )?;
        
        Ok(())
    }
    
    fn remove_anime(&self, collection_id: Uuid, anime_id: Uuid) -> AppResult<()> {
        let conn = self.pool.get()?;
        
        conn.execute(
            "DELETE FROM anime_collections WHERE collection_id = ?1 AND anime_id = ?2",
            params![collection_id.to_string(), anime_id.to_string()]
        )?;
        
        Ok(())
    }
    
    fn list_anime_in_collection(&self, collection_id: Uuid) -> AppResult<Vec<Uuid>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare(
            "SELECT anime_id FROM anime_collections WHERE collection_id = ?1"
        )?;
        
        let anime_ids: Vec<Uuid> = stmt.query_map(params![collection_id.to_string()], |row| {
            let id_str: String = row.get(0)?;
            Uuid::parse_str(&id_str)
                .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))
        })?
        .collect::<Result<Vec<_>, _>>()?;
        
        Ok(anime_ids)
    }
    
    fn list_collections_for_anime(&self, anime_id: Uuid) -> AppResult<Vec<Uuid>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare(
            "SELECT collection_id FROM anime_collections WHERE anime_id = ?1"
        )?;
        
        let collection_ids: Vec<Uuid> = stmt.query_map(params![anime_id.to_string()], |row| {
            let id_str: String = row.get(0)?;
            Uuid::parse_str(&id_str)
                .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))
        })?
        .collect::<Result<Vec<_>, _>>()?;
        
        Ok(collection_ids)
    }
}

--- FILE: src-tauri\src\repositories\episode_repository.rs ---
use crate::domain::episode::{Episode, EpisodeNumber, EpisodeState};
use crate::error::AppResult;
use r2d2::Pool;
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::{params, Row};
use std::sync::Arc;
use chrono::{DateTime, Utc};
use uuid::Uuid;

pub trait EpisodeRepository: Send + Sync {
    fn save(&self, episode: &Episode) -> AppResult<()>;
    fn get_by_id(&self, id: Uuid) -> AppResult<Option<Episode>>;
    fn list_by_anime(&self, anime_id: Uuid) -> AppResult<Vec<Episode>>;
    fn list_by_state(&self, anime_id: Uuid, state: EpisodeState) -> AppResult<Vec<Episode>>;
    fn delete(&self, id: Uuid) -> AppResult<()>;
    fn exists(&self, id: Uuid) -> AppResult<bool>;
    fn count_by_anime(&self, anime_id: Uuid) -> AppResult<usize>;
    fn count_completed(&self, anime_id: Uuid) -> AppResult<usize>;
    fn link_file(&self, episode_id: Uuid, file_id: Uuid, is_primary: bool) -> AppResult<()>;
    fn unlink_file(&self, episode_id: Uuid, file_id: Uuid) -> AppResult<()>;
    fn get_linked_files(&self, episode_id: Uuid) -> AppResult<Vec<(Uuid, bool)>>;
}

pub struct SqliteEpisodeRepository {
    pool: Arc<Pool<SqliteConnectionManager>>,
}

impl SqliteEpisodeRepository {
    pub fn new(pool: Arc<Pool<SqliteConnectionManager>>) -> Self {
        Self { pool }
    }

    fn row_to_episode(row: &Row) -> rusqlite::Result<Episode> {
        let id_str: String = row.get("id")?;
        let anime_id_str: String = row.get("anime_id")?;
        let numero_tipo: String = row.get("numero_tipo")?;
        let numero_valor: String = row.get("numero_valor")?;
        let estado_str: String = row.get("estado")?;

        let numero = match numero_tipo.as_str() {
            "regular" => EpisodeNumber::Regular { 
                numero: numero_valor.parse().unwrap_or(0) 
            },
            _ => EpisodeNumber::Special { label: numero_valor },
        };

        let estado = match estado_str.as_str() {
            "em_progresso" => EpisodeState::EmProgresso,
            "concluido" => EpisodeState::Concluido,
            _ => EpisodeState::NaoVisto,
        };

        Ok(Episode {
            id: Uuid::parse_str(&id_str).unwrap_or_default(),
            anime_id: Uuid::parse_str(&anime_id_str).unwrap_or_default(),
            numero,
            titulo: row.get("titulo")?,
            duracao_esperada: row.get::<_, Option<i64>>("duracao_esperada")?.map(|d| d as u64),
            progresso_atual: row.get::<_, i64>("progresso_atual")? as u64,
            estado,
            criado_em: DateTime::parse_from_rfc3339(&row.get::<_, String>("criado_em")?)
                .map(|dt| dt.with_timezone(&Utc)).unwrap_or_else(|_| Utc::now()),
            atualizado_em: DateTime::parse_from_rfc3339(&row.get::<_, String>("atualizado_em")?)
                .map(|dt| dt.with_timezone(&Utc)).unwrap_or_else(|_| Utc::now()),
        })
    }
}

impl EpisodeRepository for SqliteEpisodeRepository {
    fn save(&self, ep: &Episode) -> AppResult<()> {
        let conn = self.pool.get()?;
        let (num_tipo, num_val) = match &ep.numero {
            EpisodeNumber::Regular { numero } => ("regular", numero.to_string()),
            EpisodeNumber::Special { label } => ("special", label.clone()),
        };

        conn.execute(
            "INSERT OR REPLACE INTO episodes (id, anime_id, numero_tipo, numero_valor, titulo, duracao_esperada, progresso_atual, estado, criado_em, atualizado_em)
             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)",
            params![
                ep.id.to_string(),
                ep.anime_id.to_string(),
                num_tipo,
                num_val,
                ep.titulo,
                ep.duracao_esperada.map(|d| d as i64),
                ep.progresso_atual as i64,
                ep.estado.to_string(),
                ep.criado_em.to_rfc3339(),
                ep.atualizado_em.to_rfc3339()
            ],
        )?;
        Ok(())
    }

    fn get_by_id(&self, id: Uuid) -> AppResult<Option<Episode>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT * FROM episodes WHERE id = ?1")?;
        let mut rows = stmt.query(params![id.to_string()])?;
        if let Some(row) = rows.next()? {
            Ok(Some(Self::row_to_episode(row)?))
        } else {
            Ok(None)
        }
    }

    fn list_by_anime(&self, anime_id: Uuid) -> AppResult<Vec<Episode>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT * FROM episodes WHERE anime_id = ?1 ORDER BY numero_valor ASC")?;
        let episodes = stmt.query_map(params![anime_id.to_string()], Self::row_to_episode)?
            .collect::<Result<Vec<_>, _>>()?;
        Ok(episodes)
    }

    fn list_by_state(&self, anime_id: Uuid, state: EpisodeState) -> AppResult<Vec<Episode>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT * FROM episodes WHERE anime_id = ?1 AND estado = ?2")?;
        let episodes = stmt.query_map(params![anime_id.to_string(), state.to_string()], Self::row_to_episode)?
            .collect::<Result<Vec<_>, _>>()?;
        Ok(episodes)
    }

    fn delete(&self, id: Uuid) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute("DELETE FROM episodes WHERE id = ?1", params![id.to_string()])?;
        Ok(())
    }

    fn exists(&self, id: Uuid) -> AppResult<bool> {
        let conn = self.pool.get()?;
        let count: i64 = conn.query_row(
            "SELECT COUNT(*) FROM episodes WHERE id = ?1",
            params![id.to_string()],
            |row| row.get(0),
        )?;
        Ok(count > 0)
    }

    fn count_by_anime(&self, anime_id: Uuid) -> AppResult<usize> {
        let conn = self.pool.get()?;
        let count: i64 = conn.query_row(
            "SELECT COUNT(*) FROM episodes WHERE anime_id = ?1",
            params![anime_id.to_string()],
            |row| row.get(0),
        )?;
        Ok(count as usize)
    }

    fn count_completed(&self, anime_id: Uuid) -> AppResult<usize> {
        let conn = self.pool.get()?;
        let count: i64 = conn.query_row(
            "SELECT COUNT(*) FROM episodes WHERE anime_id = ?1 AND estado = 'concluido'",
            params![anime_id.to_string()],
            |row| row.get(0),
        )?;
        Ok(count as usize)
    }

    fn link_file(&self, episode_id: Uuid, file_id: Uuid, is_primary: bool) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute(
            "INSERT OR REPLACE INTO episode_files (episode_id, file_id, is_primary, criado_em) VALUES (?1, ?2, ?3, ?4)",
            params![episode_id.to_string(), file_id.to_string(), is_primary, Utc::now().to_rfc3339()],
        )?;
        Ok(())
    }

    fn unlink_file(&self, episode_id: Uuid, file_id: Uuid) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute(
            "DELETE FROM episode_files WHERE episode_id = ?1 AND file_id = ?2",
            params![episode_id.to_string(), file_id.to_string()],
        )?;
        Ok(())
    }

    fn get_linked_files(&self, episode_id: Uuid) -> AppResult<Vec<(Uuid, bool)>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT file_id, is_primary FROM episode_files WHERE episode_id = ?1")?;
        let rows = stmt.query_map(params![episode_id.to_string()], |row| {
            let id_str: String = row.get(0)?;
            Ok((Uuid::parse_str(&id_str).unwrap_or_default(), row.get(1)?))
        })?;
        let mut links = Vec::new();
        for link in rows { links.push(link?); }
        Ok(links)
    }
}

--- FILE: src-tauri\src\repositories\external_reference_repository.rs ---
// src-tauri/src/repositories/external_reference_repository.rs

use std::sync::Arc;
use rusqlite::{params, Row};
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::db::ConnectionPool;
use crate::domain::ExternalReference;
use crate::error::{AppError, AppResult};

pub trait ExternalReferenceRepository: Send + Sync {
    fn save(&self, reference: &ExternalReference) -> AppResult<()>;
    fn get_by_anime_and_source(&self, anime_id: Uuid, fonte: &str) -> AppResult<Option<ExternalReference>>;
    fn list_by_anime(&self, anime_id: Uuid) -> AppResult<Vec<ExternalReference>>;
    fn delete(&self, id: Uuid) -> AppResult<()>;
}

pub struct SqliteExternalReferenceRepository {
    pool: Arc<ConnectionPool>,
}

impl SqliteExternalReferenceRepository {
    pub fn new(pool: Arc<ConnectionPool>) -> Self {
        Self { pool }
    }
    
    fn row_to_reference(row: &Row) -> Result<ExternalReference, rusqlite::Error> {
        let id = Uuid::parse_str(&row.get::<_, String>("id")?)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
        let anime_id = Uuid::parse_str(&row.get::<_, String>("anime_id")?)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
        
        let fonte: String = row.get("fonte")?;
        let external_id: String = row.get("external_id")?;
        
        let criado_em = DateTime::parse_from_rfc3339(&row.get::<_, String>("criado_em")?)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?
            .with_timezone(&Utc);
        
        Ok(ExternalReference {
            id,
            anime_id,
            fonte,
            external_id,
            criado_em,
        })
    }
}

impl ExternalReferenceRepository for SqliteExternalReferenceRepository {
    fn save(&self, reference: &ExternalReference) -> AppResult<()> {
        let conn = self.pool.get()?;
        
        conn.execute(
            "INSERT OR REPLACE INTO external_references (id, anime_id, fonte, external_id, criado_em)
             VALUES (?1, ?2, ?3, ?4, ?5)",
            params![
                reference.id.to_string(),
                reference.anime_id.to_string(),
                reference.fonte,
                reference.external_id,
                reference.criado_em.to_rfc3339(),
            ]
        )?;
        
        Ok(())
    }
    
    fn get_by_anime_and_source(&self, anime_id: Uuid, fonte: &str) -> AppResult<Option<ExternalReference>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare(
            "SELECT * FROM external_references WHERE anime_id = ?1 AND fonte = ?2"
        )?;
        
        match stmt.query_row(params![anime_id.to_string(), fonte], Self::row_to_reference) {
            Ok(reference) => Ok(Some(reference)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(e) => Err(AppError::Database(e)),
        }
    }
    
    fn list_by_anime(&self, anime_id: Uuid) -> AppResult<Vec<ExternalReference>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare(
            "SELECT * FROM external_references WHERE anime_id = ?1"
        )?;
        
        let refs: Vec<ExternalReference> = stmt.query_map(params![anime_id.to_string()], Self::row_to_reference)?
            .collect::<Result<Vec<_>, _>>()?;
        
        Ok(refs)
    }
    
    fn delete(&self, id: Uuid) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute("DELETE FROM external_references WHERE id = ?1", params![id.to_string()])?;
        Ok(())
    }
}

--- FILE: src-tauri\src\repositories\file_repository.rs ---
use crate::domain::file::{File, FileType, FileOrigin};
use crate::error::AppResult;
use r2d2::Pool;
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::{params, Row};
use std::sync::Arc;
use std::path::PathBuf;
use chrono::{DateTime, Utc};
use uuid::Uuid;

pub trait FileRepository: Send + Sync {
    fn save(&self, file: &File) -> AppResult<()>;
    fn get_by_id(&self, id: Uuid) -> AppResult<Option<File>>;
    fn get_by_path(&self, path: &PathBuf) -> AppResult<Option<File>>;
    fn list_by_type(&self, file_type: FileType) -> AppResult<Vec<File>>;
    fn delete(&self, id: Uuid) -> AppResult<()>;
    fn exists(&self, id: Uuid) -> AppResult<bool>;
}

pub struct SqliteFileRepository {
    pool: Arc<Pool<SqliteConnectionManager>>,
}

impl SqliteFileRepository {
    pub fn new(pool: Arc<Pool<SqliteConnectionManager>>) -> Self {
        Self { pool }
    }

    fn row_to_file(row: &Row) -> rusqlite::Result<File> {
        let id_str: String = row.get("id")?;
        let path_str: String = row.get("caminho_absoluto")?;
        let tipo_str: String = row.get("tipo")?;
        let origem_str: String = row.get("origem")?;
        
        let tipo = match tipo_str.as_str() {
            "video" => FileType::Video,
            "legenda" => FileType::Legenda,
            "imagem" => FileType::Imagem,
            _ => FileType::Outro,
        };

        let origem = match origem_str.as_str() {
            "scan" => FileOrigin::Scan,
            "importacao" => FileOrigin::Importacao,
            _ => FileOrigin::Manual,
        };

        Ok(File {
            id: Uuid::parse_str(&id_str).unwrap_or_default(),
            caminho_absoluto: PathBuf::from(path_str),
            tipo,
            tamanho: row.get::<_, i64>("tamanho")? as u64,
            hash: row.get("hash")?,
            data_modificacao: DateTime::parse_from_rfc3339(&row.get::<_, String>("data_modificacao")?)
                .map(|dt| dt.with_timezone(&Utc)).unwrap_or_else(|_| Utc::now()),
            origem,
            criado_em: DateTime::parse_from_rfc3339(&row.get::<_, String>("criado_em")?)
                .map(|dt| dt.with_timezone(&Utc)).unwrap_or_else(|_| Utc::now()),
            atualizado_em: DateTime::parse_from_rfc3339(&row.get::<_, String>("atualizado_em")?)
                .map(|dt| dt.with_timezone(&Utc)).unwrap_or_else(|_| Utc::now()),
        })
    }
}

impl FileRepository for SqliteFileRepository {
    fn save(&self, file: &File) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute(
            "INSERT OR REPLACE INTO files (id, caminho_absoluto, tipo, tamanho, hash, data_modificacao, origem, criado_em, atualizado_em)
             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)",
            params![
                file.id.to_string(),
                file.caminho_absoluto.to_string_lossy().to_string(),
                file.tipo.to_string(),
                file.tamanho as i64,
                file.hash,
                file.data_modificacao.to_rfc3339(),
                file.origem.to_string(),
                file.criado_em.to_rfc3339(),
                file.atualizado_em.to_rfc3339()
            ],
        )?;
        Ok(())
    }

    fn get_by_id(&self, id: Uuid) -> AppResult<Option<File>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT * FROM files WHERE id = ?1")?;
        let mut rows = stmt.query(params![id.to_string()])?;
        if let Some(row) = rows.next()? {
            Ok(Some(Self::row_to_file(row)?))
        } else {
            Ok(None)
        }
    }

    fn get_by_path(&self, path: &PathBuf) -> AppResult<Option<File>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT * FROM files WHERE caminho_absoluto = ?1")?;
        let mut rows = stmt.query(params![path.to_string_lossy().to_string()])?;
        if let Some(row) = rows.next()? {
            Ok(Some(Self::row_to_file(row)?))
        } else {
            Ok(None)
        }
    }

    fn list_by_type(&self, file_type: FileType) -> AppResult<Vec<File>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT * FROM files WHERE tipo = ?1")?;
        let files = stmt.query_map(params![file_type.to_string()], Self::row_to_file)?
            .collect::<Result<Vec<_>, _>>()?;
        Ok(files)
    }

    fn delete(&self, id: Uuid) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute("DELETE FROM files WHERE id = ?1", params![id.to_string()])?;
        Ok(())
    }

    fn exists(&self, id: Uuid) -> AppResult<bool> {
        let conn = self.pool.get()?;
        let count: i64 = conn.query_row(
            "SELECT COUNT(*) FROM files WHERE id = ?1",
            params![id.to_string()],
            |row| row.get(0),
        )?;
        Ok(count > 0)
    }
}

--- FILE: src-tauri\src\repositories\mod.rs ---
// src-tauri/src/repositories/mod.rs
//
// Repository layer
//
// CRITICAL RULES:
// - Repositories are DUMB data mappers
// - NO business logic
// - NO invariant enforcement
// - NO event emission
// - NO cross-repository calls
// - Explicit SQL only

pub mod anime_repository;
pub mod episode_repository;
pub mod file_repository;
pub mod subtitle_repository;
pub mod collection_repository;
pub mod external_reference_repository;
pub mod anime_alias_repository;
pub mod statistics_repository;

pub use anime_repository::{AnimeRepository, SqliteAnimeRepository};
pub use episode_repository::{EpisodeRepository, SqliteEpisodeRepository};
pub use file_repository::{FileRepository, SqliteFileRepository};
pub use subtitle_repository::{SubtitleRepository, SqliteSubtitleRepository};
pub use collection_repository::{CollectionRepository, SqliteCollectionRepository};
pub use external_reference_repository::{ExternalReferenceRepository, SqliteExternalReferenceRepository};
pub use anime_alias_repository::{AnimeAliasRepository, SqliteAnimeAliasRepository};
pub use statistics_repository::{StatisticsRepository, SqliteStatisticsRepository};

--- FILE: src-tauri\src\repositories\sqlite\sqlite_episode_repository.rs ---
use crate::domain::models::episode::{Episode, EpisodeState};
use crate::repositories::episode_repository::EpisodeRepository;
use crate::shared::errors::AppResult;
use r2d2::Pool;
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::{params, Row};
use std::str::FromStr;
use uuid::Uuid;

pub struct SqliteEpisodeRepository {
    pool: Pool<SqliteConnectionManager>,
}

impl SqliteEpisodeRepository {
    pub fn new(pool: Pool<SqliteConnectionManager>) -> Self {
        Self { pool }
    }

    fn row_to_episode(row: &Row) -> rusqlite::Result<Episode> {
        let id_str: String = row.get(0)?;
        let anime_id_str: String = row.get(1)?;
        let state_str: String = row.get(4)?;

        Ok(Episode {
            id: Uuid::parse_str(&id_str).unwrap_or_default(),
            anime_id: Uuid::parse_str(&anime_id_str).unwrap_or_default(),
            number: row.get(2)?,
            title: row.get(3)?,
            state: EpisodeState::from_str(&state_str).unwrap_or(EpisodeState::Unwatched),
            duration: row.get(5)?,
            last_watched_at: row.get(6)?,
            created_at: row.get(7)?,
            updated_at: row.get(8)?,
        })
    }
}

impl EpisodeRepository for SqliteEpisodeRepository {
    fn save(&self, episode: &Episode) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute(
            "INSERT OR REPLACE INTO episodes (id, anime_id, number, title, state, duration, last_watched_at, created_at, updated_at)
             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)",
            params![
                episode.id.to_string(),
                episode.anime_id.to_string(),
                episode.number,
                episode.title,
                episode.state.to_string(),
                episode.duration,
                episode.last_watched_at,
                episode.created_at,
                episode.updated_at
            ],
        )?;
        Ok(())
    }

    fn get_by_id(&self, id: Uuid) -> AppResult<Option<Episode>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT id, anime_id, number, title, state, duration, last_watched_at, created_at, updated_at FROM episodes WHERE id = ?1")?;
        let mut rows = stmt.query(params![id.to_string()])?;

        if let Some(row) = rows.next()? {
            Ok(Some(Self::row_to_episode(row)?))
        } else {
            Ok(None)
        }
    }

    fn list_by_anime(&self, anime_id: Uuid) -> AppResult<Vec<Episode>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT id, anime_id, number, title, state, duration, last_watched_at, created_at, updated_at FROM episodes WHERE anime_id = ?1 ORDER BY number ASC")?;
        let rows = stmt.query_map(params![anime_id.to_string()], |row| Self::row_to_episode(row))?;

        let mut episodes = Vec::new();
        for ep in rows {
            episodes.push(ep?);
        }
        Ok(episodes)
    }

    fn list_by_state(&self, anime_id: Uuid, state: EpisodeState) -> AppResult<Vec<Episode>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT id, anime_id, number, title, state, duration, last_watched_at, created_at, updated_at FROM episodes WHERE anime_id = ?1 AND state = ?2")?;
        let rows = stmt.query_map(params![anime_id.to_string(), state.to_string()], |row| Self::row_to_episode(row))?;

        let mut episodes = Vec::new();
        for ep in rows {
            episodes.push(ep?);
        }
        Ok(episodes)
    }

    fn delete(&self, id: Uuid) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute("DELETE FROM episodes WHERE id = ?1", params![id.to_string()])?;
        Ok(())
    }

    fn exists(&self, id: Uuid) -> AppResult<bool> {
        let conn = self.pool.get()?;
        let count: i64 = conn.query_row(
            "SELECT COUNT(*) FROM episodes WHERE id = ?1",
            params![id.to_string()],
            |row| row.get(0),
        )?;
        Ok(count > 0)
    }

    fn count_by_anime(&self, anime_id: Uuid) -> AppResult<usize> {
        let conn = self.pool.get()?;
        let count: i64 = conn.query_row(
            "SELECT COUNT(*) FROM episodes WHERE anime_id = ?1",
            params![anime_id.to_string()],
            |row| row.get(0),
        )?;
        Ok(count as usize)
    }

    fn count_completed(&self, anime_id: Uuid) -> AppResult<usize> {
        let conn = self.pool.get()?;
        let count: i64 = conn.query_row(
            "SELECT COUNT(*) FROM episodes WHERE anime_id = ?1 AND state = 'Completed'",
            params![anime_id.to_string()],
            |row| row.get(0),
        )?;
        Ok(count as usize)
    }

    fn link_file(&self, episode_id: Uuid, file_id: Uuid, is_primary: bool) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute(
            "INSERT OR REPLACE INTO episode_files (episode_id, file_id, is_primary) VALUES (?1, ?2, ?3)",
            params![episode_id.to_string(), file_id.to_string(), is_primary],
        )?;
        Ok(())
    }

    fn unlink_file(&self, episode_id: Uuid, file_id: Uuid) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute(
            "DELETE FROM episode_files WHERE episode_id = ?1 AND file_id = ?2",
            params![episode_id.to_string(), file_id.to_string()],
        )?;
        Ok(())
    }

    fn get_linked_files(&self, episode_id: Uuid) -> AppResult<Vec<(Uuid, bool)>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT file_id, is_primary FROM episode_files WHERE episode_id = ?1")?;
        let rows = stmt.query_map(params![episode_id.to_string()], |row| {
            let id_str: String = row.get(0)?;
            Ok((Uuid::parse_str(&id_str).unwrap_or_default(), row.get(1)?))
        })?;

        let mut links = Vec::new();
        for link in rows {
            links.push(link?);
        }
        Ok(links)
    }
}

--- FILE: src-tauri\src\repositories\sqlite\sqlite_file_repository.rs ---
use crate::domain::models::episode::{Episode, EpisodeState};
use crate::repositories::episode_repository::EpisodeRepository;
use crate::shared::errors::AppResult;
use r2d2::Pool;
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::{params, Row};
use std::str::FromStr;
use uuid::Uuid;

pub struct SqliteEpisodeRepository {
    pool: Pool<SqliteConnectionManager>,
}

impl SqliteEpisodeRepository {
    pub fn new(pool: Pool<SqliteConnectionManager>) -> Self {
        Self { pool }
    }

    fn row_to_episode(row: &Row) -> rusqlite::Result<Episode> {
        let id_str: String = row.get(0)?;
        let anime_id_str: String = row.get(1)?;
        let state_str: String = row.get(4)?;

        Ok(Episode {
            id: Uuid::parse_str(&id_str).unwrap_or_default(),
            anime_id: Uuid::parse_str(&anime_id_str).unwrap_or_default(),
            number: row.get(2)?,
            title: row.get(3)?,
            state: EpisodeState::from_str(&state_str).unwrap_or(EpisodeState::Unwatched),
            duration: row.get(5)?,
            last_watched_at: row.get(6)?,
            created_at: row.get(7)?,
            updated_at: row.get(8)?,
        })
    }
}

impl EpisodeRepository for SqliteEpisodeRepository {
    fn save(&self, episode: &Episode) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute(
            "INSERT OR REPLACE INTO episodes (id, anime_id, number, title, state, duration, last_watched_at, created_at, updated_at)
             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)",
            params![
                episode.id.to_string(),
                episode.anime_id.to_string(),
                episode.number,
                episode.title,
                episode.state.to_string(),
                episode.duration,
                episode.last_watched_at,
                episode.created_at,
                episode.updated_at
            ],
        )?;
        Ok(())
    }

    fn get_by_id(&self, id: Uuid) -> AppResult<Option<Episode>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT id, anime_id, number, title, state, duration, last_watched_at, created_at, updated_at FROM episodes WHERE id = ?1")?;
        let mut rows = stmt.query(params![id.to_string()])?;

        if let Some(row) = rows.next()? {
            Ok(Some(Self::row_to_episode(row)?))
        } else {
            Ok(None)
        }
    }

    fn list_by_anime(&self, anime_id: Uuid) -> AppResult<Vec<Episode>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT id, anime_id, number, title, state, duration, last_watched_at, created_at, updated_at FROM episodes WHERE anime_id = ?1 ORDER BY number ASC")?;
        let rows = stmt.query_map(params![anime_id.to_string()], |row| Self::row_to_episode(row))?;

        let mut episodes = Vec::new();
        for ep in rows {
            episodes.push(ep?);
        }
        Ok(episodes)
    }

    fn list_by_state(&self, anime_id: Uuid, state: EpisodeState) -> AppResult<Vec<Episode>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT id, anime_id, number, title, state, duration, last_watched_at, created_at, updated_at FROM episodes WHERE anime_id = ?1 AND state = ?2")?;
        let rows = stmt.query_map(params![anime_id.to_string(), state.to_string()], |row| Self::row_to_episode(row))?;

        let mut episodes = Vec::new();
        for ep in rows {
            episodes.push(ep?);
        }
        Ok(episodes)
    }

    fn delete(&self, id: Uuid) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute("DELETE FROM episodes WHERE id = ?1", params![id.to_string()])?;
        Ok(())
    }

    fn exists(&self, id: Uuid) -> AppResult<bool> {
        let conn = self.pool.get()?;
        let count: i64 = conn.query_row(
            "SELECT COUNT(*) FROM episodes WHERE id = ?1",
            params![id.to_string()],
            |row| row.get(0),
        )?;
        Ok(count > 0)
    }

    fn count_by_anime(&self, anime_id: Uuid) -> AppResult<usize> {
        let conn = self.pool.get()?;
        let count: i64 = conn.query_row(
            "SELECT COUNT(*) FROM episodes WHERE anime_id = ?1",
            params![anime_id.to_string()],
            |row| row.get(0),
        )?;
        Ok(count as usize)
    }

    fn count_completed(&self, anime_id: Uuid) -> AppResult<usize> {
        let conn = self.pool.get()?;
        let count: i64 = conn.query_row(
            "SELECT COUNT(*) FROM episodes WHERE anime_id = ?1 AND state = 'Completed'",
            params![anime_id.to_string()],
            |row| row.get(0),
        )?;
        Ok(count as usize)
    }

    fn link_file(&self, episode_id: Uuid, file_id: Uuid, is_primary: bool) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute(
            "INSERT OR REPLACE INTO episode_files (episode_id, file_id, is_primary) VALUES (?1, ?2, ?3)",
            params![episode_id.to_string(), file_id.to_string(), is_primary],
        )?;
        Ok(())
    }

    fn unlink_file(&self, episode_id: Uuid, file_id: Uuid) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute(
            "DELETE FROM episode_files WHERE episode_id = ?1 AND file_id = ?2",
            params![episode_id.to_string(), file_id.to_string()],
        )?;
        Ok(())
    }

    fn get_linked_files(&self, episode_id: Uuid) -> AppResult<Vec<(Uuid, bool)>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT file_id, is_primary FROM episode_files WHERE episode_id = ?1")?;
        let rows = stmt.query_map(params![episode_id.to_string()], |row| {
            let id_str: String = row.get(0)?;
            Ok((Uuid::parse_str(&id_str).unwrap_or_default(), row.get(1)?))
        })?;

        let mut links = Vec::new();
        for link in rows {
            links.push(link?);
        }
        Ok(links)
    }
}

--- FILE: src-tauri\src\repositories\sqlite\sqlite_statistics_repository.rs ---
use crate::domain::models::statistics::{StatisticsSnapshot, StatisticsType};
use crate::repositories::statistics_repository::StatisticsRepository;
use crate::shared::errors::AppResult;
use r2d2::Pool;
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::{params, Row};
use std::collections::HashMap;
use std::str::FromStr;
use uuid::Uuid;

pub struct SqliteStatisticsRepository {
    pool: Pool<SqliteConnectionManager>,
}

impl SqliteStatisticsRepository {
    pub fn new(pool: Pool<SqliteConnectionManager>) -> Self {
        Self { pool }
    }

    fn row_to_snapshot(row: &Row) -> rusqlite::Result<StatisticsSnapshot> {
        let id_str: String = row.get(0)?;
        let tipo_str: String = row.get(1)?;
        let data_json: String = row.get(2)?;

        // Agora utiliza o FromStr do domÃ­nio, removendo o "cheiro" arquitetural
        let tipo = StatisticsType::from_str(&tipo_str)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;

        let data: HashMap<String, f64> = serde_json::from_str(&data_json)
            .unwrap_or_default();

        Ok(StatisticsSnapshot {
            id: Uuid::parse_str(&id_str).unwrap_or_default(),
            tipo,
            data,
            captured_at: row.get(3)?,
        })
    }
}

impl StatisticsRepository for SqliteStatisticsRepository {
    fn save_snapshot(&self, snapshot: &StatisticsSnapshot) -> AppResult<()> {
        let conn = self.pool.get()?;
        let data_json = serde_json::to_string(&snapshot.data).unwrap_or_default();
        
        conn.execute(
            "INSERT OR REPLACE INTO statistics_snapshots (id, tipo, data, captured_at)
             VALUES (?1, ?2, ?3, ?4)",
            params![
                snapshot.id.to_string(),
                snapshot.tipo.to_string(),
                data_json,
                snapshot.captured_at
            ],
        )?;
        Ok(())
    }

    fn get_snapshot_by_type(&self, tipo: &str) -> AppResult<Option<StatisticsSnapshot>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT id, tipo, data, captured_at FROM statistics_snapshots WHERE tipo = ?1")?;
        let mut rows = stmt.query(params![tipo])?;

        if let Some(row) = rows.next()? {
            Ok(Some(Self::row_to_snapshot(row)?))
        } else {
            Ok(None)
        }
    }

    fn list_all_snapshots(&self) -> AppResult<Vec<StatisticsSnapshot>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare("SELECT id, tipo, data, captured_at FROM statistics_snapshots ORDER BY captured_at DESC")?;
        let rows = stmt.query_map([], |row| Self::row_to_snapshot(row))?;

        let mut snapshots = Vec::new();
        for s in rows {
            snapshots.push(s?);
        }
        Ok(snapshots)
    }

    fn delete_all(&self) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute("DELETE FROM statistics_snapshots", [])?;
        Ok(())
    }
}

--- FILE: src-tauri\src\repositories\statistics_repository.rs ---
// src-tauri/src/repositories/statistics_repository.rs

use std::sync::Arc;
use rusqlite::{params, Row};
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::db::ConnectionPool;
use crate::domain::statistics::{StatisticsSnapshot, StatisticsType};
use crate::error::{AppError, AppResult};

pub trait StatisticsRepository: Send + Sync {
    fn save_snapshot(&self, snapshot: &StatisticsSnapshot) -> AppResult<()>;
    fn get_snapshot_by_type(&self, tipo: &str) -> AppResult<Option<StatisticsSnapshot>>;
    fn list_all_snapshots(&self) -> AppResult<Vec<StatisticsSnapshot>>;
    fn delete_all(&self) -> AppResult<()>;
}

pub struct SqliteStatisticsRepository {
    pool: Arc<ConnectionPool>,
}

impl SqliteStatisticsRepository {
    pub fn new(pool: Arc<ConnectionPool>) -> Self {
        Self { pool }
    }

    fn row_to_snapshot(row: &Row) -> Result<StatisticsSnapshot, rusqlite::Error> {
        let id_str: String = row.get("id")?;
        let id = Uuid::parse_str(&id_str)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;

        let tipo_raw: String = row.get("tipo")?;
        let tipo = if tipo_raw == "global" {
            StatisticsType::Global
        } else if let Some(anime_id_str) = tipo_raw.strip_prefix("por_anime:") {
            let anime_id = Uuid::parse_str(anime_id_str)
                .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
            StatisticsType::PorAnime { anime_id }
        } else if let Some(period_str) = tipo_raw.strip_prefix("por_periodo:") {
            let parts: Vec<&str> = period_str.split(':').collect();
            if parts.len() == 2 {
                let inicio = DateTime::parse_from_rfc3339(parts[0])
                    .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?
                    .with_timezone(&Utc);
                let fim = DateTime::parse_from_rfc3339(parts[1])
                    .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?
                    .with_timezone(&Utc);
                StatisticsType::PorPeriodo { inicio, fim }
            } else {
                return Err(rusqlite::Error::InvalidQuery);
            }
        } else {
            return Err(rusqlite::Error::InvalidQuery);
        };

        let valor_json: String = row.get("valor")?;
        let valor = serde_json::from_str(&valor_json)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;

        let gerado_em = DateTime::parse_from_rfc3339(&row.get::<_, String>("gerado_em")?)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?
            .with_timezone(&Utc);

        Ok(StatisticsSnapshot {
            id,
            tipo,
            valor,
            gerado_em,
        })
    }
}

impl StatisticsRepository for SqliteStatisticsRepository {
    fn save_snapshot(&self, snap: &StatisticsSnapshot) -> AppResult<()> {
        let conn = self.pool.get()?;
        let valor_json = serde_json::to_string(&snap.valor)?;
        
        conn.execute(
            "INSERT OR REPLACE INTO statistics_snapshots (id, tipo, valor, gerado_em)
             VALUES (?1, ?2, ?3, ?4)",
            params![
                snap.id.to_string(),
                snap.tipo.to_string(),
                valor_json,
                snap.gerado_em.to_rfc3339()
            ],
        )?;
        Ok(())
    }

    fn get_snapshot_by_type(&self, tipo: &str) -> AppResult<Option<StatisticsSnapshot>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare(
            "SELECT * FROM statistics_snapshots WHERE tipo = ?1 ORDER BY gerado_em DESC LIMIT 1"
        )?;
        
        match stmt.query_row(params![tipo], Self::row_to_snapshot) {
            Ok(snap) => Ok(Some(snap)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(e) => Err(AppError::Database(e)),
        }
    }

    fn list_all_snapshots(&self) -> AppResult<Vec<StatisticsSnapshot>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare(
            "SELECT * FROM statistics_snapshots ORDER BY gerado_em DESC"
        )?;
        
        let snapshots: Vec<StatisticsSnapshot> = stmt.query_map([], Self::row_to_snapshot)?
            .collect::<Result<Vec<_>, _>>()?;
        
        Ok(snapshots)
    }

    fn delete_all(&self) -> AppResult<()> {
        let conn = self.pool.get()?;
        conn.execute("DELETE FROM statistics_snapshots", [])?;
        Ok(())
    }
}

--- FILE: src-tauri\src\repositories\subtitle_repository.rs ---
// src-tauri/src/repositories/subtitle_repository.rs

use std::sync::Arc;
use rusqlite::{params, Row};
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::db::ConnectionPool;
use crate::domain::subtitle::{Subtitle, SubtitleFormat, SubtitleTransformation, TransformationType};
use crate::error::{AppError, AppResult};

pub trait SubtitleRepository: Send + Sync {
    fn save_subtitle(&self, subtitle: &Subtitle) -> AppResult<()>;
    fn get_subtitle_by_id(&self, id: Uuid) -> AppResult<Option<Subtitle>>;
    fn list_by_file(&self, file_id: Uuid) -> AppResult<Vec<Subtitle>>;
    fn list_by_language(&self, language: &str) -> AppResult<Vec<Subtitle>>;
    fn save_transformation(&self, transformation: &SubtitleTransformation) -> AppResult<()>;
    fn get_transformations(&self, subtitle_id: Uuid) -> AppResult<Vec<SubtitleTransformation>>;
}

pub struct SqliteSubtitleRepository {
    pool: Arc<ConnectionPool>,
}

impl SqliteSubtitleRepository {
    pub fn new(pool: Arc<ConnectionPool>) -> Self {
        Self { pool }
    }
    
    fn row_to_subtitle(row: &Row) -> Result<Subtitle, rusqlite::Error> {
        let id = Uuid::parse_str(&row.get::<_, String>("id")?)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
        let file_id = Uuid::parse_str(&row.get::<_, String>("file_id")?)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
        
        let formato_str: String = row.get("formato")?;
        let formato = match formato_str.as_str() {
            "SRT" => SubtitleFormat::SRT,
            "ASS" => SubtitleFormat::ASS,
            "VTT" => SubtitleFormat::VTT,
            _ => return Err(rusqlite::Error::InvalidQuery),
        };
        
        let idioma: String = row.get("idioma")?;
        let versao: i32 = row.get("versao")?;
        let eh_original: i32 = row.get("eh_original")?;
        
        let criado_em = DateTime::parse_from_rfc3339(&row.get::<_, String>("criado_em")?)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?
            .with_timezone(&Utc);
        
        Ok(Subtitle {
            id,
            file_id,
            formato,
            idioma,
            versao: versao as u32,
            eh_original: eh_original == 1,
            criado_em,
        })
    }
    
    fn row_to_transformation(row: &Row) -> Result<SubtitleTransformation, rusqlite::Error> {
        let id = Uuid::parse_str(&row.get::<_, String>("id")?)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
        let subtitle_id_origem = Uuid::parse_str(&row.get::<_, String>("subtitle_id_origem")?)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
        
        let tipo_str: String = row.get("tipo")?;
        let tipo = match tipo_str.as_str() {
            "style" => TransformationType::Style,
            "timing" => TransformationType::Timing,
            "conversao" => TransformationType::Conversao,
            _ => return Err(rusqlite::Error::InvalidQuery),
        };
        
        let parametros_json: String = row.get("parametros_aplicados")?;
        let parametros_aplicados: serde_json::Value = serde_json::from_str(&parametros_json)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?;
        
        let criado_em = DateTime::parse_from_rfc3339(&row.get::<_, String>("criado_em")?)
            .map_err(|e| rusqlite::Error::ToSqlConversionFailure(Box::new(e)))?
            .with_timezone(&Utc);
        
        Ok(SubtitleTransformation {
            id,
            subtitle_id_origem,
            tipo,
            parametros_aplicados,
            criado_em,
        })
    }
}

impl SubtitleRepository for SqliteSubtitleRepository {
    fn save_subtitle(&self, subtitle: &Subtitle) -> AppResult<()> {
        let conn = self.pool.get()?;
        
        conn.execute(
            "INSERT OR REPLACE INTO subtitles (
                id, file_id, formato, idioma, versao, eh_original, criado_em
            ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)",
            params![
                subtitle.id.to_string(),
                subtitle.file_id.to_string(),
                subtitle.formato.to_string(),
                &subtitle.idioma,
                subtitle.versao as i32,
                subtitle.eh_original as i32,
                subtitle.criado_em.to_rfc3339(),
            ]
        )?;
        
        Ok(())
    }
    
    fn get_subtitle_by_id(&self, id: Uuid) -> AppResult<Option<Subtitle>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare("SELECT * FROM subtitles WHERE id = ?1")?;
        
        match stmt.query_row(params![id.to_string()], Self::row_to_subtitle) {
            Ok(sub) => Ok(Some(sub)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(e) => Err(AppError::Database(e)),
        }
    }
    
    fn list_by_file(&self, file_id: Uuid) -> AppResult<Vec<Subtitle>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare("SELECT * FROM subtitles WHERE file_id = ?1")?;
        
        let subs: Vec<Subtitle> = stmt.query_map(params![file_id.to_string()], Self::row_to_subtitle)?
            .collect::<Result<Vec<_>, _>>()?;
        
        Ok(subs)
    }
    
    fn list_by_language(&self, language: &str) -> AppResult<Vec<Subtitle>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare("SELECT * FROM subtitles WHERE idioma = ?1")?;
        
        let subs: Vec<Subtitle> = stmt.query_map(params![language], Self::row_to_subtitle)?
            .collect::<Result<Vec<_>, _>>()?;
        
        Ok(subs)
    }
    
    fn save_transformation(&self, transformation: &SubtitleTransformation) -> AppResult<()> {
        let conn = self.pool.get()?;
        
        let parametros_json = serde_json::to_string(&transformation.parametros_aplicados)?;
        
        conn.execute(
            "INSERT INTO subtitle_transformations (
                id, subtitle_id_origem, tipo, parametros_aplicados, criado_em
            ) VALUES (?1, ?2, ?3, ?4, ?5)",
            params![
                transformation.id.to_string(),
                transformation.subtitle_id_origem.to_string(),
                transformation.tipo.to_string(),
                parametros_json,
                transformation.criado_em.to_rfc3339(),
            ]
        )?;
        
        Ok(())
    }
    
    fn get_transformations(&self, subtitle_id: Uuid) -> AppResult<Vec<SubtitleTransformation>> {
        let conn = self.pool.get()?;
        
        let mut stmt = conn.prepare(
            "SELECT * FROM subtitle_transformations WHERE subtitle_id_origem = ?1 ORDER BY criado_em"
        )?;
        
        let transformations: Vec<SubtitleTransformation> = stmt.query_map(
            params![subtitle_id.to_string()],
            Self::row_to_transformation
        )?
        .collect::<Result<Vec<_>, _>>()?;
        
        Ok(transformations)
    }
}

--- FILE: src-tauri\src\services\anime_service.rs ---
// src-tauri/src/services/anime_service.rs
use std::sync::Arc;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use crate::domain::anime::{Anime, AnimeType, AnimeStatus, validate_anime};
use crate::repositories::{AnimeRepository, AnimeAliasRepository, ExternalReferenceRepository};
use crate::events::{EventBus, AnimeCreated, AnimeUpdated, AnimeMerged};
use crate::error::{AppError, AppResult};

#[derive(Debug, Clone)]
pub struct CreateAnimeRequest {
    pub titulo_principal: String,
    pub titulos_alternativos: Vec<String>,
    pub tipo: AnimeType,
    pub status: AnimeStatus,
    pub total_episodios: Option<u32>,
    pub data_inicio: Option<DateTime<Utc>>,
    pub data_fim: Option<DateTime<Utc>>,
    pub metadados_livres: serde_json::Value,
}

#[derive(Debug, Clone)]
pub struct UpdateAnimeRequest {
    pub anime_id: Uuid,
    pub titulo_principal: Option<String>,
    pub titulos_alternativos: Option<Vec<String>>,
    pub tipo: Option<AnimeType>,
    pub status: Option<AnimeStatus>,
    pub total_episodios: Option<Option<u32>>,
    pub data_inicio: Option<Option<DateTime<Utc>>>,
    pub data_fim: Option<Option<DateTime<Utc>>>,
    pub metadados_livres: Option<serde_json::Value>,
}

#[derive(Debug, Clone)]
pub struct MergeAnimesRequest {
    pub principal_anime_id: Uuid,
    pub anime_to_merge_id: Uuid,
}

pub struct AnimeService {
    anime_repo: Arc<dyn AnimeRepository>,
    alias_repo: Arc<dyn AnimeAliasRepository>,
    external_ref_repo: Arc<dyn ExternalReferenceRepository>,
    event_bus: Arc<EventBus>,
}

impl AnimeService {
    pub fn new(
        anime_repo: Arc<dyn AnimeRepository>,
        alias_repo: Arc<dyn AnimeAliasRepository>,
        external_ref_repo: Arc<dyn ExternalReferenceRepository>,
        event_bus: Arc<EventBus>,
    ) -> Self {
        Self {
            anime_repo,
            alias_repo,
            external_ref_repo,
            event_bus,
        }
    }

    pub fn create_anime(&self, request: CreateAnimeRequest) -> AppResult<Uuid> {
        let mut anime = Anime::new(request.titulo_principal, request.tipo);
        
        anime.update_metadata(
            None,
            Some(request.titulos_alternativos),
            None,
            Some(request.status),
            Some(request.total_episodios),
            Some(request.data_inicio),
            Some(request.data_fim),
            Some(request.metadados_livres),
        );

        validate_anime(&anime).map_err(AppError::Domain)?;
        self.anime_repo.save(&anime)?;

        self.event_bus.emit(AnimeCreated::new(
            anime.id,
            anime.titulo_principal.clone(),
            anime.tipo.to_string(),
        ));

        Ok(anime.id)
    }

    pub fn update_anime(&self, request: UpdateAnimeRequest) -> AppResult<()> {
        let mut anime = self.anime_repo
            .get_by_id(request.anime_id)?
            .ok_or(AppError::NotFound)?;

        anime.update_metadata(
            request.titulo_principal,
            request.titulos_alternativos,
            request.tipo,
            request.status,
            request.total_episodios,
            request.data_inicio,
            request.data_fim,
            request.metadados_livres,
        );

        validate_anime(&anime).map_err(AppError::Domain)?;
        self.anime_repo.save(&anime)?;

        self.event_bus.emit(AnimeUpdated::new(anime.id));
        Ok(())
    }

    pub fn get_anime(&self, anime_id: Uuid) -> AppResult<Option<Anime>> {
        self.anime_repo.get_by_id(anime_id)
    }

    pub fn list_all_animes(&self) -> AppResult<Vec<Anime>> {
        self.anime_repo.list_all()
    }

    pub fn merge_animes(&self, request: MergeAnimesRequest) -> AppResult<()> {
        let principal = self.anime_repo
            .get_by_id(request.principal_anime_id)?
            .ok_or(AppError::NotFound)?;
        let to_merge = self.anime_repo
            .get_by_id(request.anime_to_merge_id)?
            .ok_or(AppError::NotFound)?;

        let alias = crate::domain::AnimeAlias::new(
            principal.id,
            to_merge.id,
        ).map_err(AppError::Other)?;

        self.alias_repo.save(&alias)?;

        self.event_bus.emit(AnimeMerged::new(
            request.principal_anime_id,
            request.anime_to_merge_id,
        ));

        Ok(())
    }

    pub fn resolve_alias(&self, anime_id: Uuid) -> AppResult<Uuid> {
        if let Some(principal_id) = self.alias_repo.get_principal_for_alias(anime_id)? {
            Ok(principal_id)
        } else {
            Ok(anime_id)
        }
    }

    pub fn get_external_references(&self, anime_id: Uuid) -> AppResult<Vec<crate::domain::ExternalReference>> {
        self.external_ref_repo.list_by_anime(anime_id)
    }
}

--- FILE: src-tauri\src\services\episode_service.rs ---
// src-tauri/src/services/episode_service.rs
//
// Episode Service - Episode and Progress Management
//
// CRITICAL RULES:
// - Manages episodes and viewing progress ONLY
// - Never creates Anime or Files
// - Never manipulates subtitles
// - Progress updates are explicit and validated

use std::sync::Arc;
use uuid::Uuid;

use crate::domain::episode::{Episode, EpisodeNumber, EpisodeState, validate_episode};
use crate::repositories::{EpisodeRepository, AnimeRepository, FileRepository};
use crate::events::{
    EventBus, EpisodeCreated, FileLinkedToEpisode, EpisodeBecamePlayable,
    EpisodeProgressUpdated, EpisodeCompleted, PlaybackStarted, PlaybackProgressUpdated
};
use crate::error::{AppError, AppResult};

/// Request to create a new episode
#[derive(Debug, Clone)]
pub struct CreateEpisodeRequest {
    pub anime_id: Uuid,
    pub numero: EpisodeNumber,
    pub titulo: Option<String>,
    pub duracao_esperada: Option<u64>,
}

/// Request to update episode metadata
#[derive(Debug, Clone)]
pub struct UpdateEpisodeMetadataRequest {
    pub episode_id: Uuid,
    pub titulo: Option<String>,
    pub duracao_esperada: Option<Option<u64>>,
}

/// Request to link a file to an episode
#[derive(Debug, Clone)]
pub struct LinkFileRequest {
    pub episode_id: Uuid,
    pub file_id: Uuid,
    pub is_primary: bool,
}

pub struct EpisodeService {
    episode_repo: Arc<dyn EpisodeRepository>,
    anime_repo: Arc<dyn AnimeRepository>,
    file_repo: Arc<dyn FileRepository>,
    event_bus: Arc<EventBus>,
}

impl EpisodeService {
    pub fn new(
        episode_repo: Arc<dyn EpisodeRepository>,
        anime_repo: Arc<dyn AnimeRepository>,
        file_repo: Arc<dyn FileRepository>,
        event_bus: Arc<EventBus>,
    ) -> Self {
        Self {
            episode_repo,
            anime_repo,
            file_repo,
            event_bus,
        }
    }
    
    /// Create a new episode
    /// 
    /// CRITICAL: anime_id MUST exist (validated)
    pub fn create_episode(&self, request: CreateEpisodeRequest) -> AppResult<Uuid> {
        // 1. Validate anime exists
        if !self.anime_repo.exists(request.anime_id)? {
            return Err(AppError::Other("Anime not found".to_string()));
        }
        
        // 2. Create domain entity
        let mut episode = Episode::new(request.anime_id, request.numero.clone());
        
        // 3. Apply additional metadata
        if let Some(titulo) = request.titulo {
            episode.titulo = Some(titulo);
        }
        if let Some(duracao) = request.duracao_esperada {
            episode.duracao_esperada = Some(duracao);
        }
        
        // 4. Validate domain invariants
        validate_episode(&episode)
            .map_err(|e| AppError::Domain(e))?;
        
        // 5. Persist
        self.episode_repo.save(&episode)?;
        
        // 6. Emit event
        self.event_bus.emit(EpisodeCreated::new(
            episode.id,
            episode.anime_id,
            episode.numero.to_string(),
        ));
        
        Ok(episode.id)
    }
    
    /// Update episode metadata
    pub fn update_episode_metadata(&self, request: UpdateEpisodeMetadataRequest) -> AppResult<()> {
        // 1. Load episode
        let mut episode = self.episode_repo
            .get_by_id(request.episode_id)?
            .ok_or(AppError::NotFound)?;
        
        // 2. Apply updates
        episode.update_metadata(request.titulo, request.duracao_esperada);
        
        // 3. Validate
        validate_episode(&episode)
            .map_err(|e| AppError::Domain(e))?;
        
        // 4. Persist
        self.episode_repo.save(&episode)?;
        
        Ok(())
    }
    
    /// Link a file to an episode
    /// 
    /// CRITICAL: File must exist and be appropriate type
    pub fn link_file(&self, request: LinkFileRequest) -> AppResult<()> {
        // 1. Validate episode exists
        let episode = self.episode_repo
            .get_by_id(request.episode_id)?
            .ok_or(AppError::NotFound)?;
        
        // 2. Validate file exists
        let file = self.file_repo
            .get_by_id(request.file_id)?
            .ok_or(AppError::NotFound)?;
        
        // 3. Create association
        self.episode_repo.link_file(request.episode_id, request.file_id, request.is_primary)?;
        
        // 4. Emit events
        self.event_bus.emit(FileLinkedToEpisode::new(
            request.episode_id,
            request.file_id,
            request.is_primary,
        ));
        
        // 5. If primary video file, emit EpisodeBecamePlayable
        if request.is_primary && file.tipo == crate::domain::FileType::Video {
            self.event_bus.emit(EpisodeBecamePlayable::new(episode.id));
        }
        
        Ok(())
    }
    
    /// Unlink a file from an episode
    pub fn unlink_file(&self, episode_id: Uuid, file_id: Uuid) -> AppResult<()> {
        self.episode_repo.unlink_file(episode_id, file_id)?;
        Ok(())
    }
    
    /// Update episode progress
    /// 
    /// CRITICAL: Progress is validated by domain
    /// CRITICAL: Never decreases automatically
    pub fn update_progress(&self, episode_id: Uuid, progress_seconds: u64) -> AppResult<()> {
        // 1. Load episode
        let mut episode = self.episode_repo
            .get_by_id(episode_id)?
            .ok_or(AppError::NotFound)?;
        
        // 2. Update progress (domain validates)
        episode.update_progress(progress_seconds)
            .map_err(|e| AppError::Other(e))?;
        
        // 3. Validate
        validate_episode(&episode)
            .map_err(|e| AppError::Domain(e))?;
        
        // 4. Persist
        self.episode_repo.save(&episode)?;
        
        // 5. Emit event
        self.event_bus.emit(EpisodeProgressUpdated::new(
            episode.id,
            episode.progresso_atual,
            episode.duracao_esperada,
        ));
        
        // 6. If completed, emit completion event
        if episode.estado == EpisodeState::Concluido {
            self.event_bus.emit(EpisodeCompleted::new(episode.id, episode.anime_id));
        }
        
        Ok(())
    }
    
    /// Mark episode as completed
    pub fn mark_completed(&self, episode_id: Uuid) -> AppResult<()> {
        // 1. Load episode
        let mut episode = self.episode_repo
            .get_by_id(episode_id)?
            .ok_or(AppError::NotFound)?;
        
        // 2. Mark completed
        episode.mark_completed();
        
        // 3. Persist
        self.episode_repo.save(&episode)?;
        
        // 4. Emit event
        self.event_bus.emit(EpisodeCompleted::new(episode.id, episode.anime_id));
        
        Ok(())
    }
    
    /// Reset episode progress
    pub fn reset_progress(&self, episode_id: Uuid) -> AppResult<()> {
        // 1. Load episode
        let mut episode = self.episode_repo
            .get_by_id(episode_id)?
            .ok_or(AppError::NotFound)?;
        
        // 2. Reset
        episode.reset_progress();
        
        // 3. Persist
        self.episode_repo.save(&episode)?;
        
        Ok(())
    }
    
    /// Get episode by ID
    pub fn get_episode(&self, episode_id: Uuid) -> AppResult<Option<Episode>> {
        self.episode_repo.get_by_id(episode_id)
    }
    
    /// List all episodes for an anime
    pub fn list_episodes_for_anime(&self, anime_id: Uuid) -> AppResult<Vec<Episode>> {
        self.episode_repo.list_by_anime(anime_id)
    }
    
    /// List episodes by state
    pub fn list_episodes_by_state(&self, anime_id: Uuid, state: EpisodeState) -> AppResult<Vec<Episode>> {
        self.episode_repo.list_by_state(anime_id, state)
    }
    
    /// Get linked files for an episode
    pub fn get_linked_files(&self, episode_id: Uuid) -> AppResult<Vec<(Uuid, bool)>> {
        self.episode_repo.get_linked_files(episode_id)
    }
    
    /// Setup event handlers
    /// This subscribes to playback events to update progress
    pub fn register_event_handlers(&self) {
        let episode_repo = Arc::clone(&self.episode_repo);
        let event_bus = Arc::clone(&self.event_bus);
        
        // Handle PlaybackStarted
        {
            let repo = Arc::clone(&episode_repo);
            self.event_bus.subscribe::<PlaybackStarted, _>(move |event| {
                if let Ok(Some(mut episode)) = repo.get_by_id(event.episode_id) {
                    episode.estado = EpisodeState::EmProgresso;
                    let _ = repo.save(&episode);
                }
            });
        }
        
        // Handle PlaybackProgressUpdated
        {
            let repo = Arc::clone(&episode_repo);
            let bus = Arc::clone(&event_bus);
            self.event_bus.subscribe::<PlaybackProgressUpdated, _>(move |event| {
                if let Ok(Some(mut episode)) = repo.get_by_id(event.episode_id) {
                    if let Ok(_) = episode.update_progress(event.progress_seconds) {
                        let _ = repo.save(&episode);
                        
                        // Emit progress update
                        bus.emit(EpisodeProgressUpdated::new(
                            episode.id,
                            episode.progresso_atual,
                            episode.duracao_esperada,
                        ));
                        
                        // Emit completion if applicable
                        if episode.estado == EpisodeState::Concluido {
                            bus.emit(EpisodeCompleted::new(episode.id, episode.anime_id));
                        }
                    }
                }
            });
        }
    }
}

--- FILE: src-tauri\src\services\external_integration_service.rs ---
// src-tauri/src/services/external_integration_service.rs
use std::sync::Arc;
use uuid::Uuid;
use crate::domain::{ExternalReference, validate_external_reference};
use crate::repositories::{ExternalReferenceRepository, AnimeRepository};
use crate::events::{EventBus, ExternalMetadataRequested, ExternalMetadataFetched, ExternalMetadataLinked};
use crate::error::{AppError, AppResult};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExternalMetadata {
    pub external_id: String,
    pub title: String,
    pub alternative_titles: Vec<String>,
    pub total_episodes: Option<u32>,
    pub status: Option<String>,
    pub start_date: Option<String>,
    pub end_date: Option<String>,
    pub genres: Vec<String>,
    pub cover_image: Option<String>,
    pub synopsis: Option<String>,
}

// Esta estrutura estava faltando e causando erro no mod.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetadataSuggestions {
    pub provider: String,
    pub suggestions: Vec<ExternalMetadata>,
}

#[derive(Debug, Clone)]
pub struct FetchMetadataRequest {
    pub anime_id: Uuid,
    pub provider: String,
}

#[derive(Debug, Clone)]
pub struct LinkExternalReferenceRequest {
    pub anime_id: Uuid,
    pub provider: String,
    pub external_id: String,
}

pub struct ExternalIntegrationService {
    external_ref_repo: Arc<dyn ExternalReferenceRepository>,
    anime_repo: Arc<dyn AnimeRepository>,
    event_bus: Arc<EventBus>,
}

impl ExternalIntegrationService {
    pub fn new(
        external_ref_repo: Arc<dyn ExternalReferenceRepository>,
        anime_repo: Arc<dyn AnimeRepository>,
        event_bus: Arc<EventBus>,
    ) -> Self {
        Self {
            external_ref_repo,
            anime_repo,
            event_bus,
        }
    }

    pub fn fetch_and_link_metadata(&self, request: FetchMetadataRequest) -> AppResult<()> {
        self.event_bus.emit(ExternalMetadataRequested::new(
            request.anime_id,
            request.provider.clone(),
        ));
        Ok(())
    }

    pub fn link_external_reference(&self, request: LinkExternalReferenceRequest) -> AppResult<()> {
        if !self.anime_repo.exists(request.anime_id)? {
            return Err(AppError::NotFound);
        }

        let reference = ExternalReference::new(
            request.anime_id,
            request.provider.clone(),
            request.external_id.clone(),
        );

        validate_external_reference(&reference)
            .map_err(AppError::Domain)?;

        self.external_ref_repo.save(&reference)?;

        self.event_bus.emit(ExternalMetadataLinked::new(
            request.anime_id,
            request.provider,
            request.external_id,
        ));

        Ok(())
    }

    pub fn search_external(&self, _provider: &str, _query: &str) -> AppResult<Vec<ExternalMetadata>> {
        let results: Vec<ExternalMetadata> = Vec::new();
        Ok(results)
    }

    pub fn sync_metadata_from_external(
        &self,
        anime_id: Uuid,
        provider: &str,
    ) -> AppResult<ExternalMetadata> {
        let anime = self.anime_repo
            .get_by_id(anime_id)?
            .ok_or(AppError::NotFound)?;

        let reference = self.external_ref_repo
            .get_by_anime_and_source(anime_id, provider)?
            .ok_or_else(|| AppError::Other("No external reference found".to_string()))?;

        let metadata = ExternalMetadata {
            external_id: reference.external_id.clone(),
            title: anime.titulo_principal.clone(),
            alternative_titles: anime.titulos_alternativos.clone(),
            total_episodes: anime.total_episodios,
            status: Some(anime.status.to_string()),
            start_date: anime.data_inicio.map(|d| d.to_rfc3339()),
            end_date: anime.data_fim.map(|d| d.to_rfc3339()),
            genres: Vec::new(),
            cover_image: None,
            synopsis: None,
        };

        self.event_bus.emit(ExternalMetadataFetched::new(
            anime_id,
            provider.to_string(),
            reference.external_id,
        ));

        Ok(metadata)
    }
}

--- FILE: src-tauri\src\services\file_service.rs ---
// src-tauri/src/services/file_service.rs
use std::sync::Arc;
use std::path::PathBuf;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use crate::domain::file::{File, FileType, FileOrigin, validate_file};
use crate::repositories::FileRepository;
use crate::events::{EventBus, DirectoryScanned, FileDetected};
use crate::error::{AppError, AppResult};

/// Request to register a detected file
#[derive(Debug, Clone)]
pub struct RegisterFileRequest {
    pub caminho_absoluto: PathBuf,
    pub tipo: FileType,
    pub tamanho: u64,
    pub data_modificacao: DateTime<Utc>,
    pub origem: FileOrigin,
    pub hash: Option<String>,
}

pub struct FileService {
    file_repo: Arc<dyn FileRepository>,
    event_bus: Arc<EventBus>,
}

impl FileService {
    pub fn new(
        file_repo: Arc<dyn FileRepository>,
        event_bus: Arc<EventBus>,
    ) -> Self {
        Self {
            file_repo,
            event_bus,
        }
    }

    pub fn register_file(&self, request: RegisterFileRequest) -> AppResult<Uuid> {
        if let Some(existing) = self.file_repo.get_by_path(&request.caminho_absoluto)? {
            if existing.has_changed(request.tamanho, request.data_modificacao) {
                return self.update_file_metadata(
                    existing.id,
                    request.tamanho,
                    request.data_modificacao,
                );
            } else {
                return Ok(existing.id);
            }
        }

        let mut file = File::new(
            request.caminho_absoluto.clone(),
            request.tipo,
            request.tamanho,
            request.data_modificacao,
            request.origem,
        );

        if let Some(hash) = request.hash {
            file.set_hash(hash);
        }

        validate_file(&file)
            .map_err(AppError::Domain)?;

        self.file_repo.save(&file)?;

        self.event_bus.emit(FileDetected::new(
            request.caminho_absoluto,
            request.tamanho,
            request.tipo.to_string(),
        ));

        Ok(file.id)
    }

    pub fn update_file_metadata(
        &self,
        file_id: Uuid,
        tamanho: u64,
        data_modificacao: DateTime<Utc>,
    ) -> AppResult<Uuid> {
        let mut file = self.file_repo
            .get_by_id(file_id)?
            .ok_or(AppError::NotFound)?;

        file.update_metadata(tamanho, data_modificacao);

        validate_file(&file)
            .map_err(AppError::Domain)?;

        self.file_repo.save(&file)?;

        self.event_bus.emit(FileDetected::new(
            file.caminho_absoluto.clone(),
            file.tamanho,
            file.tipo.to_string(),
        ));

        Ok(file.id)
    }

    pub fn calculate_and_set_hash(&self, file_id: Uuid) -> AppResult<String> {
        let mut file = self.file_repo
            .get_by_id(file_id)?
            .ok_or(AppError::NotFound)?;

        let hash = self.calculate_file_hash(&file.caminho_absoluto)?;
        file.set_hash(hash.clone());
        self.file_repo.save(&file)?;

        Ok(hash)
    }

    pub fn get_file(&self, file_id: Uuid) -> AppResult<Option<File>> {
        self.file_repo.get_by_id(file_id)
    }

    pub fn scan_directory(&self, directory_path: PathBuf) -> AppResult<usize> {
        if !directory_path.exists() {
            return Err(AppError::Other("Directory does not exist".to_string()));
        }
        if !directory_path.is_dir() {
            return Err(AppError::Other("Path is not a directory".to_string()));
        }

        let mut files_found = 0;

        for entry in walkdir::WalkDir::new(&directory_path)
            .follow_links(true)
            .into_iter()
            .filter_map(|e: Result<walkdir::DirEntry, walkdir::Error>| e.ok()) {
            
            if entry.file_type().is_file() {
                let path = entry.path().to_path_buf();
                let file_type = FileType::from_extension(&path);

                if matches!(file_type, FileType::Video | FileType::Legenda | FileType::Imagem) {
                    if let Ok(metadata) = std::fs::metadata(&path) {
                        self.event_bus.emit(FileDetected::new(
                            path.clone(),
                            metadata.len(),
                            file_type.to_string(),
                        ));
                        let request = RegisterFileRequest {
                            caminho_absoluto: path,
                            tipo: file_type,
                            tamanho: metadata.len(),
                            data_modificacao: chrono::DateTime::from(
                                metadata.modified().unwrap_or(std::time::SystemTime::now())
                            ),
                            origem: FileOrigin::Scan,
                            hash: None,
                        };
                        let _ = self.register_file(request);
                        files_found += 1;
                    }
                }
            }
        }

        self.event_bus.emit(DirectoryScanned::new(directory_path, files_found));
        Ok(files_found)
    }

    fn calculate_file_hash(&self, path: &std::path::PathBuf) -> AppResult<String> {
        use sha2::{Sha256, Digest};
        use std::fs::File as StdFile;
        use std::io::Read;

        let mut file = StdFile::open(path)?;
        let mut hasher = Sha256::new();
        let mut buffer = [0u8; 8192];

        loop {
            let bytes_read = file.read(&mut buffer)?;
            if bytes_read == 0 { break; }
            hasher.update(&buffer[..bytes_read]);
        }

        let result = hasher.finalize();
        Ok(format!("{:x}", result))
    }
}

--- FILE: src-tauri\src\services\mod.rs ---
// src-tauri/src/services/mod.rs
//
// Services Module - Orchestration Layer

pub mod anime_service;
pub mod episode_service;
pub mod file_service;
pub mod playback_service;
pub mod statistics_service;
pub mod external_integration_service;
pub mod subtitle_service;
pub mod playback_observer;
pub mod resolution_service;

#[cfg(test)]
mod resolution_service_tests;

// Re-export all services and their types
pub use anime_service::{
    AnimeService,
    CreateAnimeRequest,
    UpdateAnimeRequest,
    MergeAnimesRequest,
};

pub use episode_service::{
    EpisodeService,
    CreateEpisodeRequest,
    UpdateEpisodeMetadataRequest,
    LinkFileRequest,
};

pub use file_service::{
    FileService,
    RegisterFileRequest,
};

pub use playback_service::{
    PlaybackService,
    StartPlaybackRequest,
};

pub use statistics_service::{
    StatisticsService,
};

pub use external_integration_service::{
    ExternalIntegrationService,
    FetchMetadataRequest,
    LinkExternalReferenceRequest,
    ExternalMetadata,
    MetadataSuggestions,
};

pub use subtitle_service::{
    SubtitleService,
    StyleTransformRequest,
    TimingTransformRequest,
};

--- FILE: src-tauri\src\services\playback_observer.rs ---
// src-tauri/src/services/playback_observer.rs
//
// Playback Observer - Background monitoring of MPV state
//
// CRITICAL RULES:
// - Runs in background task
// - Polls MPV periodically for position, pause state, eof-reached
// - Emits domain events based on observed changes
// - Does NOT persist state directly
// - Does NOT call domain services

use std::sync::{Arc, Mutex};
use std::time::Duration;
use tokio::task::JoinHandle;
use uuid::Uuid;

use crate::integrations::mpv::MpvClient;
use crate::events::EventBus;
use crate::events::types::{PlaybackProgressUpdated, PlaybackFinished, PlaybackStopped};

#[derive(Debug, Clone)]
pub struct ObserverConfig {
    pub poll_interval_ms: u64,
    pub min_progress_delta: u64,
    pub completion_threshold: f32,
}

impl Default for ObserverConfig {
    fn default() -> Self {
        Self {
            poll_interval_ms: 2000,
            min_progress_delta: 5,
            completion_threshold: 0.90,
        }
    }
}

#[derive(Clone)]
struct ObservationSession {
    episode_id: Uuid,
    last_reported_position: u64,
    duration: Option<u64>,
    completed_emitted: bool,
}

pub struct PlaybackObserver {
    mpv_client: Arc<MpvClient>,
    event_bus: Arc<EventBus>,
    config: ObserverConfig,
    current_session: Arc<Mutex<Option<ObservationSession>>>,
    task_handle: Arc<Mutex<Option<JoinHandle<()>>>>,
}

impl PlaybackObserver {
    pub fn new(
        mpv_client: Arc<MpvClient>,
        event_bus: Arc<EventBus>,
        config: ObserverConfig,
    ) -> Self {
        Self {
            mpv_client,
            event_bus,
            config,
            current_session: Arc::new(Mutex::new(None)),
            task_handle: Arc::new(Mutex::new(None)),
        }
    }

    pub fn start_observing(&self, episode_id: Uuid, initial_position: u64, duration: Option<u64>) {
        self.stop_observing();

        {
            let mut session = self.current_session.lock().unwrap();
            *session = Some(ObservationSession {
                episode_id,
                last_reported_position: initial_position,
                duration,
                completed_emitted: false,
            });
        }

        self.spawn_observer_task();
    }

    pub fn stop_observing(&self) {
        {
            let mut session = self.current_session.lock().unwrap();
            *session = None;
        }
        let mut handle = self.task_handle.lock().unwrap();
        if let Some(task) = handle.take() {
            task.abort();
        }
    }

    pub fn is_observing(&self) -> bool {
        self.current_session.lock().unwrap().is_some()
    }

    fn spawn_observer_task(&self) {
        let mpv_client = Arc::clone(&self.mpv_client);
        let event_bus = Arc::clone(&self.event_bus);
        let session = Arc::clone(&self.current_session);
        let config = self.config.clone();

        let task = tokio::spawn(async move {
            let interval = Duration::from_millis(config.poll_interval_ms);

            loop {
                tokio::time::sleep(interval).await;

                let mut current = {
                    let guard = session.lock().unwrap();
                    if let Some(s) = guard.as_ref() {
                        s.clone()
                    } else {
                        break;
                    }
                };

                if !mpv_client.is_running() {
                    event_bus.emit(PlaybackStopped::new(current.episode_id, current.last_reported_position));
                    let mut guard = session.lock().unwrap();
                    *guard = None;
                    break;
                }

                let position = match mpv_client.get_position() {
                    Ok(p) => p,
                    Err(_) => continue,
                };

                // Atualiza duraÃ§Ã£o se ainda desconhecida
                if current.duration.is_none() {
                    if let Ok(Some(dur)) = mpv_client.get_duration() {
                        current.duration = Some(dur);
                    }
                }

                // Verifica conclusÃ£o (90% ou mais)
                let completed = current.completed_emitted || current.duration.map_or(false, |dur| {
                    (position as f32 / dur as f32) >= config.completion_threshold
                });

                if completed && !current.completed_emitted {
                    // Usa duraÃ§Ã£o conhecida ou 0 como fallback
                    let duration_seconds = current.duration.unwrap_or(0);
                    event_bus.emit(PlaybackFinished::new(current.episode_id, duration_seconds));
                    current.completed_emitted = true;
                }

                // Atualiza progresso se mudou significativamente
                let delta = if position > current.last_reported_position {
                    position - current.last_reported_position
                } else {
                    current.last_reported_position - position
                };

                if delta >= config.min_progress_delta {
                    event_bus.emit(PlaybackProgressUpdated::new(current.episode_id, position));
                    current.last_reported_position = position;
                }

                // Atualiza sessÃ£o
                {
                    let mut guard = session.lock().unwrap();
                    if let Some(s) = guard.as_mut() {
                        s.last_reported_position = position;
                        s.duration = current.duration;
                        s.completed_emitted = current.completed_emitted;
                    }
                }
            }
        });

        let mut handle = self.task_handle.lock().unwrap();
        *handle = Some(task);
    }
}

impl Drop for PlaybackObserver {
    fn drop(&mut self) {
        self.stop_observing();
    }
}

--- FILE: src-tauri\src\services\playback_service.rs ---
// src-tauri/src/services/playback_service.rs
//
// Playback Service - Player Integration
//
// PHASE 6 IMPLEMENTATION COMPLETE
// - Launches MPV (if needed) with fixed IPC pipe
// - Loads file via IPC (replace mode)
// - Resumes from saved progress (>5 min threshold)
// - Controls pause/seek/stop via IPC commands
// - Observer handles progress/pause/eof events
// - All state changes go through events â†’ EpisodeService persists

use std::sync::Arc;
use std::process::{Command, Stdio};
use std::io::Write;
use uuid::Uuid;
use std::path::PathBuf;

use crate::integrations::mpv::MpvClient;
use crate::repositories::{EpisodeRepository, FileRepository};
use crate::events::{EventBus, PlaybackStarted, PlaybackProgressUpdated};
use crate::error::{AppError, AppResult};
use crate::services::playback_observer::{PlaybackObserver, ObserverConfig};

const PIPE_NAME: &str = "animehub-mpv";
const RESUME_THRESHOLD_SECONDS: u64 = 300;

#[derive(Debug, Clone)]
pub struct StartPlaybackRequest {
    pub episode_id: Uuid,
    pub file_id: Option<Uuid>,
}

fn send_ipc_command(json_cmd: &str) -> std::io::Result<()> {
    let pipe_path = format!(r"\\.\pipe\{}", PIPE_NAME);
    let mut file = std::fs::OpenOptions::new().write(true).open(pipe_path)?;
    file.write_all(json_cmd.as_bytes())?;
    file.write_all(b"\n")?;
    Ok(())
}

pub struct PlaybackService {
    episode_repo: Arc<dyn EpisodeRepository>,
    file_repo: Arc<dyn FileRepository>,
    event_bus: Arc<EventBus>,
    mpv_client: Arc<MpvClient>,
    observer: Arc<PlaybackObserver>,
}

impl PlaybackService {
    pub fn new(
        episode_repo: Arc<dyn EpisodeRepository>,
        file_repo: Arc<dyn FileRepository>,
        event_bus: Arc<EventBus>,
        mpv_client: Arc<MpvClient>,
    ) -> Self {
        let observer = Arc::new(PlaybackObserver::new(
            mpv_client.clone(),
            event_bus.clone(),
            ObserverConfig::default(),
        ));

        Self {
            episode_repo,
            file_repo,
            event_bus,
            mpv_client,
            observer,
        }
    }

    pub fn start_playback(&self, request: StartPlaybackRequest) -> AppResult<PathBuf> {
        let episode = self.episode_repo.get_by_id(request.episode_id)?.ok_or(AppError::NotFound)?;

        let file_id = request.file_id.or_else(|| {
            self.episode_repo.get_linked_files(request.episode_id).ok().and_then(|links| {
                links.into_iter().find(|&(_, primary)| primary).map(|(id, _)| id)
            })
        }).ok_or(AppError::Other("No video file linked".to_string()))?;

        let file = self.file_repo.get_by_id(file_id)?.ok_or(AppError::NotFound)?;
        if file.tipo != crate::domain::file::FileType::Video {
            return Err(AppError::Other("Not a video file".to_string()));
        }
        if !file.caminho_absoluto.exists() {
            return Err(AppError::Other("File not found on disk".to_string()));
        }

        let saved_progress = episode.progresso_atual;
        let start_pos = if saved_progress >= RESUME_THRESHOLD_SECONDS { saved_progress } else { 0 };

        // CORREÃ‡ÃƒO: is_running retorna Result<bool>
        let is_running = self.mpv_client.is_running();
        if !is_running {
            Command::new("mpv")
                .arg(format!("--input-ipc-server=\\\\.\\pipe\\{}", PIPE_NAME))
                .arg("--idle=yes")
                .arg("--keep-open=yes")
                .arg("--no-terminal")
                .stdout(Stdio::null())
                .stderr(Stdio::null())
                .spawn()
                .map_err(|e| AppError::Other(format!("Failed to launch MPV: {}", e)))?;
        }

        let escaped_path = file.caminho_absoluto.to_string_lossy().replace("\\", "\\\\").replace("\"", "\\\"");
        let load_cmd = format!(r#"{{"command":["loadfile","{}","replace"]}}"#, escaped_path);
        let _ = send_ipc_command(&load_cmd);

        if start_pos > 0 {
            let seek_cmd = format!(r#"{{"command":["seek",{},"absolute"]}}"#, start_pos);
            let _ = send_ipc_command(&seek_cmd);
        }

        self.observer.start_observing(request.episode_id, start_pos, episode.duracao_esperada);

        self.event_bus.emit(PlaybackStarted::new(request.episode_id));

        Ok(file.caminho_absoluto.clone())
    }

    pub fn toggle_pause(&self) -> AppResult<()> {
        let cmd = r#"{"command":["cycle","pause"]}"#;
        send_ipc_command(cmd).map_err(|e| AppError::Other(e.to_string()))?;
        Ok(())
    }

    pub fn seek_to(&self, episode_id: Uuid, position_seconds: u64) -> AppResult<()> {
        let cmd = format!(r#"{{"command":["seek",{},"absolute"]}}"#, position_seconds);
        send_ipc_command(&cmd).map_err(|e| AppError::Other(e.to_string()))?;
        self.report_progress(episode_id, position_seconds)?;
        Ok(())
    }

    pub fn stop_playback(&self, episode_id: Uuid) -> AppResult<()> {
        if let Ok(pos) = self.mpv_client.get_position() {
            self.report_progress(episode_id, pos)?;
        }
        let cmd = r#"{"command":["quit"]}"#;
        let _ = send_ipc_command(cmd);
        self.observer.stop_observing();
        Ok(())
    }

    fn report_progress(&self, episode_id: Uuid, progress_seconds: u64) -> AppResult<()> {
        self.event_bus.emit(PlaybackProgressUpdated::new(episode_id, progress_seconds));
        Ok(())
    }

    // Keep get_current_position if needed elsewhere
    pub fn get_current_position(&self, episode_id: Uuid) -> AppResult<u64> {
        let episode = self.episode_repo.get_by_id(episode_id)?.ok_or(AppError::NotFound)?;
        Ok(episode.progresso_atual)
    }
}

--- FILE: src-tauri\src\services\resolution_service.rs ---
// src-tauri/src/services/resolution_service.rs
//
// Resolution Service - Phase 4
//
// Transforms detected files into resolved domain intent without committing state.
//
// CRITICAL RULES:
// - Consumes persisted File records (from scan phase)
// - Produces resolution results as value objects
// - Emits resolution events (FileResolved, ResolutionFailed, etc.)
// - Does NOT auto-persist Anime/Episode
// - Operates on facts already scanned, not the filesystem
// - Deterministic: same input â†’ same output
// - Idempotent: running twice produces identical results

use std::sync::Arc;
use std::path::PathBuf;
use uuid::Uuid;
use regex::Regex;

use crate::domain::file::{File, FileType};
use crate::domain::resolution::{
    ResolutionResult,
    ResolvedFile,
    ResolvedAnimeIntent,
    ResolvedEpisodeIntent,
    ResolvedEpisodeNumber,
    FileRole,
    ResolutionConfidence,
    ResolutionFailure,
    ResolutionFailureReason,
    ResolutionSource,
};
use crate::domain::anime::Anime;
use crate::repositories::{FileRepository, AnimeRepository, EpisodeRepository};
use crate::events::{
    EventBus,
    FileResolved,
    EpisodeResolved,
    ResolutionFailed,
    ResolutionBatchCompleted,
};
use crate::error::{AppError, AppResult};

// ============================================================================
// RESOLUTION SERVICE
// ============================================================================

pub struct ResolutionService {
    file_repo: Arc<dyn FileRepository>,
    anime_repo: Arc<dyn AnimeRepository>,
    episode_repo: Arc<dyn EpisodeRepository>,
    event_bus: Arc<EventBus>,
    rules: ResolutionRules,
}

impl ResolutionService {
    pub fn new(
        file_repo: Arc<dyn FileRepository>,
        anime_repo: Arc<dyn AnimeRepository>,
        episode_repo: Arc<dyn EpisodeRepository>,
        event_bus: Arc<EventBus>,
    ) -> Self {
        Self {
            file_repo,
            anime_repo,
            episode_repo,
            event_bus,
            rules: ResolutionRules::default(),
        }
    }

    /// Resolve a single file by ID
    pub fn resolve_file(&self, file_id: Uuid) -> AppResult<ResolutionResult> {
        let file = self.file_repo
            .get_by_id(file_id)?
            .ok_or(AppError::NotFound)?;

        let result = self.resolve_file_internal(&file);
        self.emit_resolution_event(&result);
        Ok(result)
    }

    /// Resolve all unresolved video and subtitle files
    pub fn resolve_all_pending(&self) -> AppResult<Vec<ResolutionResult>> {
        let start_time = std::time::Instant::now();
        
        let videos = self.file_repo.list_by_type(FileType::Video)?;
        let legenda_files = self.file_repo.list_by_type(FileType::Legenda)?;
        let mut files = videos;
        files.extend(legenda_files);
        
        let total_files = files.len();
        
        let mut results = Vec::with_capacity(total_files);
        let mut resolved_count = 0;
        let mut failed_count = 0;
        let mut skipped_count = 0;

        for file in files {
            let result = self.resolve_file_internal(&file);
            
            match &result {
                ResolutionResult::Success(_) => resolved_count += 1,
                ResolutionResult::Failure(_) => failed_count += 1,
            }
            
            self.emit_resolution_event(&result);
            results.push(result);
        }

        let duration_ms = start_time.elapsed().as_millis() as u64;
        
        self.event_bus.emit(ResolutionBatchCompleted::new(
            total_files,
            resolved_count,
            failed_count,
            skipped_count,
            duration_ms,
        ));

        Ok(results)
    }

    /// Resolve files in a specific directory (by path prefix)
    pub fn resolve_directory(&self, directory_path: &PathBuf) -> AppResult<Vec<ResolutionResult>> {
        let start_time = std::time::Instant::now();
        
        let videos = self.file_repo.list_by_type(FileType::Video)?;
        let legenda_files = self.file_repo.list_by_type(FileType::Legenda)?;
        
        let files: Vec<File> = videos
            .into_iter()
            .chain(legenda_files.into_iter())
            .filter(|file| file.caminho_absoluto.starts_with(directory_path))
            .collect();
        
        let total_files = files.len();
        
        let mut results = Vec::with_capacity(total_files);
        let mut resolved_count = 0;
        let mut failed_count = 0;
        let mut skipped_count = 0;

        for file in files {
            let result = self.resolve_file_internal(&file);
            
            match &result {
                ResolutionResult::Success(_) => resolved_count += 1,
                ResolutionResult::Failure(_) => failed_count += 1,
            }
            
            self.emit_resolution_event(&result);
            results.push(result);
        }

        let duration_ms = start_time.elapsed().as_millis() as u64;
        
        self.event_bus.emit(ResolutionBatchCompleted::new(
            total_files,
            resolved_count,
            failed_count,
            skipped_count,
            duration_ms,
        ));

        Ok(results)
    }

    // ========================================================================
    // INTERNAL RESOLUTION LOGIC
    // ========================================================================

    fn resolve_file_internal(&self, file: &File) -> ResolutionResult {
        // Step 1: Determine file role
        let role = match file.tipo {
            FileType::Video => FileRole::Video,
            FileType::Legenda => FileRole::Subtitle,
            FileType::Imagem => FileRole::Image,
            FileType::Outro => {
                return ResolutionResult::Failure(ResolutionFailure::new(
                    file.id,
                    file.caminho_absoluto.clone(),
                    ResolutionFailureReason::UnsupportedFileType,
                    "File type 'outro' is not supported for resolution".to_string(),
                ));
            }
        };

        // Step 2: Parse anime title
        let anime_parse_result = self.rules.parse_anime_title(&file.caminho_absoluto);
        let (anime_title, anime_source) = match anime_parse_result {
            Some((title, source)) => (title, source),
            None => {
                return ResolutionResult::Failure(ResolutionFailure::new(
                    file.id,
                    file.caminho_absoluto.clone(),
                    ResolutionFailureReason::UnparsableTitle,
                    "Could not extract anime title from filename or folder".to_string(),
                ));
            }
        };

        // Step 3: Parse episode number
        let episode_parse_result = self.rules.parse_episode_number(&file.caminho_absoluto);
        let (episode_number, episode_source) = match episode_parse_result {
            Some((num, source)) => (num, source),
            None => {
                return ResolutionResult::Failure(ResolutionFailure::new(
                    file.id,
                    file.caminho_absoluto.clone(),
                    ResolutionFailureReason::UnparsableEpisodeNumber,
                    "Could not extract episode number from filename".to_string(),
                ));
            }
        };

        // Step 4: Try to match against existing anime
        let matched_anime_id = self.try_match_anime(&anime_title).ok().flatten();

        // Step 5: Try to match against existing episode (if anime matched)
        let matched_episode_id = if let Some(anime_id) = matched_anime_id {
            self.try_match_episode(anime_id, &episode_number).ok().flatten()
        } else {
            None
        };

        // Step 6: Calculate confidence
        let confidence = self.rules.calculate_confidence(
            &anime_title,
            &episode_number,
            matched_anime_id.is_some(),
            matched_episode_id.is_some(),
            &anime_source,
            &episode_source,
        );

        // Step 7: Check confidence threshold
        if !confidence.meets_threshold() {
            return ResolutionResult::Failure(ResolutionFailure::new(
                file.id,
                file.caminho_absoluto.clone(),
                ResolutionFailureReason::LowConfidence,
                format!(
                    "Confidence {} is below threshold {}",
                    confidence,
                    ResolutionConfidence::THRESHOLD
                ),
            ));
        }

        // Step 8: Build resolved file
        let combined_source = if anime_source == episode_source {
            anime_source
        } else {
            ResolutionSource::Combined
        };

        let anime_intent = if let Some(anime_id) = matched_anime_id {
            ResolvedAnimeIntent::matched(anime_id, anime_title, combined_source.clone())
        } else {
            ResolvedAnimeIntent::from_parsed_title(anime_title, combined_source.clone())
        };

        let episode_intent = if let Some(episode_id) = matched_episode_id {
            ResolvedEpisodeIntent::matched(episode_id, episode_number, combined_source)
        } else {
            ResolvedEpisodeIntent::from_parsed_number(episode_number, combined_source)
        };

        ResolutionResult::Success(ResolvedFile::new(
            file.id,
            file.caminho_absoluto.clone(),
            role,
            anime_intent,
            episode_intent,
            confidence,
        ))
    }

    fn emit_resolution_event(&self, result: &ResolutionResult) {
        match result {
            ResolutionResult::Success(resolved) => {
                self.event_bus.emit(FileResolved::new(
                    resolved.file_id,
                    resolved.file_path.clone(),
                    resolved.anime_intent.title.clone(),
                    resolved.anime_intent.matched_anime_id,
                    resolved.episode_intent.number.to_string(),
                    resolved.episode_intent.matched_episode_id,
                    resolved.role.to_string(),
                    resolved.confidence.score(),
                    resolved.anime_intent.source.to_string(),
                ));
            }
            ResolutionResult::Failure(failure) => {
                self.event_bus.emit(ResolutionFailed::new(
                    failure.file_id,
                    failure.file_path.clone(),
                    failure.reason.to_string(),
                    failure.description.clone(),
                ));
            }
        }
    }

    fn try_match_anime(&self, title: &str) -> AppResult<Option<Uuid>> {
        let animes: Vec<Anime> = self.anime_repo.list_all()?;

        // Try exact match first
        if let Some(anime) = animes.iter().find(|a| a.title == title) {
            return Ok(Some(anime.id));
        }

        // Try normalized match
        let normalized = self.rules.normalize_title(title);
        if let Some(anime) = animes.iter().find(|a| self.rules.normalize_title(&a.title) == normalized) {
            return Ok(Some(anime.id));
        }

        Ok(None)
    }

    fn try_match_episode(
        &self,
        anime_id: Uuid,
        episode_number: &ResolvedEpisodeNumber,
    ) -> AppResult<Option<Uuid>> {
        match episode_number {
            ResolvedEpisodeNumber::Regular { number } => {
                self.episode_repo.find_by_anime_and_number(anime_id, *number)
                    .map(|opt| opt.map(|ep| ep.id))
            }
            ResolvedEpisodeNumber::Special { label } => {
                self.episode_repo.find_by_anime_and_special_label(anime_id, label)
                    .map(|opt| opt.map(|ep| ep.id))
            }
            ResolvedEpisodeNumber::Range { start, .. } => {
                // For ranges, match the first episode
                self.episode_repo.find_by_anime_and_number(anime_id, *start)
                    .map(|opt| opt.map(|ep| ep.id))
            }
        }
    }
}

// ============================================================================
// RESOLUTION RULES (DETERMINISTIC, LAYERED)
// ============================================================================

/// Deterministic rules for parsing and resolving file information.
/// All rules are explicit and ordered.
pub struct ResolutionRules {
    /// Patterns for extracting anime title from filename
    anime_title_patterns: Vec<Regex>,
    
    /// Patterns for extracting episode number from filename
    episode_number_patterns: Vec<Regex>,
    
    /// Patterns for special episode labels
    special_episode_patterns: Vec<Regex>,
}

impl Default for ResolutionRules {
    fn default() -> Self {
        Self {
            anime_title_patterns: vec![
                // [Group] Anime Title - 01 [Quality].mkv
                Regex::new(r"^\[.+?\]\s*(.+?)\s*-\s*\d+").unwrap(),
                // Anime Title - 01.mkv
                Regex::new(r"^(.+?)\s*-\s*\d+").unwrap(),
                // Anime Title S01E01.mkv
                Regex::new(r"^(.+?)\s*S\d+E\d+").unwrap(),
                // Anime Title Episode 01.mkv
                Regex::new(r"^(.+?)\s*[Ee]pisode\s*\d+").unwrap(),
            ],
            episode_number_patterns: vec![
                // - 01, - 001, etc.
                Regex::new(r"-\s*(\d{1,4})(?:\s|\.|\[|$)").unwrap(),
                // S01E01, S1E01
                Regex::new(r"S\d+E(\d+)").unwrap(),
                // Episode 01, Ep 01, EP01
                Regex::new(r"[Ee](?:pisode|p)?\s*(\d+)").unwrap(),
                // #01, #001
                Regex::new(r"#(\d+)").unwrap(),
            ],
            special_episode_patterns: vec![
                // OVA, OVA1, OVA 1
                Regex::new(r"(OVA\s*\d*)").unwrap(),
                // OAD, OAD1
                Regex::new(r"(OAD\s*\d*)").unwrap(),
                // Special, SP, SP1
                Regex::new(r"(Special\s*\d*|SP\s*\d+)").unwrap(),
                // Movie, Film
                Regex::new(r"(Movie|Film)").unwrap(),
            ],
        }
    }
}

impl ResolutionRules {
    /// Parse anime title from file path
    pub fn parse_anime_title(&self, path: &PathBuf) -> Option<(String, ResolutionSource)> {
        // Try filename first
        if let Some(filename) = path.file_stem().and_then(|s| s.to_str()) {
            for pattern in &self.anime_title_patterns {
                if let Some(captures) = pattern.captures(filename) {
                    if let Some(title) = captures.get(1) {
                        let cleaned = self.clean_title(title.as_str());
                        if !cleaned.is_empty() {
                            return Some((cleaned, ResolutionSource::Filename));
                        }
                    }
                }
            }
        }

        // Try parent folder
        if let Some(parent) = path.parent() {
            if let Some(folder_name) = parent.file_name().and_then(|s| s.to_str()) {
                // Clean up folder name (remove [Group], quality tags, etc.)
                let cleaned = self.clean_folder_name(folder_name);
                if !cleaned.is_empty() && cleaned.len() > 2 {
                    return Some((cleaned, ResolutionSource::FolderName));
                }
            }
        }

        None
    }

    /// Parse episode number from file path
    pub fn parse_episode_number(
        &self,
        path: &PathBuf,
    ) -> Option<(ResolvedEpisodeNumber, ResolutionSource)> {
        let filename = path.file_stem().and_then(|s| s.to_str())?;

        // Check for special episodes first
        for pattern in &self.special_episode_patterns {
            if let Some(captures) = pattern.captures(filename) {
                if let Some(label) = captures.get(1) {
                    return Some((
                        ResolvedEpisodeNumber::Special {
                            label: label.as_str().trim().to_string(),
                        },
                        ResolutionSource::Filename,
                    ));
                }
            }
        }

        // Try regular episode patterns
        for pattern in &self.episode_number_patterns {
            if let Some(captures) = pattern.captures(filename) {
                if let Some(num_str) = captures.get(1) {
                    if let Ok(number) = num_str.as_str().parse::<u32>() {
                        return Some((
                            ResolvedEpisodeNumber::Regular { number },
                            ResolutionSource::Filename,
                        ));
                    }
                }
            }
        }

        None
    }

    /// Calculate confidence score based on resolution quality
    pub fn calculate_confidence(
        &self,
        anime_title: &str,
        episode_number: &ResolvedEpisodeNumber,
        anime_matched: bool,
        episode_matched: bool,
        anime_source: &ResolutionSource,
        episode_source: &ResolutionSource,
    ) -> ResolutionConfidence {
        let mut score = 0.5; // Base score

        // Bonus for matching existing entities
        if anime_matched {
            score += 0.2;
        }
        if episode_matched {
            score += 0.15;
        }

        // Bonus for filename-based resolution (most reliable)
        if *anime_source == ResolutionSource::Filename {
            score += 0.1;
        }
        if *episode_source == ResolutionSource::Filename {
            score += 0.1;
        }

        // Penalty for short titles (likely incorrect)
        if anime_title.len() < 3 {
            score -= 0.2;
        }

        // Bonus for regular episode numbers (more common)
        if matches!(episode_number, ResolvedEpisodeNumber::Regular { .. }) {
            score += 0.05;
        }

        ResolutionConfidence::new(score)
    }

    /// Normalize title for matching
    pub fn normalize_title(&self, title: &str) -> String {
        title
            .to_lowercase()
            .replace([':', ';', '!', '?', '.', ','], "")
            .replace(['_', '-'], " ")
            .split_whitespace()
            .collect::<Vec<_>>()
            .join(" ")
    }

    /// Clean up extracted title
    fn clean_title(&self, title: &str) -> String {
        let mut cleaned = title.trim().to_string();
        
        // Remove trailing quality tags
        let quality_patterns = [
            r"\s*\[.*?\]\s*$",
            r"\s*\(.*?\)\s*$",
            r"\s*1080p\s*$",
            r"\s*720p\s*$",
            r"\s*480p\s*$",
            r"\s*HEVC\s*$",
            r"\s*x264\s*$",
            r"\s*x265\s*$",
        ];

        for pattern in quality_patterns {
            if let Ok(re) = Regex::new(pattern) {
                cleaned = re.replace_all(&cleaned, "").to_string();
            }
        }

        cleaned.trim().to_string()
    }

    /// Clean up folder name for title extraction
    fn clean_folder_name(&self, folder: &str) -> String {
        let mut cleaned = folder.to_string();

        // Remove leading [Group] tags
        if let Ok(re) = Regex::new(r"^\[.+?\]\s*") {
            cleaned = re.replace(&cleaned, "").to_string();
        }

        // Remove trailing quality/season tags
        let patterns = [
            r"\s*\[.*?\]\s*$",
            r"\s*\(.*?\)\s*$",
            r"\s*S\d+\s*$",
            r"\s*Season\s*\d+\s*$",
        ];

        for pattern in patterns {
            if let Ok(re) = Regex::new(pattern) {
                cleaned = re.replace_all(&cleaned, "").to_string();
            }
        }

        cleaned.trim().to_string()
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_anime_title_from_filename() {
        let rules = ResolutionRules::default();

        // [SubGroup] Anime Title - 01 [1080p].mkv
        let path = PathBuf::from("[SubGroup] Steins Gate - 01 [1080p].mkv");
        let result = rules.parse_anime_title(&path);
        assert!(result.is_some());
        let (title, source) = result.unwrap();
        assert_eq!(title, "Steins Gate");
        assert_eq!(source, ResolutionSource::Filename);

        // Anime Title - 01.mkv
        let path = PathBuf::from("Attack on Titan - 01.mkv");
        let result = rules.parse_anime_title(&path);
        assert!(result.is_some());
        let (title, _) = result.unwrap();
        assert_eq!(title, "Attack on Titan");
    }

    #[test]
    fn test_parse_episode_number() {
        let rules = ResolutionRules::default();

        // - 01
        let path = PathBuf::from("Anime - 01.mkv");
        let result = rules.parse_episode_number(&path);
        assert!(result.is_some());
        let (num, _) = result.unwrap();
        assert_eq!(num, ResolvedEpisodeNumber::Regular { number: 1 });

        // S01E05
        let path = PathBuf::from("Anime S01E05.mkv");
        let result = rules.parse_episode_number(&path);
        assert!(result.is_some());
        let (num, _) = result.unwrap();
        assert_eq!(num, ResolvedEpisodeNumber::Regular { number: 5 });

        // OVA
        let path = PathBuf::from("Anime OVA.mkv");
        let result = rules.parse_episode_number(&path);
        assert!(result.is_some());
        let (num, _) = result.unwrap();
        assert!(matches!(num, ResolvedEpisodeNumber::Special { .. }));
    }

    #[test]
    fn test_confidence_calculation() {
        let rules = ResolutionRules::default();

        // High confidence: matched anime and episode, filename source
        let confidence = rules.calculate_confidence(
            "Steins;Gate",
            &ResolvedEpisodeNumber::Regular { number: 1 },
            true,
            true,
            &ResolutionSource::Filename,
            &ResolutionSource::Filename,
        );
        assert!(confidence.meets_threshold());
        assert!(confidence.score() > 0.8);

        // Low confidence: no matches, short title
        let confidence = rules.calculate_confidence(
            "AB",
            &ResolvedEpisodeNumber::Special { label: "?".to_string() },
            false,
            false,
            &ResolutionSource::FolderName,
            &ResolutionSource::FolderName,
        );
        assert!(!confidence.meets_threshold());
    }

    #[test]
    fn test_normalize_title() {
        let rules = ResolutionRules::default();

        assert_eq!(
            rules.normalize_title("Steins;Gate"),
            "steinsgate"
        );
        assert_eq!(
            rules.normalize_title("Attack_on_Titan"),
            "attack on titan"
        );
        assert_eq!(
            rules.normalize_title("Re:Zero"),
            "rezero"
        );
    }
}

--- FILE: src-tauri\src\services\resolution_service_tests.rs ---
// src-tauri/examples/resolution_service_tests.rs
//
// PHASE 4 UNIT TESTS: Resolution Service Idempotency
//
// PURPOSE:
// - Prove that resolution is idempotent: same input â†’ same output
// - Prove that resolution is deterministic: no randomness in results
// - Prove that resolution does not mutate domain state
//
// INVARIANTS TESTED:
// - Running resolve_file(id) twice returns identical ResolutionResult
// - Running resolve_all_pending() twice returns identical Vec<ResolutionResult>
// - No Anime or Episode entities are created during resolution
// - Confidence scores are deterministic

#[cfg(test)]
mod idempotency_tests {
    use crate::domain::resolution::{
        ResolutionResult,
        ResolvedFile,
        ResolvedAnimeIntent,
        ResolvedEpisodeIntent,
        ResolvedEpisodeNumber,
        FileRole,
        ResolutionConfidence,
        ResolutionSource,
    };
    use std::path::PathBuf;
    use uuid::Uuid;

    /// Test that ResolutionResult comparison works correctly
    #[test]
    fn test_resolution_result_equality() {
        let file_id = Uuid::new_v4();
        let path = PathBuf::from("/test/anime/Episode 01.mkv");

        let result1 = ResolutionResult::Success(ResolvedFile::new(
            file_id,
            path.clone(),
            FileRole::Video,
            ResolvedAnimeIntent::from_parsed_title("Test Anime".to_string(), ResolutionSource::Filename),
            ResolvedEpisodeIntent::from_parsed_number(
                ResolvedEpisodeNumber::Regular { number: 1 },
                ResolutionSource::Filename,
            ),
            ResolutionConfidence::high(),
        ));

        let result2 = ResolutionResult::Success(ResolvedFile::new(
            file_id,
            path.clone(),
            FileRole::Video,
            ResolvedAnimeIntent::from_parsed_title("Test Anime".to_string(), ResolutionSource::Filename),
            ResolvedEpisodeIntent::from_parsed_number(
                ResolvedEpisodeNumber::Regular { number: 1 },
                ResolutionSource::Filename,
            ),
            ResolutionConfidence::high(),
        ));

        // Both should be successful
        assert!(result1.is_success());
        assert!(result2.is_success());

        // Extract and compare
        let r1 = result1.resolved_file().unwrap();
        let r2 = result2.resolved_file().unwrap();

        assert_eq!(r1.file_id, r2.file_id);
        assert_eq!(r1.anime_intent.title, r2.anime_intent.title);
        assert_eq!(r1.episode_intent.number.to_string(), r2.episode_intent.number.to_string());
        assert_eq!(r1.confidence.score(), r2.confidence.score());
    }

    /// Test that confidence calculation is deterministic
    #[test]
    fn test_confidence_determinism() {
        use crate::services::resolution_service::ResolutionRules;

        let rules = ResolutionRules::default();

        // Calculate confidence multiple times with same input
        let mut scores = Vec::new();
        for _ in 0..100 {
            let confidence = rules.calculate_confidence(
                "Steins;Gate",
                &ResolvedEpisodeNumber::Regular { number: 1 },
                true,
                true,
                &ResolutionSource::Filename,
                &ResolutionSource::Filename,
            );
            scores.push(confidence.score());
        }

        // All scores must be identical
        let first = scores[0];
        for score in &scores {
            assert!(
                (score - first).abs() < f64::EPSILON,
                "Confidence scores differ: {} vs {}",
                first,
                score
            );
        }
    }

    /// Test that title parsing is deterministic
    #[test]
    fn test_title_parsing_determinism() {
        use crate::services::resolution_service::ResolutionRules;

        let rules = ResolutionRules::default();
        let path = PathBuf::from("[SubGroup] Steins Gate - 01 [1080p].mkv");

        // Parse multiple times
        let mut results = Vec::new();
        for _ in 0..100 {
            let result = rules.parse_anime_title(&path);
            results.push(result);
        }

        // All results must be identical
        let first = &results[0];
        for result in &results {
            assert_eq!(result, first, "Title parsing results differ");
        }
    }

    /// Test that episode number parsing is deterministic
    #[test]
    fn test_episode_parsing_determinism() {
        use crate::services::resolution_service::ResolutionRules;

        let rules = ResolutionRules::default();
        let path = PathBuf::from("Anime - 05.mkv");

        // Parse multiple times
        let mut results = Vec::new();
        for _ in 0..100 {
            let result = rules.parse_episode_number(&path);
            results.push(result);
        }

        // All results must be identical
        let first = &results[0];
        for result in &results {
            match (result, first) {
                (Some((num1, src1)), Some((num2, src2))) => {
                    assert_eq!(num1.to_string(), num2.to_string());
                    assert_eq!(src1, src2);
                }
                (None, None) => {}
                _ => panic!("Episode parsing results differ"),
            }
        }
    }

    /// Test that normalization is deterministic
    #[test]
    fn test_normalization_determinism() {
        use crate::services::resolution_service::ResolutionRules;

        let rules = ResolutionRules::default();
        let titles = vec![
            "Steins;Gate",
            "Attack on Titan",
            "Re:Zero",
            "Sword Art Online",
            "My Hero Academia!",
        ];

        for title in titles {
            let mut normalizations = Vec::new();
            for _ in 0..100 {
                normalizations.push(rules.normalize_title(title));
            }

            let first = &normalizations[0];
            for norm in &normalizations {
                assert_eq!(norm, first, "Normalization differs for '{}'", title);
            }
        }
    }
}

#[cfg(test)]
mod resolution_rules_tests {
    use crate::services::resolution_service::ResolutionRules;
    use crate::domain::resolution::{ResolvedEpisodeNumber, ResolutionSource};
    use std::path::PathBuf;

    #[test]
    fn test_parse_anime_title_various_formats() {
        let rules = ResolutionRules::default();

        let test_cases = vec![
            // (filename, expected_title)
            ("[SubGroup] Steins Gate - 01 [1080p].mkv", "Steins Gate"),
            ("Attack on Titan - 01.mkv", "Attack on Titan"),
            ("Naruto S01E01.mkv", "Naruto"),
            ("One Piece Episode 01.mkv", "One Piece"),
        ];

        for (filename, expected) in test_cases {
            let path = PathBuf::from(filename);
            let result = rules.parse_anime_title(&path);
            assert!(result.is_some(), "Failed to parse: {}", filename);
            let (title, _) = result.unwrap();
            assert_eq!(title, expected, "Title mismatch for: {}", filename);
        }
    }

    #[test]
    fn test_parse_episode_number_various_formats() {
        let rules = ResolutionRules::default();

        let test_cases = vec![
            // (filename, expected_number)
            ("Anime - 01.mkv", ResolvedEpisodeNumber::Regular { number: 1 }),
            ("Anime - 12.mkv", ResolvedEpisodeNumber::Regular { number: 12 }),
            ("Anime S01E05.mkv", ResolvedEpisodeNumber::Regular { number: 5 }),
            ("Anime Episode 10.mkv", ResolvedEpisodeNumber::Regular { number: 10 }),
            ("Anime #03.mkv", ResolvedEpisodeNumber::Regular { number: 3 }),
        ];

        for (filename, expected) in test_cases {
            let path = PathBuf::from(filename);
            let result = rules.parse_episode_number(&path);
            assert!(result.is_some(), "Failed to parse: {}", filename);
            let (number, _) = result.unwrap();
            assert_eq!(number, expected, "Number mismatch for: {}", filename);
        }
    }

    #[test]
    fn test_parse_special_episodes() {
        let rules = ResolutionRules::default();

        let test_cases = vec![
            ("Anime OVA.mkv", "OVA"),
            ("Anime OVA 1.mkv", "OVA 1"),
            ("Anime OAD.mkv", "OAD"),
            ("Anime Special.mkv", "Special"),
            ("Anime Movie.mkv", "Movie"),
        ];

        for (filename, expected_label) in test_cases {
            let path = PathBuf::from(filename);
            let result = rules.parse_episode_number(&path);
            assert!(result.is_some(), "Failed to parse: {}", filename);
            let (number, _) = result.unwrap();
            match number {
                ResolvedEpisodeNumber::Special { label } => {
                    assert!(
                        label.contains(expected_label) || expected_label.contains(&label),
                        "Label mismatch for {}: got '{}', expected '{}'",
                        filename,
                        label,
                        expected_label
                    );
                }
                _ => panic!("Expected Special episode for: {}", filename),
            }
        }
    }

    #[test]
    fn test_confidence_thresholds() {
        use crate::domain::resolution::ResolutionConfidence;

        // High confidence (matched anime + episode, filename source)
        let rules = ResolutionRules::default();
        let high = rules.calculate_confidence(
            "Steins;Gate",
            &ResolvedEpisodeNumber::Regular { number: 1 },
            true,
            true,
            &ResolutionSource::Filename,
            &ResolutionSource::Filename,
        );
        assert!(high.meets_threshold(), "High confidence should meet threshold");
        assert!(high.score() > 0.8, "High confidence should be > 0.8");

        // Medium confidence (matched anime only)
        let medium = rules.calculate_confidence(
            "Steins;Gate",
            &ResolvedEpisodeNumber::Regular { number: 1 },
            true,
            false,
            &ResolutionSource::Filename,
            &ResolutionSource::Filename,
        );
        assert!(medium.meets_threshold(), "Medium confidence should meet threshold");

        // Low confidence (no matches, folder source)
        let low = rules.calculate_confidence(
            "Unknown",
            &ResolvedEpisodeNumber::Regular { number: 1 },
            false,
            false,
            &ResolutionSource::FolderName,
            &ResolutionSource::FolderName,
        );
        assert!(!low.meets_threshold() || low.score() < 0.7, "Low confidence should be lower");

        // Very low confidence (short title)
        let very_low = rules.calculate_confidence(
            "AB",
            &ResolvedEpisodeNumber::Special { label: "?".to_string() },
            false,
            false,
            &ResolutionSource::FolderName,
            &ResolutionSource::FolderName,
        );
        assert!(!very_low.meets_threshold(), "Very low confidence should not meet threshold");
    }

    #[test]
    fn test_title_normalization() {
        let rules = ResolutionRules::default();

        assert_eq!(rules.normalize_title("Steins;Gate"), "steinsgate");
        assert_eq!(rules.normalize_title("Attack on Titan"), "attack on titan");
        assert_eq!(rules.normalize_title("Re:Zero"), "rezero");
        assert_eq!(rules.normalize_title("Sword_Art_Online"), "sword art online");
        assert_eq!(rules.normalize_title("My Hero Academia!"), "my hero academia");
        assert_eq!(rules.normalize_title("  Spaced  Title  "), "spaced title");
    }
}

#[cfg(test)]
mod value_object_tests {
    use crate::domain::resolution::*;
    use std::path::PathBuf;
    use uuid::Uuid;

    #[test]
    fn test_resolved_file_immutability() {
        let file_id = Uuid::new_v4();
        let resolved = ResolvedFile::new(
            file_id,
            PathBuf::from("/test/file.mkv"),
            FileRole::Video,
            ResolvedAnimeIntent::from_parsed_title("Test".to_string(), ResolutionSource::Filename),
            ResolvedEpisodeIntent::from_parsed_number(
                ResolvedEpisodeNumber::Regular { number: 1 },
                ResolutionSource::Filename,
            ),
            ResolutionConfidence::high(),
        );

        // Verify all fields are accessible
        assert_eq!(resolved.file_id, file_id);
        assert_eq!(resolved.role, FileRole::Video);
        assert_eq!(resolved.anime_intent.title, "Test");
        assert!(resolved.confidence.meets_threshold());

        // Note: No &mut self methods exist, proving immutability
    }

    #[test]
    fn test_resolution_failure_creation() {
        let file_id = Uuid::new_v4();
        let failure = ResolutionFailure::new(
            file_id,
            PathBuf::from("/test/unknown.bin"),
            ResolutionFailureReason::UnsupportedFileType,
            "Binary files not supported".to_string(),
        );

        assert_eq!(failure.file_id, file_id);
        assert_eq!(failure.reason, ResolutionFailureReason::UnsupportedFileType);
        assert!(!failure.description.is_empty());
    }

    #[test]
    fn test_file_role_display() {
        assert_eq!(FileRole::Video.to_string(), "video");
        assert_eq!(FileRole::Subtitle.to_string(), "subtitle");
        assert_eq!(FileRole::Image.to_string(), "image");
        assert_eq!(FileRole::Auxiliary.to_string(), "auxiliary");
    }

    #[test]
    fn test_episode_number_variants() {
        let regular = ResolvedEpisodeNumber::Regular { number: 5 };
        assert_eq!(regular.to_string(), "5");

        let special = ResolvedEpisodeNumber::Special { label: "OVA 1".to_string() };
        assert_eq!(special.to_string(), "OVA 1");

        let range = ResolvedEpisodeNumber::Range { start: 1, end: 3 };
        assert_eq!(range.to_string(), "1-3");
    }

    #[test]
    fn test_confidence_clamping() {
        let over = ResolutionConfidence::new(1.5);
        assert_eq!(over.score(), 1.0);

        let under = ResolutionConfidence::new(-0.5);
        assert_eq!(under.score(), 0.0);

        let normal = ResolutionConfidence::new(0.75);
        assert_eq!(normal.score(), 0.75);
    }

    #[test]
    fn test_resolution_source_display() {
        assert_eq!(ResolutionSource::Filename.to_string(), "filename");
        assert_eq!(ResolutionSource::FolderName.to_string(), "folder_name");
        assert_eq!(ResolutionSource::FolderHierarchy.to_string(), "folder_hierarchy");
        assert_eq!(ResolutionSource::DatabaseMatch.to_string(), "database_match");
        assert_eq!(ResolutionSource::Combined.to_string(), "combined");
    }
}


--- FILE: src-tauri\src\services\services\mod.rs ---
// Module root â€” intentionally empty


--- FILE: src-tauri\src\services\statistics_service.rs ---
// src-tauri/src/services/statistics_service.rs
use std::sync::Arc;
use uuid::Uuid;
use chrono::Utc;
use crate::domain::statistics::{
    StatisticsSnapshot, StatisticsType, GlobalStatistics, AnimeStatistics
};
use crate::domain::episode::EpisodeState;
use crate::repositories::{StatisticsRepository, AnimeRepository, EpisodeRepository};
use crate::events::{EventBus, StatisticsUpdated, EpisodeCompleted};
use crate::error::AppResult;

pub struct StatisticsService {
    statistics_repo: Arc<dyn StatisticsRepository>,
    anime_repo: Arc<dyn AnimeRepository>,
    episode_repo: Arc<dyn EpisodeRepository>,
    event_bus: Arc<EventBus>,
}

impl StatisticsService {
    pub fn new(
        statistics_repo: Arc<dyn StatisticsRepository>,
        anime_repo: Arc<dyn AnimeRepository>,
        episode_repo: Arc<dyn EpisodeRepository>,
        event_bus: Arc<EventBus>,
    ) -> Self {
        Self {
            statistics_repo,
            anime_repo,
            episode_repo,
            event_bus,
        }
    }

    pub fn calculate_global_statistics(&self) -> AppResult<GlobalStatistics> {
        let animes = self.anime_repo.list_all()?;
        let mut total_episodes = 0;
        let mut episodes_assistidos = 0;
        let mut tempo_total_assistido = 0u64;
        let mut animes_em_progresso = 0;
        let mut animes_completos = 0;

        for anime in &animes {
            let episodes = self.episode_repo.list_by_anime(anime.id)?;
            let mut anime_has_progress = false;
            let mut all_episodes_done = !episodes.is_empty();

            for ep in &episodes {
                total_episodes += 1;
                tempo_total_assistido += ep.progresso_atual;

                if ep.estado == EpisodeState::Concluido {
                    episodes_assistidos += 1;
                    anime_has_progress = true;
                } else if ep.progresso_atual > 0 {
                    anime_has_progress = true;
                    all_episodes_done = false;
                } else {
                    all_episodes_done = false;
                }
            }

            if all_episodes_done {
                animes_completos += 1;
            } else if anime_has_progress {
                animes_em_progresso += 1;
            }
        }

        let stats = GlobalStatistics {
            total_animes: animes.len() as u32,
            total_episodes,
            episodes_assistidos,
            tempo_total_assistido,
            animes_em_progresso,
            animes_completos,
        };

        let snapshot = StatisticsSnapshot::new(
            StatisticsType::Global,
            serde_json::to_value(&stats)?,
        );

        self.statistics_repo.save_snapshot(&snapshot)?;
        Ok(stats)
    }

    pub fn register_event_handlers(&self) {
        let episode_repo = Arc::clone(&self.episode_repo);
        let statistics_repo = Arc::clone(&self.statistics_repo);
        let event_bus = Arc::clone(&self.event_bus);

        self.event_bus.subscribe::<EpisodeCompleted, _>(move |event| {
            if let Ok(episodes) = episode_repo.list_by_anime(event.anime_id) {
                let total_episodes = episodes.len() as u32;
                let mut episodes_assistidos = 0;
                let mut tempo_assistido = 0u64;

                for ep in &episodes {
                    if ep.estado == EpisodeState::Concluido {
                        episodes_assistidos += 1;
                    }
                    tempo_assistido += ep.progresso_atual;
                }

                let progresso_percentual = if total_episodes > 0 {
                    (episodes_assistidos as f32 / total_episodes as f32) * 100.0
                } else {
                    0.0
                };

                let stats = AnimeStatistics {
                    anime_id: event.anime_id,
                    total_episodes,
                    episodes_assistidos,
                    tempo_assistido,
                    progresso_percentual,
                    ultimo_episodio_assistido: Some(event.episode_id),
                    data_ultima_visualizacao: Some(Utc::now()),
                };

                let snapshot = StatisticsSnapshot::new(
                    StatisticsType::PorAnime { anime_id: event.anime_id },
                    serde_json::to_value(&stats).unwrap(),
                );

                let _ = statistics_repo.save_snapshot(&snapshot);
            }
            event_bus.emit(StatisticsUpdated::new());
        });
    }
}

--- FILE: src-tauri\src\services\subtitle_service.rs ---
// src-tauri/src/services/subtitle_service.rs
use std::sync::Arc;
use std::path::{Path, PathBuf};
use uuid::Uuid;
use crate::domain::subtitle::{SubtitleFormat, SubtitleTransformation, TransformationType};
use crate::repositories::{SubtitleRepository, FileRepository};
use crate::events::{EventBus, SubtitleStyleApplied, SubtitleTimingAdjusted, SubtitleVersionCreated};
use crate::infrastructure::subtitle_workspace::{SubtitleWorkspace, SubtitleWorkspaceCreated, SubtitleWorkspaceCleaned};
use crate::error::{AppError, AppResult};

#[derive(Debug, Clone)]
pub struct StyleTransformRequest {
    pub subtitle_id: Uuid,
    pub font_name: Option<String>,
    pub font_size: Option<u32>,
    pub primary_color: Option<String>,
    pub outline_color: Option<String>,
    pub outline_width: Option<f32>,
    pub shadow_offset: Option<f32>,
}

#[derive(Debug, Clone)]
pub struct TimingTransformRequest {
    pub subtitle_id: Uuid,
    pub offset_ms: i64,
}

pub struct SubtitleService {
    subtitle_repo: Arc<dyn SubtitleRepository>,
    file_repo: Arc<dyn FileRepository>,
    event_bus: Arc<EventBus>,
}

impl SubtitleService {
    pub fn new(
        subtitle_repo: Arc<dyn SubtitleRepository>,
        file_repo: Arc<dyn FileRepository>,
        event_bus: Arc<EventBus>,
    ) -> Self {
        Self {
            subtitle_repo,
            file_repo,
            event_bus,
        }
    }

    pub fn apply_style_transformation(&self, request: StyleTransformRequest) -> AppResult<Uuid> {
        let params = serde_json::json!({
            "font_name": request.font_name,
            "font_size": request.font_size,
        });

        self.execute_transformation_pipeline(
            request.subtitle_id,
            TransformationType::Style,
            params,
            |path, format| self.apply_style_to_file(path, format, &request),
            |original_id, new_id| {
                self.event_bus.emit(SubtitleStyleApplied::new(original_id, new_id));
            }
        )
    }

    pub fn apply_timing_transformation(&self, request: TimingTransformRequest) -> AppResult<Uuid> {
        let params = serde_json::json!({ "offset_ms": request.offset_ms });
        self.execute_transformation_pipeline(
            request.subtitle_id,
            TransformationType::Timing,
            params,
            |path, format| self.apply_timing_to_file(path, format, request.offset_ms),
            |original_id, new_id| {
                self.event_bus.emit(SubtitleTimingAdjusted::new(original_id, new_id, request.offset_ms));
            }
        )
    }

    pub fn get_transformation_history(&self, subtitle_id: Uuid) -> AppResult<Vec<SubtitleTransformation>> {
        self.subtitle_repo.get_transformations(subtitle_id)
    }

    fn execute_transformation_pipeline<F, E>(
        &self,
        subtitle_id: Uuid,
        trans_type: TransformationType,
        params: serde_json::Value,
        transform_fn: F,
        emit_custom_event: E,
    ) -> AppResult<Uuid> 
    where 
        F: FnOnce(&Path, &SubtitleFormat) -> AppResult<()>,
        E: FnOnce(Uuid, Uuid),
    {
        let original = self.subtitle_repo
            .get_subtitle_by_id(subtitle_id)?
            .ok_or(AppError::NotFound)?;

        let original_file = self.file_repo
            .get_by_id(original.file_id)?
            .ok_or(AppError::NotFound)?;

        let mut workspace = SubtitleWorkspace::new(original_file.caminho_absoluto.clone())?;
        self.event_bus.emit(SubtitleWorkspaceCreated::new(workspace.id, original.id));

        transform_fn(workspace.working_file_path(), &original.formato)?;

        let new_file_path = self.generate_versioned_path(&original_file.caminho_absoluto, original.versao + 1);
        workspace.copy_working_file_to(&new_file_path)?;

        let file_metadata = std::fs::metadata(&new_file_path)?;
        let new_file = crate::domain::file::File::new(
            new_file_path,
            crate::domain::file::FileType::Legenda,
            file_metadata.len(),
            chrono::DateTime::from(file_metadata.modified().unwrap_or(std::time::SystemTime::now())),
            crate::domain::file::FileOrigin::Manual,
        );

        self.file_repo.save(&new_file)?;

        let new_subtitle = original.derive_from(new_file.id, original.formato);
        self.subtitle_repo.save_subtitle(&new_subtitle)?;

        let transformation = SubtitleTransformation::new(original.id, trans_type, params);
        self.subtitle_repo.save_transformation(&transformation)?;

        emit_custom_event(original.id, new_subtitle.id);
        self.event_bus.emit(SubtitleVersionCreated::new(new_subtitle.id, new_subtitle.versao));

        workspace.cleanup()?;
        self.event_bus.emit(SubtitleWorkspaceCleaned::new(workspace.id));

        Ok(new_subtitle.id)
    }

    fn apply_style_to_file(&self, file_path: &Path, format: &SubtitleFormat, request: &StyleTransformRequest) -> AppResult<()> {
        match format {
            SubtitleFormat::ASS => self.apply_style_to_ass(file_path, request),
            _ => Ok(()),
        }
    }

    fn apply_timing_to_file(&self, file_path: &Path, format: &SubtitleFormat, offset_ms: i64) -> AppResult<()> {
        match format {
            SubtitleFormat::ASS => self.apply_timing_to_ass(file_path, offset_ms),
            SubtitleFormat::SRT | SubtitleFormat::VTT => self.apply_timing_to_srt(file_path, offset_ms),
        }
    }

    fn generate_versioned_path(&self, original: &PathBuf, version: u32) -> PathBuf {
        let stem = original.file_stem().and_then(|s| s.to_str()).unwrap_or("subtitle");
        let ext = original.extension().and_then(|e| e.to_str()).unwrap_or("srt");
        let parent = original.parent().unwrap_or(Path::new("."));
        parent.join(format!("{}.v{}.{}", stem, version, ext))
    }

    fn apply_style_to_ass(&self, path: &Path, request: &StyleTransformRequest) -> AppResult<()> {
        let content = std::fs::read_to_string(path)?;
        let mut lines: Vec<String> = content.lines().map(|s| s.to_string()).collect();
        let mut in_styles = false;

        for line in lines.iter_mut() {
            if line.starts_with("[V4+ Styles]") {
                in_styles = true;
                continue;
            }
            if in_styles && line.starts_with("Style:") {
                let parts: Vec<&str> = line.split(',').collect();
                if parts.len() > 10 {
                    let mut new_parts: Vec<String> = parts.iter().map(|&s| s.to_string()).collect();
                    if let Some(ref font) = request.font_name {
                        new_parts[1] = font.clone();
                    }
                    if let Some(size) = request.font_size {
                        new_parts[2] = size.to_string();
                    }
                    *line = new_parts.join(",");
                }
            }
            if in_styles && line.is_empty() {
                in_styles = false;
            }
        }
        std::fs::write(path, lines.join("\n"))?;
        Ok(())
    }

    fn apply_timing_to_ass(&self, _path: &Path, _offset_ms: i64) -> AppResult<()> { Ok(()) }
    fn apply_timing_to_srt(&self, _path: &Path, _offset_ms: i64) -> AppResult<()> { Ok(()) }
}

--- FILE: src-tauri\tauri.conf.json ---
{
    "$schema": "../gen/schemas/desktop-schema.json",
    "productName": "AnimeHub",
    "version": "0.1.0",
    "identifier": "com.animehub.app",
    "build": {
        "beforeDevCommand": "npm run dev",
        "beforeBuildCommand": "npm run build",
        "devUrl": "http://localhost:5173"
    },
    "app": {
        "windows": [
            {
                "title": "AnimeHub",
                "width": 1280,
                "height": 800,
                "resizable": true,
                "fullscreen": false
            }
        ],
        "security": {
            "csp": null
        }
    },
    "plugins": {
        "dialog": null
    }
}

--- FILE: src\app.css ---


--- FILE: src\app.html ---
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <link rel="icon" href="%sveltekit.assets%/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    %sveltekit.head%
</head>

<body data-sveltekit-preload-data="hover">
    <div style="display: contents">%sveltekit.body%</div>
</body>

</html>

--- FILE: src\lib\api\anime.ts ---


--- FILE: src\lib\api\episode.ts ---


--- FILE: src\lib\api\file.ts ---


--- FILE: src\lib\api\playback.ts ---


--- FILE: src\lib\api\subtitle.ts ---


--- FILE: src\lib\components\anime\AnimeHeader.svelte ---


--- FILE: src\lib\components\anime\EpisodeItem.svelte ---


--- FILE: src\lib\components\anime\EpisodeList.svelte ---


--- FILE: src\lib\components\common\Sidebar.svelte ---


--- FILE: src\lib\components\library\AnimeCard.svelte ---


--- FILE: src\lib\components\library\AnimeGrid.svelte ---


--- FILE: src\lib\stores\anime.ts ---


--- FILE: src\lib\stores\episode.ts ---


--- FILE: src\lib\stores\playback.ts ---


--- FILE: src\lib\stores\ui.ts ---


--- FILE: src\lib\types\anime.ts ---


--- FILE: src\lib\types\episode.ts ---


--- FILE: src\lib\types\events.ts ---


--- FILE: src\lib\types\file.ts ---


--- FILE: src\lib\types\subtitle.ts ---


--- FILE: src\routes\+layout.svelte ---


--- FILE: src\routes\+page.svelte ---


--- FILE: src\routes\anime\[id]\+page.svelte ---


--- FILE: src\routes\calendar\+page.svelte ---


--- FILE: src\routes\library\+page.svelte ---


--- FILE: src\routes\statistics\+page.svelte ---


--- FILE: src\routes\subtitles\+page.svelte ---


--- FILE: svelte.config.js ---
import adapter from '@sveltejs/adapter-static';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
    preprocess: vitePreprocess(),

    kit: {
        adapter: adapter({
            pages: 'build',
            assets: 'build',
            fallback: 'index.html',
            precompress: false,
            strict: true
        }),
        alias: {
            $lib: './src/lib',
            $components: './src/lib/components',
            $stores: './src/lib/stores',
            $types: './src/lib/types',
            $api: './src/lib/api'
        }
    }
};

export default config;

--- FILE: tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
export default {
    content: ['./src/**/*.{html,js,svelte,ts}'],
    theme: {
        extend: {
            colors: {
                // Dark mode palette
                background: {
                    primary: '#0a0a0a',
                    secondary: '#141414',
                    tertiary: '#1e1e1e'
                },
                text: {
                    primary: '#ffffff',
                    secondary: '#a0a0a0',
                    tertiary: '#707070'
                },
                accent: {
                    primary: '#3b82f6',
                    hover: '#2563eb'
                },
                state: {
                    completed: '#22c55e',
                    progress: '#f59e0b',
                    unwatched: '#6b7280',
                    error: '#ef4444'
                }
            },
            fontFamily: {
                sans: ['Inter', 'system-ui', 'sans-serif']
            }
        }
    },
    plugins: []
};

--- FILE: vite.config.ts ---
import { defineConfig } from 'vite';
import { sveltekit } from '@sveltejs/kit/vite';

export default defineConfig({
    plugins: [sveltekit()],
    clearScreen: false,
    server: {
        port: 5173,
        strictPort: true,
        watch: {
            ignored: ['**/src-tauri/**']
        }
    },
    envPrefix: ['VITE_', 'TAURI_'],
    build: {
        target: 'esnext',
        minify: !process.env.TAURI_DEBUG ? 'esbuild' : false,
        sourcemap: !!process.env.TAURI_DEBUG
    }
});
